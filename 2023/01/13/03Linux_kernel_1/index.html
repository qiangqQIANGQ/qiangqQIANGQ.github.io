<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Linux内核分析应用一 - 多进程共享内存内核驱动模块 上一章节分析到 Linux 的虚拟地址空间布局，正好这段时间在学 Linux 内核，这部分内存管理是上一篇文章的有力实践，通过自己实现一个内核模块，可以进一步加深对 Linux 内存管理的认识，同时也对 Linux 内核开发有个学习！源代码在文末我放在 Gitee 上了，友友们遇到 bug 可以自行对照一下。  驱动功能演示​	目标：实现一">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核分析应用一 - 多进程共享内存内核驱动模块">
<meta property="og:url" content="https://www.chaceq.love/2023/01/13/03Linux_kernel_1/index.html">
<meta property="og:site_name" content="chaceq.love">
<meta property="og:description" content="Linux内核分析应用一 - 多进程共享内存内核驱动模块 上一章节分析到 Linux 的虚拟地址空间布局，正好这段时间在学 Linux 内核，这部分内存管理是上一篇文章的有力实践，通过自己实现一个内核模块，可以进一步加深对 Linux 内存管理的认识，同时也对 Linux 内核开发有个学习！源代码在文末我放在 Gitee 上了，友友们遇到 bug 可以自行对照一下。  驱动功能演示​	目标：实现一">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/01/13/ZLTczpjRBvfghsq.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/13/KXgIW9BOz5l7pkn.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/13/uptW5Vl9XTZOaCq.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/13/7XbBUgv9NDpwCdJ.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/12/3ScKFZluzn9Bri5.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/12/MEzu5V6x4Y1SrWv.png">
<meta property="og:image" content="https://s2.loli.net/2023/01/12/k4js9oRAYviTa7t.png">
<meta property="article:published_time" content="2023-01-13T14:18:40.830Z">
<meta property="article:modified_time" content="2023-01-18T07:34:18.504Z">
<meta property="article:author" content="sqq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/01/13/ZLTczpjRBvfghsq.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Linux内核分析应用一 - 多进程共享内存内核驱动模块</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/Operation_System/">Operation System</a></li><!--
     --><!--
       --><li><a href="/Computer_Networks/">Computer Networks</a></li><!--
     --><!--
       --><li><a href="/General/">General</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/01/16/04Linux_fileSystem/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2022/12/28/02malloc_1/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&text=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&is_video=false&description=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux内核分析应用一 - 多进程共享内存内核驱动模块&body=Check out this article: https://www.chaceq.love/2023/01/13/03Linux_kernel_1/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&name=Linux内核分析应用一 - 多进程共享内存内核驱动模块&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&t=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E4%B8%80-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">Linux内核分析应用一 - 多进程共享内存内核驱动模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">驱动功能演示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内核开发原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">代码流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-driver-c"><span class="toc-number">4.0.1.</span> <span class="toc-text">map_driver.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maptest-read-c"><span class="toc-number">4.0.2.</span> <span class="toc-text">maptest_read.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maptest-write-c"><span class="toc-number">4.0.3.</span> <span class="toc-text">maptest_write.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile"><span class="toc-number">4.0.4.</span> <span class="toc-text">Makefile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B8%A9%E5%9D%91%E8%A1%A5%E5%85%85"><span class="toc-number">4.1.</span> <span class="toc-text">踩坑补充</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Linux内核分析应用一 - 多进程共享内存内核驱动模块
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">sqq</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-01-13T14:18:40.830Z" class="dt-published" itemprop="datePublished">2023-01-13</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Linux内核分析应用一-多进程共享内存内核驱动模块"><a href="#Linux内核分析应用一-多进程共享内存内核驱动模块" class="headerlink" title="Linux内核分析应用一 - 多进程共享内存内核驱动模块"></a>Linux内核分析应用一 - 多进程共享内存内核驱动模块</h1><blockquote>
<p>上一章节分析到 Linux 的虚拟地址空间布局，正好这段时间在学 Linux 内核，这部分内存管理是上一篇文章的有力实践，通过自己实现一个内核模块，可以进一步加深对 Linux 内存管理的认识，同时也对 Linux 内核开发有个学习！源代码在文末我放在 Gitee 上了，友友们遇到 bug 可以自行对照一下。</p>
</blockquote>
<h1 id="驱动功能演示"><a href="#驱动功能演示" class="headerlink" title="驱动功能演示"></a>驱动功能演示</h1><p>​	目标：实现一个内核驱动模块，建立一个设备文件，在用户态用 mmap 将设备映射到各自的进程空间来实现进程间通信。首先编译并安装该内核模块，其中的<code>map_driver.c</code>便是该内核模块的源文件：</p>
<p><img src="https://s2.loli.net/2023/01/13/ZLTczpjRBvfghsq.png" alt="演示1.png"></p>
<p>​	然后编译运行用户态程序，一个程序负责写入，另一个程序可以从该共享内存区读出相应的值，其中的<code>ASDDDFFGGHHJJKKL</code>即写进程的输入，读进程可以看到对应的值以及其虚拟地址空间（<code>Page1 initialize...</code>信息是我预设的初始字符串）。</p>
<p><img src="https://s2.loli.net/2023/01/13/KXgIW9BOz5l7pkn.png" alt="演示2.png"></p>
<p>​	作为内核调试的重要一部分，还加入了日志信息可以查看内核加载卸载提示，对应进程的 pid ，读写信息，物理及逻辑地址等等，输入命令<code>dmesg</code>可以看到：</p>
<p><img src="https://s2.loli.net/2023/01/13/uptW5Vl9XTZOaCq.png" alt="演示3"></p>
<h1 id="内核开发原理"><a href="#内核开发原理" class="headerlink" title="内核开发原理"></a>内核开发原理</h1><p>​	在了解整个代码流程之前，由个比较重要的前置知识 - Linux 内核模块开发，我在这里就不单独介绍了，友友们如果没了解过可以先去看看这部分的小基础。Linux 模块由没链接成完整的可执行文件的目标代码组成，可以动态链接到内核中，而内核空开发也与 c库开发存在区别，你只需要了解内核模块的编译，加载，查询，卸载，日志打印等流程，以及 Linux 内核模块代码结构即可。-&gt; <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/420194002">如何编写一个Linux内核模块，这次手把手教你</a>。此外，这里有个[ Linux 内核 api 手册](<a target="_blank" rel="noopener" href="https://deepinout.com/linux-kernel-api">Linux内核API|极客笔记 (deepinout.com)</a>)，感觉蛮不错的，需要的时候可以查查。</p>
<p>​	该程序是实现一个内核驱动模块，通过共享设备文件来实现进程间通信。对于传统的读写文件方式，首先进程通过 open 函数打开设备文件，然后使用 read ,  write 以及 lseek 等调用进行 I&#x2F;O 操作， 这种方式是非常低效的，每一次 I&#x2F;O 操作都需要与外设交互，可能会频繁的触发系统调用导致 I&#x2F;O 效率的降低。所以我们在这里使用 mmap() 函数来解决这个问题，mmap 系统调用其实并不是完全为了用于共享内存而设计的，它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而 Posix 或 systemV 的共享内存 IPC 则纯粹用于共享内存目的，当然 mmap() 实现共享内存也是其主要应用之一。</p>
<p>​	<code>mmap</code>函数的主要作用是可以将一个文件或者设备的内容映射到内存当中，用户就可以通过一些内存操作方式(如<code>memcpy</code>、<code>memset</code>)对文件或者设备进行直接操作，不必再调用 read ，write 等进行 I&#x2F;O 设备文件操作。mmap 并不分配物理空间, 只是将文件映射到调用进程的地址空间里（只会占用 virutal memory）, 一旦进行文件读写，操作系统就会陷入缺页中断进行物理页框的分配。文件写完后，内存中的内容并不会立即更新到文件中，而是待内存回收时写回设备文件中，当然也可以调用 msync 进行显式同步，这样所写的内容就能立即保存到文件里了，这和自己的驱动设计有关。 此外，通过 mmap 来写文件的方式无法增加文件的长度, 因为要映射的长度在调用 mmap 的时候就决定。如果想取消内存映射，可以调用 munmap 来进行取消。</p>
<p><img src="https://s2.loli.net/2023/01/13/7XbBUgv9NDpwCdJ.png" alt="image.png"></p>
<p>​	mmap 本身是一个很复杂的系统调用过程，每个版本的设计也有所不同，我们先看一下基于 Linux 4.x 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot , <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>start：要映射到的内存区域的起始地址，通常都是用NULL，表示由内核来指定该内存地址。</li>
<li>length：要映射的内存区域的大小。</li>
<li>prot：期望的内存保护标志，不能与文件的打开模式冲突，可以通过 or 运算合理地组合在一起。<ul>
<li>PROT_EXEC  ：页内容可以被执行</li>
<li>PROT_READ  ： 页内容可以被读取</li>
<li>PROT_WRITE ： 页可以被写入</li>
<li>PROT_NONE  ：页不可访问</li>
</ul>
</li>
<li>flags：指定映射对象的类型，映射选项和映射页是否可以共享等标志位，下面给出几个比较重要的。<ul>
<li>MAP_FIXED ：使用指定的映射起始地址，如果由 start 和 len 参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</li>
<li>MAP_SHARED ：对映射区域的写入数据会复制回文件内, 而且允许其他映射该文件的进程共享。</li>
<li>MAP_PRIVATE ：建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。</li>
<li>MAP_LOCKED ：锁定映射区的页面，从而防止页面被交换出内存。</li>
<li>MAP_ANONYMOUS ：匿名映射，映射区不与任何文件关联。</li>
</ul>
</li>
<li>fd：文件描述符（由open函数返回）。</li>
<li>offset：以文件开始处的偏移量，该值应该为大小为 PAGE_SIZE 的整数倍，通常为0表示从文件头开始映射。</li>
</ul>
<p>​	mmap 系统调用的实现过程大致流程如下：</p>
<ol>
<li>先通过文件系统定位要映射的文件；  </li>
<li>权限检查, 映射的权限不会超过文件打开的方式, 也就是说如果文件是以只读方式打开, 那么则不允许建立一个可写映射；</li>
<li>创建一个vma对象, 并对之进行初始化；</li>
<li>调用映射文件的mmap函数, 其主要工作是给vm_ops向量表赋值；</li>
<li>把该vma链入该进程的vma链表中, 如果可以和前后的vma合并则合并；</li>
<li>如果是要求VM_LOCKED(映射区不被换出)方式映射, 则发出缺页请求, 把映射页面读入内存中。</li>
</ol>
<p>​	总体来说 mmap 的调用过程复杂，短时间内还没法做到很深的掌握，下面我们按照其调用流程依次做一个简单的源码分析，为后面的内核开发做个小铺垫。下面是大体的 mmap 函数调用栈帧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mmap</span>()</span><br><span class="line">└→	<span class="built_in">sys_mmap</span>()</span><br><span class="line">    └→ <span class="built_in">sys_mmap_pgoff</span>()</span><br><span class="line">    	└→ <span class="built_in">vm_mmap_pgoff</span>()</span><br><span class="line">            └→ <span class="built_in">do_mmap_pgoff</span>() ※</span><br><span class="line">               └→ <span class="built_in">mmap_region</span>()</span><br><span class="line">                  └→ file-&gt;f_op-&gt;<span class="built_in">mmap</span>(file, vma);</span><br></pre></td></tr></table></figure>

<p>​	mmap 是通过系统调用进入内核，其对应的内核系统调用是<code>sys_mmap</code>函数，下面是 x86 下的系统调用表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta"># arch/x86/entry/syscalls/syscall_64.tbl	64位系统下的mmap系统调用</span></span><br><span class="line"><span class="number">9</span>	common	mmap			sys_mmap</span><br><span class="line"><span class="number">10</span>	common	mprotect		sys_mprotect</span><br><span class="line"><span class="number">11</span>	common	munmap			sys_munmap</span><br></pre></td></tr></table></figure>

<p>​	<code>sys_mmap</code>的源码如下所示，主要处理了 offset 的页对齐问题，并进入<code>sys_mmap_pgoff</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sys_mmap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> prot, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">unsigned</span> <span class="type">long</span> fd, <span class="type">unsigned</span> <span class="type">long</span> off)</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> error;</span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (off &amp; ~PAGE_MASK) <span class="comment">// 判断offset是否是页对齐，如果不是页对齐就返回错误</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = sys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<code>sys_mmap_pgoff</code>函数主要处理了文件映射和匿名映射的预处理，下一步进入<code>vm_mmap_pgoff</code>函数，<code>vm_mmap_pgoff</code>函数处理了安全性问题，然后就进入下一关键的函数<code>do_mmap_pgoff</code>（下面的代码里写了详细的注释步骤）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">do_mmap_pgoff</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr, </span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot, </span></span><br><span class="line"><span class="params">              <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1. 获取一个未被使用的虚拟内存区，并返回其起始地址</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 根据映射类型做一些 flag 值的设定和错误检查。</span></span><br><span class="line">	<span class="keyword">if</span> (file) &#123; <span class="comment">// 如果file不为NULL，则表示是基于文件的映射，否则是匿名映射</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file); <span class="comment">// 根据file获取inode结构</span></span><br><span class="line">		<span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123; <span class="comment">// 根据是私有映射还是共享映射进行不同的处理</span></span><br><span class="line">		<span class="keyword">case</span> MAP_SHARED: <span class="comment">// 共享映射</span></span><br><span class="line">			<span class="keyword">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE))</span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE)) <span class="comment">// 判断是否为APPEND-ONLY文件，mmap不允许写入这种类型文件</span></span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span> (locks_verify_locked(file))</span><br><span class="line">				<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 更新一系列的使用于vm_area_struct的flag</span></span><br><span class="line">			vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">			<span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">				vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> MAP_PRIVATE: <span class="comment">// 私有映射，也是设置flag</span></span><br><span class="line">			<span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ)) <span class="comment">// 如果文件本身不允许读，那么就直接返回</span></span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line">			<span class="keyword">if</span> (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC) &#123;</span><br><span class="line">				<span class="keyword">if</span> (vm_flags &amp; VM_EXEC)</span><br><span class="line">					<span class="keyword">return</span> -EPERM;</span><br><span class="line">				vm_flags &amp;= ~VM_MAYEXEC;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!file-&gt;f_op-&gt;mmap)</span><br><span class="line">				<span class="keyword">return</span> -ENODEV;</span><br><span class="line">			<span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 匿名映射，也是设置flag</span></span><br><span class="line">		<span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">		<span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">			<span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			pgoff = <span class="number">0</span>; <span class="comment">// 共享匿名映射忽略pgoff</span></span><br><span class="line">			vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">			pgoff = addr &gt;&gt; PAGE_SHIFT; <span class="comment">// 匿名私有映射使用分配出来的addr作为pgoff</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 3. 调用 mmap_region() 函数继续进行映射操作</span></span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	总结起来该函数主要就是申请一段虚拟内存地址区域，然后根据映射类型做一些 flag 值的设定和错误检查，最后调用 <code>mmap_region()</code> 函数来进行进程的用户空间映射操作。接下来我们继续看看下一层的 <code>mmap_region()</code> 函数的实现，其完成了最后的映射过程，即将用户需要映射的虚拟地址范围加入当前进程的<code>mm_struct</code>结构中。</p>
<blockquote>
<p>对了，在往下探究之前请确保你对 <code>mm_struct</code>结构体和<code>vm_area_struct</code>结构体还算了解。我在上一篇文章有对其的介绍，不了解的同学可以先看看上一篇文章。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">mmap_region</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">int</span> vm_flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> accountable)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前进程的 mm_struct 结构。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">int</span> correct_wcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 申请一个虚拟内存区管理结构(vma)</span></span><br><span class="line">    <span class="comment">// 用find_vma_links函数寻找当前进程的虚拟地址空间所管理的内存块(vma)是否与目前预备分配的内存块的地址有相交的关系，如果有先将其unmap</span></span><br><span class="line">	<span class="keyword">if</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link, &amp;rb_parent)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (do_munmap(mm, addr, len))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> munmap_back;</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前申请的虚拟地址空间是否可以当前进程的虚拟地址空间进行合并，</span></span><br><span class="line">    <span class="comment">// 如果可以合并，直接修改当前进程的vma的vm_start和vm_end的值。</span></span><br><span class="line">	vma = vma_merge(mm, prev, addr, addr + len, vm_flags, <span class="literal">NULL</span>, file, pgoff, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (vma)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">// 如果无法合并，根据用户申请的地址空间范围，分配一个新的vma结构。</span></span><br><span class="line">	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化vma结构各个字段的信息</span></span><br><span class="line">    vma-&gt;vm_mm = mm;</span><br><span class="line">    vma-&gt;vm_start = addr;</span><br><span class="line">    vma-&gt;vm_end = addr + len;</span><br><span class="line">    vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    vma-&gt;vm_page_prot = protection_map[vm_flags &amp; (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)];</span><br><span class="line">    vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;	<span class="comment">// 文件映射</span></span><br><span class="line">        ...</span><br><span class="line">        vma-&gt;vm_file = file;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. 此处是内存映射的关键点，调用文件系统的mmap函数作处理，</span></span><br><span class="line"><span class="comment">         * 该函数可自定义，文件系统会根据设计设定各自的mmap函数。</span></span><br><span class="line"><span class="comment">         * 同时还设置vma结构的 fault() 回调函数去处理page fault的情况。</span></span><br><span class="line"><span class="comment">         *    vma对象的 fault() 回调函数的作用是：</span></span><br><span class="line"><span class="comment">         *        - 当访问的虚拟内存没有映射到物理内存时，</span></span><br><span class="line"><span class="comment">         *        - 将会调用 fault() 回调函数对虚拟内存地址映射到物理内存地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        error = file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 匿名映射</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 把 vma 结构连接到进程虚拟内存区的链表和红黑树中。</span></span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	我们可以看到，该函数根据用户需要分配的地址空间的信息，或扩展当前的进程的虚拟地址空间范围，或创建一个新的 vma 结构加入到进程的 mm_struct 当中，这样当前进程就有可以直接访问的 mmap 分配的内存区域，自此完成了整个 mmap 的映射过程了。不过注意这里只是分配了 vma 结构到进程的虚拟地址空间当中，只有实际访问页面的时候才会触发 page-fault 缺页异常，并给这些刚刚分配的虚拟地址空间的 vma 结构分配物理页框并建立页表。</p>
<p>​	因此，对于多进程的共享文件映射，每个进程在调用 mmap 时都是单独建立自己的 vma 区域。在后续访问中，通过 page-fault 缺页异常构建自己的物理页框映射时，需要花较长时间访问硬盘才能将该文件对应的页的数据读入到内存，相比而言，共享匿名映射就会更加快速。</p>
<p>​	自此， mmap 的通用流程就该结束了，当执行到<code>error = file-&gt;f_op-&gt;mmap(file, vma);</code>这一句时，正如上面所分析，该<code>mmap(file, vma)</code> 函数由各个设备的模块自定义，而我们后面写的内核模块其中一个任务也就是完成这部分代码。</p>
<p>​	接下来我们再来简单看看缺页过程吧，mmap 众所周知只分配虚拟地址，当进程在实际读写时亦触发缺页中断，进而分配物理页框并建立页表映射。缺页异常的调用过程实际上也是相当复杂，这里我们就不再过多介绍了，这有篇文章，可以参考一下 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/540850512">缺页中断</a>，大体调用栈如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">do_page_fault</span>()</span><br><span class="line">└→ <span class="built_in">handle_mm_fault</span>()</span><br><span class="line">   └→ <span class="built_in">handle_pte_fault</span>()</span><br><span class="line">      └→ <span class="built_in">do_linear_fault</span>()</span><br><span class="line">         └→ __do_fault() ※</span><br></pre></td></tr></table></figure>

<p>​	我们直接来看一下最后一步，<code>__do_fault()</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__do_fault(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd, <span class="type">pgoff_t</span> pgoff,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vmf.virtual_address = address &amp; PAGE_MASK; </span><br><span class="line">    vmf.pgoff = pgoff;                       </span><br><span class="line">    vmf.flags = flags;                       </span><br><span class="line">    vmf.page = <span class="literal">NULL</span>;       </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果虚拟内存管理区提供了 falut() 回调函数，那么将调用此函数来获取要映射的物理内存页，</span></span><br><span class="line">    <span class="comment">//    我们在 mmap() 系统调用的实现中看到，已经将其设置为 map_fault() 函数了。</span></span><br><span class="line">    <span class="comment">//    不同版本的 Linux 源码的该函数定义不一样，</span></span><br><span class="line">    <span class="comment">//    我们实现的在头文件中定义这样 vm_fault_t (*fault)(struct vm_fault *vmf);只有一个参数</span></span><br><span class="line">    <span class="keyword">if</span> (likely(vma-&gt;vm_ops-&gt;fault)) &#123;</span><br><span class="line">        ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(pte_same(*page_table, orig_pte))) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2. 通过物理内存页生成一个页表项值。</span></span><br><span class="line">        entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">            entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将虚拟内存地址映射到物理内存。</span></span><br><span class="line">        set_pte_at(mm, address, page_table, entry);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	函数主要通过调用虚拟内存管理区结构（vma）的 <code>fault()</code> 回调函数（也就是我们后面需要自定义的函数）来获取到文件的页缓存。并将虚拟内存地址映射到页缓存的物理内存页（也就是将进程的页表项设置为上面生成的页表项的值）。铺垫完这些前置知识后，接下来我们就一起来看看模块的代码具体实现。</p>
<h1 id="代码流程分析"><a href="#代码流程分析" class="headerlink" title="代码流程分析"></a>代码流程分析</h1><h3 id="map-driver-c"><a href="#map-driver-c" class="headerlink" title="map_driver.c"></a>map_driver.c</h3><p>​	首先来看看内核驱动模块的源代码文件，该文件的函数可以分成三部分，第一部分是模块注册和退出函数，第二部分是 file_operations 函数指针，第三部分便是 vm_operations_struct 的函数指针，下面我们将依次进行分析。</p>
<p>​	首先是第一部分模块注册和退出函数，宏定义方面，<code>MAP_PAGE_COUNT</code>为我们想创建的10个页面，每个页面的大小<code>PAGE_SIZE</code>的宏可在<code>linux/pages.h</code>下找到，<code>MAP_DEV_NAME</code> 为设备名，设备号我们采用动态分配。接下来的几个字段均和设备有关，定义于<code>linux/cdev.h</code>和<code>linux/divice.h</code>中。</p>
<p>​	<code>struct file_operations</code>结构体定义在<code>linux/fs.h</code>下，它是 fs_struct 的一个成员，用来存放可对文件执行的函数操作指针，而<code>struct vm_operations_struct</code>在<code>linux/mm.h</code>下，它是 mm_struct 的一个成员，表示可对 vma 执行的函数操作指针。最后的<code>static char *vmalloc_area = NULL;</code>我们在后面会用到，用来记录分配的页面逻辑地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_PAGE_COUNT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_LEN (PAGE_SIZE * MAP_PAGE_COUNT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_DEV_NAME <span class="string">&quot;mmap_dirver_dev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">map_dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">my_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">my_device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct file_operations handler */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct vm_operations_struct handler */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vopen</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vclose</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span>;</span><br><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">map_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mapdrvo_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .mmap = mapdrv_mmap,</span><br><span class="line">    .open = mapdrv_open,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">map_vm_ops</span> =</span> &#123;</span><br><span class="line">    .open = map_vopen,</span><br><span class="line">    .close = map_vclose,</span><br><span class="line">    .fault = map_fault,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *vmalloc_area = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);	<span class="comment">// 证书</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;sqq&quot;</span>);	<span class="comment">// 作者</span></span><br></pre></td></tr></table></figure>

<p>​	模块加载函数需要完成两件事，其一为设备注册，我们使用动态申请设备号的注册方法，具体流程是 <code>register_chrdev_region()</code> 动态申请该设备号，<code>cdev_init()</code> 用于初始化 cedv 结构体，<code>cdev_add()</code> 用于添加一个字符设备到操作系统，<code>class_create()</code> 用于自动创建类和设备节点，这样我们就不必手动在 <code>/dev</code> 下创建设备文件了。这部分其实是一个单独的话题，设备驱动开发，因为我现在对其也不是特别了解，调试也花了不少时间，其中涉及到很多结构体关联，感兴趣可以自己去深入研究一下~</p>
<p>​	其二为页面的申请，我们使用 <code>vmalloc()</code>函数进行页面的申请，然后在循环里，为每个物理页框<code>SetPageReserved()</code>置位，通过设置 Page 结构的 flag 成员变量，将 reserved 位置1，来将页框的属性设为占用，避免操作系统回收。而<code>struct page *vmalloc_to_page(const void *addr)</code>函数则是通过逻辑地址 addr 来寻找其物理页框的函数。为了方便观察，我们在每个页面内填充内容<code>&quot;Page%d initialize...&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mapdrv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;alloc_chrdev_region is failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;map_dev, &amp;mapdrvo_fops);</span><br><span class="line">    ret = cdev_add(&amp;map_dev, devid, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Add dev is failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_class = class_create(THIS_MODULE, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!my_class)</span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create calss failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_device = device_create(my_class, <span class="literal">NULL</span>, devid, <span class="literal">NULL</span>, MAP_DEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!my_device)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;create device failed\n&quot;</span>);</span><br><span class="line">        unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;map_dev);</span><br><span class="line">        class_destroy(my_class);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;chrdev[id:%d %d] register successfull!\n&quot;</span>, MAJOR(devid), MINOR(devid));</span><br><span class="line"></span><br><span class="line">    vmalloc_area = vmalloc(MAP_LEN);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; virt_addr &lt; (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + MAP_LEN; virt_addr += PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        SetPageReserved(vmalloc_to_page((<span class="type">void</span> *)virt_addr));</span><br><span class="line">        <span class="built_in">sprintf</span>((<span class="type">char</span> *)virt_addr, <span class="string">&quot;Page%d initialize...&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* printk(&quot;vmalloc_area at 0x%lx (phys 0x%lx)\n&quot;,</span></span><br><span class="line"><span class="comment">    (unsigned long)vmalloc_area,(unsigned long)vmalloc_to_pfn((void *)vmalloc_area) &lt;&lt; PAGE_SHIFT);  */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;map_driver module init!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	模块退出函数与之相反，物理页面标记为可释放，并 vfree 掉虚拟地址，最后注销掉相关类和设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mapdrv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* unreserve all pages */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area; virt_addr &lt; (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + MAP_LEN; virt_addr += PAGE_SIZE)</span><br><span class="line">        ClearPageReserved(vmalloc_to_page((<span class="type">void</span> *)virt_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vmalloc_area)</span><br><span class="line">        vfree(vmalloc_area);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev_region(devid, <span class="number">1</span>);</span><br><span class="line">    cdev_del(&amp;map_dev);</span><br><span class="line">    device_del(my_device);</span><br><span class="line">    class_destroy(my_class);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;delete device /sys/class/%s \n&quot;</span>,MAP_DEV_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;delete device /dev/%s\n&quot;</span>, MAP_DEV_NAME);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;map_driver module exit!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	第二部分就是涉及到和 mmap() 函数相关的东西了，我们前面提到，在用户态的 mmap 函数进入到 mmap_region 函数里的这一句 <code>error = file-&gt;f_op-&gt;mmap(file, vma);</code>时，便是该进入我们 <code>struct file_operations mapdrvo_fops </code>结构体里自定义的 mmap 函数里执行了。接下来看看相关代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static struct file_operations mapdrvo_fops = &#123;</span></span><br><span class="line"><span class="comment">    .owner = THIS_MODULE,</span></span><br><span class="line"><span class="comment">    .mmap = mapdrv_mmap,</span></span><br><span class="line"><span class="comment">    .open = mapdrv_open,</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAP_LEN)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Size too big\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  写进程的 vma 区域必须是可共享的 */</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_flags &amp; VM_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Writeable mappings can not be privated!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 锁住物理页框，防止被换出 */</span></span><br><span class="line">    vma-&gt;vm_flags |= VM_LOCKONFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 核心代码，设置对 mmap 区域的处理方法。</span></span><br><span class="line">        vma-&gt;vm_ops = &amp;map_vm_ops;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;offset out of range\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	核心代码便是<code>vma-&gt;vm_ops = &amp;map_vm_ops;</code>，通过设置该域对 mmap 区域的处理方法，包括后续我们所说的缺页中断的处理函数，以方便进程在实际读写时调用该方法函数。对了，我们还定义了 open 函数，来看看吧，该函数主要就打印一下主调进程的信息方便记录一下日志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mapdrv_open</span><span class="params">(<span class="keyword">struct</span> inode *inoe, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;process[id: %d]: %s is mapping...\n&quot;</span>, current-&gt;pid, current-&gt;comm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	接下来就是我们的第三部分，对应<code>struct vm_operations_struct map_vm_ops</code>里，我们完成了对虚拟内存的这三个操作的函数体实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;linux.mm.h&gt;  --这是内核源码中对 struct vm_operations_struct 的注释</span></span><br><span class="line"><span class="comment"> * These are the virtual MM functions - opening of an area, closing and</span></span><br><span class="line"><span class="comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span></span><br><span class="line"><span class="comment"> * to the functions called when a no-page or a wp-page exception occurs. </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>​	首先来看看<code>vm_fault_t map_fault(struct vm_fault *vmf)</code>函数，其参数为<code>struct vm_fault</code>结构体，其定义于<code>linux/mm.h</code>，用于描述缺页相关页面参数。<code>struct vm_area_struct *vma;</code>就指向其所在线性映射区的 VAM，<code>unsigned long address;</code>即产生缺页的地址（注意：是进程空间中的逻辑地址），<code>*pmd, *pud, orig_pte </code>是一些页目录项和页表项，还有最重要的一项，就是<code>struct page *page;</code>，这就是需要建立的物理页框的结构体指针，需要指向对应页框的物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span>	<span class="comment">/* Target VMA */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;		<span class="comment">/* FAULT_FLAG_xxx flags */</span></span><br><span class="line">	<span class="type">gfp_t</span> gfp_mask;			<span class="comment">/* gfp mask to be used for allocations */</span></span><br><span class="line">	<span class="type">pgoff_t</span> pgoff;			<span class="comment">/* Logical page offset based on vma */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> address;		<span class="comment">/* Faulting virtual address */</span></span><br><span class="line">	<span class="type">pmd_t</span> *pmd;			<span class="comment">/* Pointer to pmd entry matching</span></span><br><span class="line"><span class="comment">					 * the &#x27;address&#x27; */</span></span><br><span class="line">	<span class="type">pud_t</span> *pud;			<span class="comment">/* Pointer to pud entry matching</span></span><br><span class="line"><span class="comment">					 * the &#x27;address&#x27;</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	<span class="type">pte_t</span> orig_pte;			<span class="comment">/* Value of PTE at the time of fault */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cow_page</span>;</span>		<span class="comment">/* Page handler may use for COW fault */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span>	<span class="comment">/* Cgroup cow_page belongs to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>		<span class="comment">/* -&gt;fault handlers should return a</span></span><br><span class="line"><span class="comment">					 * page here, unless VM_FAULT_NOPAGE</span></span><br><span class="line"><span class="comment">					 * is set (which is also implied by</span></span><br><span class="line"><span class="comment">					 * VM_FAULT_ERROR).</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	下面来看看我们的<code>vm_fault_t map_fault(struct vm_fault *vmf)</code>函数的具体实现。</p>
<blockquote>
<p> 请注意该函数的目的是：将页在内核空间中的线性（逻辑）地址所对应的物理地址映射到进程用户空间的某线性（逻辑）地址中，而不是申请物理页框，物理页框在之前缺页流程中已经申请好了！请仔细揣摩一下这段话。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page fault handler */</span></span><br><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">map_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset, kernel_virt_addr, phy_addr;</span><br><span class="line">    offset = vmf-&gt;address - vmf-&gt;vma-&gt;vm_start;</span><br><span class="line">    kernel_virt_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_area + (<span class="type">unsigned</span> <span class="type">long</span>)(vmf-&gt;pgoff &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误检查</span></span><br><span class="line">    <span class="keyword">if</span> ((vmf-&gt;vma == <span class="literal">NULL</span>) || (vmalloc_area == <span class="literal">NULL</span>) || (offset &gt;= MAP_LEN))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;return VM_FAULT_SIGBUS!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    phy_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vmalloc_to_pfn((<span class="type">void</span> *)kernel_virt_addr) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    page = vmalloc_to_page((<span class="type">void</span> *)kernel_virt_addr);</span><br><span class="line">    </span><br><span class="line">    get_page(page);</span><br><span class="line">    vmf-&gt;page = page;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;%s: map ker_virt_addr:0x%lx (phy_addr:0x%016lx) to usr_virt_addr:0x%lx , size: 0x%lx, page:%ld \n&quot;</span>,</span><br><span class="line">           __func__, kernel_virt_addr, phy_addr, vmf-&gt;address, PAGE_SIZE, vmf-&gt;pgoff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>vmf-&gt;address，vmalloc_area，vmf-&gt;pgoff</code>：之前有提到，<code>vmf-&gt;address</code>表示该缺页在用户空间的逻辑地址。<code>vmalloc_area</code>是全局变量，在模块初始化函数里赋值的，表示页面在内核空间中的逻辑地址。<code>vmf-&gt;pgoff</code>则表示该缺页的编号，通常是0，1，2…。</li>
<li><code>unsigned long offset, kernel_virt_addr, phy_addr;</code>：<code>offset</code>字段表示该缺页与所在 VMA 起始地址的偏移，由于申请的页面大小为4096，因此该 <code>offset</code>的值通常是0，4096，8192…，<code>kernel_virt_addr</code>表示页在内核空间中的线性地址，<code>phy_addr</code>表示页框的物理地址。</li>
<li><code>phy_addr = (unsigned long)vmalloc_to_pfn((void *)kernel_virt_addr) &lt;&lt; PAGE_SHIFT;</code>：<code>vmalloc_to_pfn</code>函数可通过内核空间线性地址找到对应页的物理页框号并返回，而物理页框左移<code>PAGE_SHIFT</code>位便是我们要寻找的物理地址。</li>
<li><code>page = vmalloc_to_page((void *)kernel_virt_addr);</code>：该函数可通过内核空间线性地址返回对应页框的页描述符指针。</li>
<li><code>get_page(page);</code>：该函数用于该物理页框的引用计数 +1。</li>
<li><code>vmf-&gt;page = page;</code>：这个语句便是我们关键的动作了，将 vmf 结构体的 page 字段指向物理页框的描述符，便完成了映射过程。</li>
</ul>
<p>​	最后，再来看看 open 和 close 的函数实现，这很简单啦，只是为了写个日志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* open handler for vm area */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vopen</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;mapping vma is opened..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* close handler form vm area */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">map_vclose</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;mapping vma is closed..\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	到这里我们的故事终于就要结束了，太不容易了。</p>
<h3 id="maptest-read-c"><a href="#maptest-read-c" class="headerlink" title="maptest_read.c"></a>maptest_read.c</h3><p>​	下面是我们用户空间的读程序。mmap 参数：可读，私有，加锁（防止被换出）。 mmap 返回的自然是用户空间的线性地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_PAGE_COUNT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN (MAP_PAGE_COUNT * 4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/mmap_driver_dev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *vadr = mmap(<span class="number">0</span>, LEN, PROT_READ, MAP_PRIVATE | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> loop = <span class="number">0</span>; loop &lt; MAP_PAGE_COUNT; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-10s----%lx]\n&quot;</span>, vadr + <span class="number">4096</span> * loop, (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)vadr + <span class="number">4096</span> * loop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)	<span class="comment">//便于查看调试的时候查看进程pid</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="maptest-write-c"><a href="#maptest-write-c" class="headerlink" title="maptest_write.c"></a>maptest_write.c</h3><p>​	下面是我们用户空间的写程序，向第一个页面写入一个字符串。mmap 参数：可读，可写，共享，加锁（防止被换出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN (10 * 4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/mmap_driver_dev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *vadr = mmap(<span class="number">0</span>, LEN, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_LOCKED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input the info to Page0:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, vadr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><blockquote>
<p>这里只需要强调一点就是，内核编译默认采用 C90 标准，所以某些语法会导致 make 报错，解决的方法可以是在 Makefile 文件里添加进这句话<code>ccflags-y := -std=gnu99 -Wno-declaration-after-statement</code>。（比如在阅读很多开源内核模块时可能发现所有变量定义都是统一放在函数开头的，这就是 C90 的一个特点）</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/01/12/3ScKFZluzn9Bri5.png" alt="c90编译内核.png"></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MODULE_SIG := n</span><br><span class="line">ccflags-y := -std=gnu99 -Wno-declaration-after-statement</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">	obj-m += map_driver.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">	KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="section">default:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span>  M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@rm -rf *.o *.mod *.mod.c *.mod.o *.ko *.order *.symvers .*.cmd .tmp_versions</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外想强调一点，就是 printk 进行内核打印日志时，打印的字符串末尾一定要加换行符 \n ，否则可能因为缓冲区问题导致无法正常打印，而自己还以为是程序本身有 bug 出错。</p>
</blockquote>
<p>​	到这里这一章所有的故事就讲完了，我自己从写代码，各种 bug 调试到完成该文章也是搞了整整三天，收获还是很大的，这篇应该还算写的蛮详细了，语言表达上也是反复斟酌。最后，所有代码都放在 Gitee上了 <a target="_blank" rel="noopener" href="https://gitee.com/ChaceQ/linuxk_blog_code.git">linuxk_blog_code1 </a>，希望对友友们有帮助！</p>
<hr>
<h2 id="踩坑补充"><a href="#踩坑补充" class="headerlink" title="踩坑补充"></a>踩坑补充</h2><ol>
<li><p>模块退出函数里的这两句一定不能写反了，否则在卸载模块时会内核崩溃，提示<code>ERROR: Module is in use.</code>导致该模块无法被卸载，查看内核日志发现是 <code>device_del(my_device);</code>函数里出现空指针异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_del(my_device);</span><br><span class="line">class_destroy(my_class);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://s2.loli.net/2023/01/12/MEzu5V6x4Y1SrWv.png" alt="image.png"></p>
<ol start="2">
<li><p>执行主程序时一定要加管理员权限<code>sudo ./maptest_read</code>，因为我们创建的设备文件是仅 root 用户才能打开的，所以不加管理员权限直接运行程序会报错，一不小心就可能将问题重心转向排查是否设备文件本身出错。</p>
<p><img src="https://s2.loli.net/2023/01/12/k4js9oRAYviTa7t.png" alt="image.png"></p>
</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/tags/">tags</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/Operation_System/">Operation System</a></li>
        
          <li><a href="/Computer_Networks/">Computer Networks</a></li>
        
          <li><a href="/General/">General</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E4%B8%80-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">Linux内核分析应用一 - 多进程共享内存内核驱动模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">驱动功能演示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内核开发原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">代码流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-driver-c"><span class="toc-number">4.0.1.</span> <span class="toc-text">map_driver.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maptest-read-c"><span class="toc-number">4.0.2.</span> <span class="toc-text">maptest_read.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maptest-write-c"><span class="toc-number">4.0.3.</span> <span class="toc-text">maptest_write.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile"><span class="toc-number">4.0.4.</span> <span class="toc-text">Makefile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B8%A9%E5%9D%91%E8%A1%A5%E5%85%85"><span class="toc-number">4.1.</span> <span class="toc-text">踩坑补充</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&text=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&is_video=false&description=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Linux内核分析应用一 - 多进程共享内存内核驱动模块&body=Check out this article: https://www.chaceq.love/2023/01/13/03Linux_kernel_1/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&title=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&name=Linux内核分析应用一 - 多进程共享内存内核驱动模块&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://www.chaceq.love/2023/01/13/03Linux_kernel_1/&t=Linux内核分析应用一 - 多进程共享内存内核驱动模块"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    sqq
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/Operation_System/">Operation System</a></li><!--
     --><!--
       --><li><a href="/Computer_Networks/">Computer Networks</a></li><!--
     --><!--
       --><li><a href="/General/">General</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
